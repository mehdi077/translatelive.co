### React Query Setup with Queries and Mutations

Source: https://tanstack.com/query/v5/docs/framework/react/quick-start

Complete React Query application setup demonstrating query fetching, mutation handling, and query invalidation. This example creates a QueryClient, wraps the app with QueryClientProvider, fetches todos using useQuery, and handles todo creation with useMutation. Requires @tanstack/react-query package and API functions (getTodos, postTodo).

```tsx
import {
  useQuery,
  useMutation,
  useQueryClient,
  QueryClient,
  QueryClientProvider,
} from '@tanstack/react-query'
import { getTodos, postTodo } from '../my-api'

// Create a client
const queryClient = new QueryClient()

function App() {
  return (
    // Provide the client to your App
    <QueryClientProvider client={queryClient}>
      <Todos />
    </QueryClientProvider>
  )
}

function Todos() {
  // Access the client
  const queryClient = useQueryClient()

  // Queries
  const query = useQuery({ queryKey: ['todos'], queryFn: getTodos })

  // Mutations
  const mutation = useMutation({
    mutationFn: postTodo,
    onSuccess: () => {
      // Invalidate and refetch
      queryClient.invalidateQueries({ queryKey: ['todos'] })
    },
  })

  return (
    <div>
      <ul>
        {query.data?.map((todo) => (
          <li key={todo.id}>{todo.title}</li>
        ))}
      </ul>

      <button
        onClick={() => {
          mutation.mutate({
            id: Date.now(),
            title: 'Do Laundry',
          })
        }}
      >
        Add Todo
      </button>
    </div>
  )
}

render(<App />, document.getElementById('root'))
```

--------------------------------

### Install Dependencies and Start Development Server

Source: https://tanstack.com/query/v5/docs/framework/svelte/examples/simple

This terminal output demonstrates the process of installing project dependencies using `npm` and then starting the development server with the `dev` script. It indicates successful package installation and the initiation of the `vite` development server.

```shell
added 50 packages in 1s
11 packages are looking for funding
run `npm fund` for details
> dev
> vite
```

--------------------------------

### Vue Query Setup with Queries, Mutations, and Invalidation

Source: https://tanstack.com/query/v5/docs/framework/vue/quick-start

Complete Vue 3 example demonstrating the three core concepts of Vue Query: accessing the QueryClient, performing queries to fetch data, executing mutations to modify data, and invalidating queries to refetch data. The example shows how to handle loading, error, and success states in both script and template, including manual query invalidation on mutation success.

```vue
<script setup>
import { useQueryClient, useQuery, useMutation } from '@tanstack/vue-query'

// Access QueryClient instance
const queryClient = useQueryClient()

// Query
const { isPending, isError, data, error } = useQuery({
  queryKey: ['todos'],
  queryFn: getTodos,
})

// Mutation
const mutation = useMutation({
  mutationFn: postTodo,
  onSuccess: () => {
    // Invalidate and refetch
    queryClient.invalidateQueries({ queryKey: ['todos'] })
  },
})

function onButtonClick() {
  mutation.mutate({
    id: Date.now(),
    title: 'Do Laundry',
  })
}
</script>

<template>
  <span v-if="isPending">Loading...</span>
  <span v-else-if="isError">Error: {{ error.message }}</span>
  <!-- We can assume by this point that `isSuccess === true` -->
  <ul v-else>
    <li v-for="todo in data" :key="todo.id">{{ todo.title }}</li>
  </ul>
  <button @click="onButtonClick">Add Todo</button>
</template>
```

--------------------------------

### Install Solid Query via Bun

Source: https://tanstack.com/query/v5/docs/framework/solid/installation

Install @tanstack/solid-query package using bun package manager as a modern alternative to npm.

```bash
bun add @tanstack/solid-query
```

--------------------------------

### Start Svelte Development Server

Source: https://tanstack.com/query/v5/docs/framework/svelte/examples/optimistic-updates

These commands are used to start the Svelte development server after a project has been created and dependencies installed. The `--open` flag allows for automatically opening the application in a new browser tab.

```bash
npm run dev

# or start the server and open the app in a new browser tab
npm run dev -- --open
```

--------------------------------

### Install Solid Query via NPM

Source: https://tanstack.com/query/v5/docs/framework/solid/installation

Install @tanstack/solid-query package using npm package manager. This is the standard installation method for Node.js projects.

```bash
npm i @tanstack/solid-query
```

--------------------------------

### Install Solid Query via pnpm

Source: https://tanstack.com/query/v5/docs/framework/solid/installation

Install @tanstack/solid-query package using pnpm package manager as an alternative to npm.

```bash
pnpm add @tanstack/solid-query
```

--------------------------------

### Install Solid Query via Yarn

Source: https://tanstack.com/query/v5/docs/framework/solid/installation

Install @tanstack/solid-query package using yarn package manager as an alternative dependency manager.

```bash
yarn add @tanstack/solid-query
```

--------------------------------

### Setup TanStack Query with Solid.js and DevTools

Source: https://tanstack.com/query/v5/docs/framework/solid/examples/simple

Initializes QueryClient and wraps the application with QueryClientProvider and SolidQueryDevtools. This establishes the foundation for query management and enables debugging capabilities in the application.

```typescript
import {
  QueryClient,
  QueryClientProvider,
  useQuery,
} from '@tanstack/solid-query'
import { SolidQueryDevtools } from '@tanstack/solid-query-devtools'
import { render } from 'solid-js/web'

const queryClient = new QueryClient()

export default function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <SolidQueryDevtools />
      <Example />
    </QueryClientProvider>
  )
}
```

--------------------------------

### Basic Vue Query Usage with <script setup>

Source: https://tanstack.com/query/v5/docs/framework/vue/installation

Demonstrates a basic example of using the `useQuery` hook from Vue Query within a Vue component using the `<script setup>` syntax. It fetches data with `getTodos` and exposes query states like `isPending`, `isFetching`, `isError`, `data`, and `error`.

```vue
<script setup>
import { useQuery } from '@tanstack/vue-query'

const { isPending, isFetching, isError, data, error } = useQuery({
  queryKey: ['todos'],
  queryFn: getTodos,
})
</script>

<template>...</template>
```

--------------------------------

### Implement basic data fetching with Solid Query

Source: https://tanstack.com/query/v5/docs/framework/solid/quick-start

This example demonstrates how to set up `QueryClientProvider` and use the `useQuery` hook to fetch data in a SolidJS application. It handles loading, error, and success states using Solid's `Switch` and `Match` components to display UI accordingly, fetching a list of todos.

```tsx
import {
  QueryClient,
  QueryClientProvider,
  useQuery,
} from '@tanstack/solid-query'
import { Switch, Match, For } from 'solid-js'

const queryClient = new QueryClient()

function Example() {
  const query = useQuery(() => ({
    queryKey: ['todos'],
    queryFn: fetchTodos,
  }))

  return (
    <div>
      <Switch>
        <Match when={query.isPending}>
          <p>Loading...</p>
        </Match>
        <Match when={query.isError}>
          <p>Error: {query.error.message}</p>
        </Match>
        <Match when={query.isSuccess}>
          <For each={query.data}>{(todo) => <p>{todo.title}</p>}</For>
        </Match>
      </Switch>
    </div>
  )
}

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Example />
    </QueryClientProvider>
  )
}
```

--------------------------------

### React Native Setup with AsyncStorage Persister

Source: https://tanstack.com/query/v5/docs/framework/react/plugins/createAsyncStoragePersister

Complete setup example using React Native's AsyncStorage with PersistQueryClientProvider to enable query persistence

```tsx
import AsyncStorage from '@react-native-async-storage/async-storage'
import { QueryClient } from '@tanstack/react-query'
import { PersistQueryClientProvider } from '@tanstack/react-query-persist-client'
import { createAsyncStoragePersister } from '@tanstack/query-async-storage-persister'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: 1000 * 60 * 60 * 24, // 24 hours
    },
  },
})

const asyncStoragePersister = createAsyncStoragePersister({
  storage: AsyncStorage,
})

const Root = () => (
  <PersistQueryClientProvider
    client={queryClient}
    persistOptions={{ persister: asyncStoragePersister }}
  >
    <App />
  </PersistQueryClientProvider>
)

export default Root
```

--------------------------------

### Import Solid Query from CDN via ESM.sh

Source: https://tanstack.com/query/v5/docs/framework/solid/installation

Load Solid Query directly in the browser using ESM.sh CDN without requiring a package manager or bundler. Add a module script tag to import QueryClient from the CDN.

```html
<script type="module">
  import { QueryClient } from 'https://esm.sh/@tanstack/solid-query'
</script>
```

--------------------------------

### Installing ESLint Plugin for TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/react/installation

Install @tanstack/eslint-plugin-query as a dev dependency using NPM, PNPM, Yarn, or Bun to catch bugs and inconsistencies. Recommended for development workflows. Installs as dev tool only.

```bash
npm i -D @tanstack/eslint-plugin-query

or

pnpm add -D @tanstack/eslint-plugin-query

or

yarn add -D @tanstack/eslint-plugin-query

or

bun add -D @tanstack/eslint-plugin-query
```

--------------------------------

### Install Project Dependencies (Bash)

Source: https://tanstack.com/query/v5/docs/framework/vue/examples/nuxt3

This `yarn install` command downloads and installs all necessary project dependencies defined in the `package.json` file. It ensures the project has all required packages for both development and production environments.

```bash
yarn install
```

--------------------------------

### Start Svelte development server

Source: https://tanstack.com/query/v5/docs/framework/svelte/examples/basic

Run the development server for a Svelte project after dependencies are installed. The command can be run with the --open flag to automatically open the app in a new browser tab.

```bash
npm run dev
```

```bash
npm run dev -- --open
```

--------------------------------

### SolidJS Home Component with Meta Title

Source: https://tanstack.com/query/v5/docs/framework/solid/examples/solid-start-streaming

This SolidJS component defines the main landing page for the Solid Query v5 demo. It utilizes `@solidjs/meta` to set the page title dynamically and renders an introductory message explaining the demo's focus on SSR with streaming support. It serves as the primary welcome view for the application.

```tsx
import { Title } from '@solidjs/meta'

export default function Home() {
  return (
    <main>
      <Title>Solid Query v5</Title>

      <h1>Solid Query v5</h1>

      <p>
        This demo demonstrates how Solid Query can be used in SSR, with
        streaming support. Use the links in the top left to navigate between the
        various examples.
      </p>
    </main>
  )
}
```

--------------------------------

### Set up QueryClient and QueryClientProvider with React Query

Source: https://tanstack.com/query/v5/docs/framework/react/examples/simple

Initialize QueryClient and wrap the application with QueryClientProvider to enable React Query functionality throughout the component tree. This setup includes ReactQueryDevtools for development debugging. The provider makes query client available to all child components via context.

```typescript
import React from 'react'
import ReactDOM from 'react-dom/client'
import {
  QueryClient,
  QueryClientProvider,
  useQuery,
} from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'

const queryClient = new QueryClient()

export default function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <ReactQueryDevtools />
      <Example />
    </QueryClientProvider>
  )
}
```

--------------------------------

### Installation Commands for Async Storage Persister

Source: https://tanstack.com/query/v5/docs/framework/react/plugins/createAsyncStoragePersister

Package installation commands using different package managers (npm, pnpm, yarn, bun) for the async storage persister utility

```bash
npm install @tanstack/query-async-storage-persister @tanstack/react-query-persist-client

pnpm add @tanstack/query-async-storage-persister @tanstack/react-query-persist-client

yarn add @tanstack/query-async-storage-persister @tanstack/react-query-persist-client

bun add @tanstack/query-async-storage-persister @tanstack/react-query-persist-client
```

--------------------------------

### Setup Solid.js App with TanStack Query Provider and Devtools

Source: https://tanstack.com/query/v5/docs/framework/solid/examples/default-query-function

Initializes the main App component with QueryClientProvider wrapping the application, enabling TanStack Query functionality throughout the component tree. Includes SolidQueryDevtools for debugging query state. Manages navigation between posts list and individual post view using Solid.js signals.

```typescript
function App() {
  const [postId, setPostId] = createSignal(-1)

  return (
    <QueryClientProvider client={queryClient}>
      <SolidQueryDevtools />
      <p>
        As you visit the posts below, you will notice them in a loading state
        the first time you load them. However, after you return to this list and
        click on any posts you have already visited again, you will see them
        load instantly and background refresh right before your eyes!{' '}
        <strong>
          (You may need to throttle your network speed to simulate longer
          loading sequences)
        </strong>
      </p>
      <Show when={postId() > -1} fallback={<Posts setPostId={setPostId} />}>
        <Post postId={postId()} setPostId={setPostId} />
      </Show>
    </QueryClientProvider>
  )
}

render(() => <App />, document.getElementById('root') as HTMLElement)
```

--------------------------------

### Setup QueryClient and Provider with TanStack React Query

Source: https://tanstack.com/query/v5/docs/framework/react/examples/auto-refetching

Initializes a QueryClient instance and wraps the application with QueryClientProvider to enable TanStack Query functionality throughout the component tree. This is the essential setup required for using TanStack Query hooks.

```typescript
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

const queryClient = new QueryClient()

export default function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Example />
    </QueryClientProvider>
  )
}
```

--------------------------------

### Define a Basic TanStack Query in Solid.js

Source: https://tanstack.com/query/v5/docs/framework/solid/guides/queries

This example demonstrates the basic setup of the `useQuery` hook in a Solid.js component. It shows how to import the hook and define a query with a unique `queryKey` and a `queryFn` to fetch data asynchronously.

```tsx
import { useQuery } from '@tanstack/solid-query'

function App() {
  const info = useQuery(() => { queryKey: ['todos'], queryFn: fetchTodoList })
}
```

--------------------------------

### Build Svelte Project for Production

Source: https://tanstack.com/query/v5/docs/framework/svelte/examples/optimistic-updates

This command compiles the Svelte application into a production-ready build, optimizing it for deployment. After building, `npm run preview` can be used to test the production build locally. Deployment may require installing a specific Svelte adapter.

```bash
npm run build
```

--------------------------------

### Initialize TanStack Query in Svelte Application

Source: https://tanstack.com/query/v5/docs/framework/svelte/examples/simple

This Svelte component (`App.svelte`) initializes the TanStack Query client and provides it to the application using `QueryClientProvider`. It also imports and renders the `Simple` component and includes `SvelteQueryDevtools` for debugging, demonstrating a basic setup for integrating TanStack Query into a Svelte project.

```svelte
<script lang="ts">
import { QueryClientProvider, 
QueryClient } from '@tanstack/
svelte-query'
import { SvelteQueryDevtools } from
'@tanstack/svelte-query-devtools'
import Simple from './lib/Simple.svelte'
const queryClient = new QueryClient()
</script>
<QueryClientProvider client={queryClient}>
<main>
<Simple />
</main>
<SvelteQueryDevtools />
</QueryClientProvider>
```

--------------------------------

### Installing React Query via Package Managers

Source: https://tanstack.com/query/v5/docs/framework/react/installation

Install @tanstack/react-query using NPM, PNPM, Yarn, or Bun. Compatible with React v18+ and works with ReactDOM and React Native. No additional dependencies required beyond the package manager.

```bash
npm i @tanstack/react-query

or

pnpm add @tanstack/react-query

or

yarn add @tanstack/react-query

or

bun add @tanstack/react-query
```

--------------------------------

### Setup QueryClient with Provider in React

Source: https://tanstack.com/query/v5/docs/framework/react/examples/infinite-query-with-max-pages

Initializes QueryClient and wraps the application with QueryClientProvider to enable TanStack Query functionality across the component tree. This is the required setup for using React Query hooks in the application.

```typescript
import React from 'react'
import {
  QueryClient,
  QueryClientProvider,
  useInfiniteQuery,
} from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'

const queryClient = new QueryClient()

export default function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Example />
    </QueryClientProvider>
  )
}
```

--------------------------------

### useMutation Hook - Complete Usage Example

Source: https://tanstack.com/query/v5/docs/framework/solid/reference/useMutation

Practical example demonstrating how to use the useMutation hook with all available callbacks and state management features.

```APIDOC
## useMutation Hook - Usage Example

### Complete Implementation

```javascript
import { useMutation } from '@tanstack/react-query';

const CreateUserMutation = () => {
  const mutation = useMutation({
    mutationFn: async (variables) => {
      const response = await fetch('/api/users', {
        method: 'POST',
        body: JSON.stringify(variables)
      });
      return response.json();
    },
    meta: {
      action: 'createUser',
      version: 1
    },
    onSuccess: (data, variables, context) => {
      console.log('User created:', data);
    },
    onError: (error, variables, context) => {
      console.error('Error creating user:', error);
    },
    onSettled: (data, error, variables, context) => {
      console.log('Mutation settled');
    }
  });

  const handleCreateUser = () => {
    mutation.mutate(
      { name: 'John Doe', email: 'john@example.com' },
      {
        onSuccess: (data) => {
          console.log('Custom success handler:', data);
        }
      }
    );
  };

  const handleCreateUserAsync = async () => {
    try {
      const data = await mutation.mutateAsync({
        name: 'Jane Doe',
        email: 'jane@example.com'
      });
      console.log('User created:', data);
    } catch (error) {
      console.error('Error:', error);
    }
  };

  return (
    <div>
      <button onClick={handleCreateUser} disabled={mutation.isPending}>
        Create User
      </button>
      <button onClick={handleCreateUserAsync} disabled={mutation.isPending}>
        Create User Async
      </button>
      <button onClick={() => mutation.reset()}>Reset</button>
      
      {mutation.isPending && <p>Creating user...</p>}
      {mutation.isError && <p>Error: {mutation.error.message}</p>}
      {mutation.isSuccess && <p>User created! ID: {mutation.data.id}</p>}
      <p>Status: {mutation.status}</p>
      <p>Submitted at: {mutation.submittedAt}</p>
      <p>Failure count: {mutation.failureCount}</p>
    </div>
  );
};
```
```

--------------------------------

### Install @tanstack/query-persist-client-core Package

Source: https://tanstack.com/query/v5/docs/framework/react/plugins/createPersister

Instructions for installing the `@tanstack/query-persist-client-core` package using various JavaScript package managers. This package provides the `experimental_createQueryPersister` utility for persisting queries.

```bash
npm install @tanstack/query-persist-client-core
```

```bash
pnpm add @tanstack/query-persist-client-core
```

```bash
yarn add @tanstack/query-persist-client-core
```

```bash
bun add @tanstack/query-persist-client-core
```

--------------------------------

### Install query persist client core package

Source: https://tanstack.com/query/v5/docs/framework/solid/plugins/createPersister

Installation commands for @tanstack/query-persist-client-core package using npm, pnpm, yarn, or bun package managers. This utility is also included in @tanstack/solid-query-persist-client package.

```bash
npm install @tanstack/query-persist-client-core
```

```bash
pnpm add @tanstack/query-persist-client-core
```

```bash
yarn add @tanstack/query-persist-client-core
```

```bash
bun add @tanstack/query-persist-client-core
```

--------------------------------

### Provide TanStack Query Client in Angular App

Source: https://tanstack.com/query/v5/docs/framework/angular/quick-start

Sets up the TanStack Query client provider in Angular applications. Supports both standalone component and NgModule-based architectures. Requires Angular's HTTP client module as a dependency.

```typescript
import { provideHttpClient } from '@angular/common/http'
import {
  provideTanStackQuery,
  QueryClient,
} from '@tanstack/angular-query-experimental'

bootstrapApplication(AppComponent, {
  providers: [provideHttpClient(), provideTanStackQuery(new QueryClient())],
})
```

```typescript
import { provideHttpClient } from '@angular/common/http'
import {
  provideTanStackQuery,
  QueryClient,
} from '@tanstack/angular-query-experimental'

@NgModule({
  declarations: [AppComponent],
  imports: [BrowserModule],
  providers: [provideTanStackQuery(new QueryClient())],
  bootstrap: [AppComponent],
})
export class AppModule {}
```

--------------------------------

### TanStack Query Setup with QueryClient Provider

Source: https://tanstack.com/query/v5/docs/framework/react/examples/optimistic-updates-ui

Initializes QueryClient and wraps the application with QueryClientProvider to enable TanStack Query functionality. Includes ReactQueryDevtools for debugging. This is the root configuration needed for all child components to use TanStack Query hooks.

```typescript
import * as React from 'react'
import {
  QueryClient,
  QueryClientProvider,
  useMutation,
  useQuery,
  useQueryClient,
} from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'

const client = new QueryClient()

export default function App() {
  return (
    <QueryClientProvider client={client}>
      <Example />
      <ReactQueryDevtools initialIsOpen />
    </QueryClientProvider>
  )
}
```

--------------------------------

### Angular Root Component with Router Setup

Source: https://tanstack.com/query/v5/docs/framework/angular/examples/router

Creates the main AppComponent with RouterOutlet for Angular routing support. Uses OnPush change detection strategy for better performance and imports RouterOutlet to enable route rendering. This component serves as the entry point for the application with standalone component configuration.

```typescript
import { ChangeDetectionStrategy, Component } from '@angular/core'
import { RouterOutlet } from '@angular/router'

@Component({
  selector: 'app-root',
  changeDetection: ChangeDetectionStrategy.OnPush,
  imports: [RouterOutlet],
  templateUrl: './app.component.html',
})
export class AppComponent {}
```

--------------------------------

### Angular Root Component Setup with Routing

Source: https://tanstack.com/query/v5/docs/framework/angular/examples/query-options-from-a-service

Defines the AppComponent as a standalone Angular component that uses routing. The component imports RouterOutlet for rendering routed child components and uses an external HTML template for the view.

```typescript
import { Component } from '@angular/core'
import { RouterOutlet } from '@angular/router'

@Component({
  selector: 'app-root',
  imports: [RouterOutlet],
  templateUrl: './app.component.html',
})
export class AppComponent {}
```

--------------------------------

### Using React Query via ESM.sh CDN

Source: https://tanstack.com/query/v5/docs/framework/react/installation

Load React Query from ESM.sh CDN using a script tag in HTML for environments without bundlers. Requires importing React and ReactDOM as well. Supports modern browsers; polyfills may be needed for older ones.

```html
<script type="module">
  import React from 'https://esm.sh/react@18.2.0'
  import ReactDOM from 'https://esm.sh/react-dom@18.2.0'
  import { QueryClient } from 'https://esm.sh/@tanstack/react-query'
</script>
```

--------------------------------

### Package Installation Commands

Source: https://tanstack.com/query/v5/docs/framework/react/plugins/createSyncStoragePersister

Installation commands for npm, pnpm, yarn, and bun package managers to install the sync storage persister package and its dependencies.

```bash
npm install @tanstack/query-sync-storage-persister @tanstack/react-query-persist-client
```

--------------------------------

### Install Solid Query Devtools Package

Source: https://tanstack.com/query/v5/docs/framework/solid/devtools

These commands install the `@tanstack/solid-query-devtools` package, which is required to use the Solid Query Devtools in your project. Choose the command corresponding to your preferred package manager.

```bash
npm i @tanstack/solid-query-devtools
```

```bash
pnpm add @tanstack/solid-query-devtools
```

```bash
yarn add @tanstack/solid-query-devtools
```

```bash
bun add @tanstack/solid-query-devtools
```

--------------------------------

### Initialize QueryClient and App Root Component - Solid.js

Source: https://tanstack.com/query/v5/docs/framework/solid/examples/basic-graphql-request

Sets up the TanStack Query provider and root App component using Solid.js. Creates a QueryClient instance and wraps the application with QueryClientProvider to enable query functionality throughout the component tree. Includes SolidQueryDevtools for development debugging.

```TypeScript
const queryClient = new QueryClient()

function App() {
  const [postId, setPostId] = createSignal(-1)

  return (
    <QueryClientProvider client={queryClient}>
      <SolidQueryDevtools />
      <p>
        As you visit the posts below, you will notice them in a loading state
        the first time you load them. However, after you return to this list and
        click on any posts you have already visited again, you will see them
        load instantly and background refresh right before your eyes!{' '}
        <strong>
          (You may need to throttle your network speed to simulate longer
          loading sequences)
        </strong>
      </p>
      {postId() > -1 ? (
        <Post postId={postId()} setPostId={setPostId} />
      ) : (
        <Posts setPostId={setPostId} />
      )}
    </QueryClientProvider>
  )
}

render(() => <App />, document.getElementById('root') as HTMLElement)
```

--------------------------------

### Basic Sync Storage Persister Setup

Source: https://tanstack.com/query/v5/docs/framework/react/plugins/createSyncStoragePersister

Example of creating and using a sync storage persister with localStorage for persisting query client state with garbage collection time configuration.

```tsx
import { persistQueryClient } from '@tanstack/react-query-persist-client'
import { createSyncStoragePersister } from '@tanstack/query-sync-storage-persister'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: 1000 * 60 * 60 * 24, // 24 hours
    },
  },
})

const localStoragePersister = createSyncStoragePersister({
  storage: window.localStorage,
})
// const sessionStoragePersister = createSyncStoragePersister({ storage: window.sessionStorage })

persistQueryClient({
  queryClient,
  persister: localStoragePersister,
})
```

--------------------------------

### Install Vue Query using Package Managers

Source: https://tanstack.com/query/v5/docs/framework/vue/installation

Installs the @tanstack/vue-query package using common JavaScript package managers: NPM, pnpm, yarn, and bun. Ensure you have Node.js and a package manager installed.

```bash
npm i @tanstack/vue-query
```

```bash
pnpm add @tanstack/vue-query
```

```bash
yarn add @tanstack/vue-query
```

```bash
bun add @tanstack/vue-query
```

--------------------------------

### Build a Basic React App with TanStack Query for Data Fetching and Persistence

Source: https://tanstack.com/query/v5/docs/framework/react/examples/basic

This comprehensive example provides a full React application that uses TanStack Query (React Query) to fetch data from a JSONPlaceholder API. It includes setup for `QueryClient`, `PersistQueryClientProvider` for local storage persistence, custom hooks (`usePosts`, `usePost`) for data retrieval, and React components (`Posts`, `Post`, `App`) to render the UI, demonstrating loading states, error handling, and background data refreshing.

```tsx
import * as React from 'react'
import ReactDOM from 'react-dom/client'
import { QueryClient, useQuery, useQueryClient } from '@tanstack/react-query'
import { PersistQueryClientProvider } from '@tanstack/react-query-persist-client'
import { createAsyncStoragePersister } from '@tanstack/query-async-storage-persister'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: 1000 * 60 * 60 * 24, // 24 hours
    },
  },
})

const persister = createAsyncStoragePersister({
  storage: window.localStorage,
})

type Post = {
  id: number
  title: string
  body: string
}

function usePosts() {
  return useQuery({
    queryKey: ['posts'],
    queryFn: async (): Promise<Array<Post>> => {
      const response = await fetch('https://jsonplaceholder.typicode.com/posts')
      return await response.json()
    },
  })
}

function Posts({
  setPostId,
}: {
  setPostId: React.Dispatch<React.SetStateAction<number>>
}) {
  const queryClient = useQueryClient()
  const { status, data, error, isFetching } = usePosts()

  return (
    <div>
      <h1>Posts</h1>
      <div>
        {status === 'pending' ? (
          'Loading...'
        ) : status === 'error' ? (
          <span>Error: {error.message}</span>
        ) : (
          <>
            <div>
              {data.map((post) => (
                <p key={post.id}>
                  <a
                    onClick={() => setPostId(post.id)}
                    href="#"
                    style={
                      // We can access the query data here to show bold links for
                      // ones that are cached
                      queryClient.getQueryData(['post', post.id])
                        ? {
                            fontWeight: 'bold',
                            color: 'green',
                          }
                        : {}
                    }
                  >
                    {post.title}
                  </a>
                </p>
              ))}
            </div>
            <div>{isFetching ? 'Background Updating...' : ' '}</div>
          </>
        )}
      </div>
    </div>
  )
}

const getPostById = async (id: number): Promise<Post> => {
  const response = await fetch(
    `https://jsonplaceholder.typicode.com/posts/${id}`,
  )
  return await response.json()
}

function usePost(postId: number) {
  return useQuery({
    queryKey: ['post', postId],
    queryFn: () => getPostById(postId),
    enabled: !!postId,
  })
}

function Post({
  postId,
  setPostId,
}: {
  postId: number
  setPostId: React.Dispatch<React.SetStateAction<number>>
}) {
  const { status, data, error, isFetching } = usePost(postId)

  return (
    <div>
      <div>
        <a onClick={() => setPostId(-1)} href="#">
          Back
        </a>
      </div>
      {!postId || status === 'pending' ? (
        'Loading...'
      ) : status === 'error' ? (
        <span>Error: {error.message}</span>
      ) : (
        <>
          <h1>{data.title}</h1>
          <div>
            <p>{data.body}</p>
          </div>
          <div>{isFetching ? 'Background Updating...' : ' '}</div>
        </>
      )}
    </div>
  )
}

function App() {
  const [postId, setPostId] = React.useState(-1)

  return (
    <PersistQueryClientProvider
      client={queryClient}
      persistOptions={{ persister }}
    >
      <p>
        As you visit the posts below, you will notice them in a loading state
        the first time you load them. However, after you return to this list and
        click on any posts you have already visited again, you will see them
        load instantly and background refresh right before your eyes! 
        <strong>
          (You may need to throttle your network speed to simulate longer
          loading sequences)
        </strong>
      </p>
      {postId > -1 ? (
        <Post postId={postId} setPostId={setPostId} />
      ) : (
        <Posts setPostId={setPostId} />
      )}
      <ReactQueryDevtools initialIsOpen />
    </PersistQueryClientProvider>
  )
}

const rootElement = document.getElementById('root') as HTMLElement
ReactDOM.createRoot(rootElement).render(<App />)

```

--------------------------------

### Implementing Suspense with Solid Query

Source: https://tanstack.com/query/v5/docs/framework/solid/quick-start

Solid Query supports Suspense out of the box. To trigger a loading fallback, ensure that the query's data is accessed within a `<Suspense>` boundary. If data is accessed outside this boundary, Suspense will not be activated.

```tsx
import { For, Suspense } from 'solid-js'

function Example() {
  const query = useQuery(() => ({
    queryKey: ['todos'],
    queryFn: fetchTodos,
  }))
  return (
    <div>
      {/* ‚úÖ Will trigger loading fallback, data accessed in a suspense boundary. */}
      <Suspense fallback={'Loading...'}>
        <For each={query.data}>{(todo) => <div>{todo.title}</div>}</For>
      </Suspense>
      {/* ‚ùå Will not trigger loading fallback, data not accessed in a suspense boundary. */}
      <For each={query.data}>{(todo) => <div>{todo.title}</div>}</For>
    </div>
  )
}
```

--------------------------------

### Create and Display a List of Posts (SolidJS TanStack Query)

Source: https://tanstack.com/query/v5/docs/framework/solid/examples/basic-graphql-request

This code defines the `createPosts` custom hook using `useQuery` to fetch multiple post titles from the GraphQL API. The `Posts` component consumes this hook, displaying loading, error, and data states, and provides navigation links to individual post details. It implicitly relies on `endpoint`, `gql`, `request`, `queryClient`, and `Post` from the global scope established in the main application setup.

```tsx
function createPosts() {
  return useQuery(() => ({
    queryKey: ['posts'],
    queryFn: async () => {
      const {
        posts: { data },
      } = await request<{
        posts: { data: Array<Post> }
      }>(
        endpoint,
        gql`
          query {
            posts {
              data {
                id
                title
              }
            }
          }
        `,
      )
      return data
    },
  }))
}

function Posts(props: { setPostId: Setter<number> }) {
  const state = createPosts()

  return (
    <div>
      <h1>Posts</h1>
      <div>
        <Switch>
          <Match when={state.status === 'pending'}>Loading...</Match>
          <Match when={state.status === 'error'}>
            <span>Error: {(state.error as Error).message}</span>
          </Match>
          <Match when={state.data !== undefined}>
            <>
              <div>
                <For each={state.data}>
                  {(post: any) => (
                    <p>
                      <a
                        onClick={() => props.setPostId(post.id)}
                        href="#"
                        style={
                          // We can find the existing query data here to show bold links for
                          // ones that are cached
                          queryClient.getQueryData(['post', post.id])
                            ?
                            {
                                'font-weight': 'bold',
                                color: 'green',
                              }
                            : {}
                        }
                      >
                        {post.title}
                      </a>
                    </p>
                  )}
                </For>
              </div>
              <div>{state.isFetching ? 'Background Updating...' : ' '}</div>
            </>
          </Match>
        </Switch>
      </div>
    </div>
  )
}
```

--------------------------------

### Start Nuxt 3 Development Server (Bash)

Source: https://tanstack.com/query/v5/docs/framework/vue/examples/nuxt3

This `yarn dev` command launches the Nuxt 3 local development server, typically accessible at `http://localhost:3000`. It provides a live-reloading environment for efficient application development and real-time feedback on code changes.

```bash
yarn dev
```

--------------------------------

### Setup React Query Provider and Application Entry - React TypeScript

Source: https://tanstack.com/query/v5/docs/framework/react/examples/default-query-function

Configures the main App component with QueryClientProvider to enable React Query functionality throughout the application. Includes ReactQueryDevtools for debugging and manages navigation between posts list and individual post views.

```typescript
import React from 'react'
import ReactDOM from 'react-dom/client'
import {
  QueryClientProvider,
  useQueryClient,
} from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'

function App() {
  const [postId, setPostId] = React.useState(-1)

  return (
    <QueryClientProvider client={queryClient}>
      <p>
        As you visit the posts below, you will notice them in a loading state
        the first time you load them. However, after you return to this list and
        click on any posts you have already visited again, you will see them
        load instantly and background refresh right before your eyes!
      </p>
      {postId > -1 ? (
        <Post postId={postId} setPostId={setPostId} />
      ) : (
        <Posts setPostId={setPostId} />
      )}
      <ReactQueryDevtools initialIsOpen />
    </QueryClientProvider>
  )
}

const rootElement = document.getElementById('root') as HTMLElement
ReactDOM.createRoot(rootElement).render(<App />)
```

--------------------------------

### NPM Project Dependencies Configuration

Source: https://tanstack.com/query/v5/docs/framework/react/examples/simple

Package configuration defining project metadata and dependencies including TanStack Query v5, React 19, and development tools like Vite and TypeScript. Specifies exact versions for consistent builds across environments.

```json
{
  "name": "@tanstack/query-example-react-simple",
  "dependencies": {
    "@tanstack/react-query": "^5.90.11",
    "@tanstack/react-query-devtools": "^5.91.1",
    "react": "^19.0.0",
    "react-dom": "^19.0.0"
  },
  "devDependencies": {
    "@vitejs/plugin-react": "^4.3.4",
    "typescript": "5.8.3",
    "vite": "^6.3.6"
  }
}
```

--------------------------------

### Initialize QueryClient and Setup React Native App with TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/react/examples/react-native

Sets up a React Native application with TanStack Query by creating a QueryClient with default retry options, integrating focus manager for app state changes, and wrapping the app with QueryClientProvider. Handles platform-specific focus detection and online/offline state management for native and web platforms.

```typescript
import * as React from 'react'
import { AppStateStatus, Platform } from 'react-native'
import { NavigationContainer } from '@react-navigation/native'
import {
  QueryClient,
  QueryClientProvider,
  focusManager,
} from '@tanstack/react-query'

import { useAppState } from './src/hooks/useAppState'
import { MoviesStack } from './src/navigation/MoviesStack'
import { useOnlineManager } from './src/hooks/useOnlineManager'

function onAppStateChange(status: AppStateStatus) {
  // React Query already supports in web browser refetch on window focus by default
  if (Platform.OS !== 'web') {
    focusManager.setFocused(status === 'active')
  }
}

const queryClient = new QueryClient({
  defaultOptions: { queries: { retry: 2 } },
})

export default function App() {
  useOnlineManager()

  useAppState(onAppStateChange)

  return (
    <QueryClientProvider client={queryClient}>
      <NavigationContainer>
        <MoviesStack />
      </NavigationContainer>
    </QueryClientProvider>
  )
}
```

--------------------------------

### Initialize TanStack Query Client and Provider in React

Source: https://tanstack.com/query/v5/docs/framework/react/examples/simple

This React TypeScript snippet demonstrates the basic setup for using TanStack Query in a React application. It imports necessary components like QueryClient and QueryClientProvider, initializes a new QueryClient instance, and then wraps the root application component with the QueryClientProvider to make the query client available throughout the component tree. It also includes the ReactQueryDevtools for debugging.

```TypeScript
import React from 'react'
import ReactDOM from 'react-dom/client'
import {
  QueryClient,
  QueryClientProvider,
  useQuery,
} from '@tanstack/react-query'
import { ReactQueryDevtools } from
  '@tanstack/react-query-devtools'

const queryClient = new QueryClient()

export default function App() {
  return (
    <QueryClientProvider client=
      {queryClient}>
      <ReactQueryDevtools />
      <Example />
    </QueryClientProvider>
  )
}
```

--------------------------------

### SolidJS App Initialization with TanStack Query and GraphQL

Source: https://tanstack.com/query/v5/docs/framework/solid/examples/basic-graphql-request

This code snippet initializes the main SolidJS application. It imports necessary modules, sets up the `QueryClientProvider` for TanStack Query, defines the GraphQL endpoint and `Post` type, and renders the root `App` component to the DOM. The `App` component manages the top-level state for viewing a list of posts or a single post.

```tsx
/* @refresh reload */
import {
  QueryClient,
  QueryClientProvider,
  useQuery,
} from '@tanstack/solid-query'
import { SolidQueryDevtools } from '@tanstack/solid-query-devtools'
import { For, Match, Switch, createSignal } from 'solid-js'
import { render } from 'solid-js/web'
import { gql, request } from 'graphql-request'
import type { Accessor, Setter } from 'solid-js'

const endpoint = 'https://graphqlzero.almansi.me/api'

const queryClient = new QueryClient()

type Post = {
  id: number
  title: string
  body: string
}

function App() {
  const [postId, setPostId] = createSignal(-1)

  return (
    <QueryClientProvider client={queryClient}>
      <SolidQueryDevtools />
      <p>
        As you visit the posts below, you will notice them in a loading state
        the first time you load them. However, after you return to this list and
        click on any posts you have already visited again, you will see them
        load instantly and background refresh right before your eyes!{' '}
        <strong>
          (You may need to throttle your network speed to simulate longer
          loading sequences)
        </strong>
      </p>
      {postId() > -1 ? (
        <Post postId={postId()} setPostId={setPostId} />
      ) : (
        <Posts setPostId={setPostId} />
      )}
    </QueryClientProvider>
  )
}

render(() => <App />, document.getElementById('root') as HTMLElement)
```

--------------------------------

### Svelte Main Application Component for Todo Playground

Source: https://tanstack.com/query/v5/docs/framework/svelte/examples/playground

This Svelte component serves as the main application entry point for a TanStack Query playground example. It utilizes `useQueryClient` to manage data fetching, displays a list of todos with filtering capabilities, and integrates with local Svelte stores (`views`, `editingIndex`) for UI state. It includes functionality to force refetch all queries and add new filtered todo lists.

```svelte
<script lang="ts">
  import { useQueryClient } from '@tanstack/svelte-query'
  import TodosList from './TodosList.svelte'
  import EditTodo from './EditTodo.svelte'
  import AddTodo from './AddTodo.svelte'
  import { views, editingIndex } from '../lib/stores.svelte'

  const queryClient = useQueryClient()
</script>

<div>
  <div>
    <button onclick={() => queryClient.invalidateQueries()}>
      Force Refetch All
    </button>
  </div>
  <br />
  <hr />

  {#each views.value as view}
    <div>
      <TodosList initialFilter={view} />
      <br />
    </div>
  {/each}

  <button
    onclick={() => {
      views.value.push('')
    }}
  >
    Add Filter List
  </button>
  <hr />

  {#if editingIndex.value !== null}
    <EditTodo />
    <hr />
  {/if}

  <AddTodo />
</div>
```

--------------------------------

### Vite Configuration with React Plugin

Source: https://tanstack.com/query/v5/docs/framework/react/examples/simple

Vite build configuration file that sets up the React plugin for HMR (Hot Module Replacement) support during development and optimized production builds.

```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
})
```

--------------------------------

### useInfiniteQuery Hook Setup and Configuration

Source: https://tanstack.com/query/v5/docs/framework/vue/reference/useInfiniteQuery

Demonstrates the basic setup of useInfiniteQuery with destructured return values and essential configuration options. The hook requires queryKey, queryFn with pageParam context, initialPageParam, and pagination parameter functions to enable bidirectional infinite scrolling.

```typescript
const {
  fetchNextPage,
  fetchPreviousPage,
  hasNextPage,
  hasPreviousPage,
  isFetchingNextPage,
  isFetchingPreviousPage,
  promise,
  ...result
} = useInfiniteQuery({
  queryKey,
  queryFn: ({ pageParam }) => fetchPage(pageParam),
  initialPageParam: 1,
  ...options,
  getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) =>
    lastPage.nextCursor,
  getPreviousPageParam: (firstPage, allPages, firstPageParam, allPageParams) =>
    firstPage.prevCursor,
})
```

--------------------------------

### React Query with Devtools Panel Integration

Source: https://tanstack.com/query/v5/docs/framework/react/examples/devtools-panel

Complete React application demonstrating TanStack Query setup with QueryClient provider, useQuery hook for fetching GitHub repository data, and ReactQueryDevtoolsPanel component. Features toggle functionality for showing/hiding the devtools panel and displays repository statistics including subscribers, stargazers, and forks count.

```typescript
import React from 'react'
import ReactDOM from 'react-dom/client'
import {
  QueryClient,
  QueryClientProvider,
  useQuery,
} from '@tanstack/react-query'
import { ReactQueryDevtoolsPanel } from '@tanstack/react-query-devtools'

const queryClient = new QueryClient()

export default function App() {
  const [isOpen, setIsOpen] = React.useState(false)

  return (
    <QueryClientProvider client={queryClient}>
      <Example />
      <button
        onClick={() => setIsOpen(!isOpen)}
      >{`${isOpen ? 'Close' : 'Open'} the devtools panel`}</button>
      {isOpen && <ReactQueryDevtoolsPanel onClose={() => setIsOpen(false)} />}
    </QueryClientProvider>
  )
}

function Example() {
  const { isPending, error, data, isFetching } = useQuery({
    queryKey: ['repoData'],
    queryFn: async () => {
      const response = await fetch(
        'https://api.github.com/repos/TanStack/query',
      )
      return await response.json()
    },
  })

  if (isPending) return 'Loading...'

  if (error) return 'An error has occurred: ' + error.message

  return (
    <div
      style={{
        paddingBottom: 20,
      }}
    >
      <h1>{data.full_name}</h1>
      <p>{data.description}</p>
      <strong>üëÄ {data.subscribers_count}</strong>{' '}
      <strong>‚ú® {data.stargazers_count}</strong>{' '}
      <strong>üç¥ {data.forks_count}</strong>
      <div>{isFetching ? 'Updating...' : ''}</div>
    </div>
  )
}

const rootElement = document.getElementById('root') as HTMLElement
ReactDOM.createRoot(rootElement).render(<App />)
```

--------------------------------

### Render Solid.js App to DOM

Source: https://tanstack.com/query/v5/docs/framework/solid/examples/simple

Mounts the Solid.js application to the DOM element with id 'root'. Uses the render function to initialize the component tree and make the app interactive in the browser.

```typescript
render(() => <App />, document.getElementById('root') as HTMLElement)
```

--------------------------------

### Implement Query and Mutation in Angular Component

Source: https://tanstack.com/query/v5/docs/framework/angular/quick-start

Demonstrates creating reactive queries and mutations using TanStack Query in Angular components. Includes a todo service with HTTP operations and automatic cache invalidation. Uses Angular's async pipe pattern with Observable-to-Promise conversion.

```angular-ts
import { Component, Injectable, inject } from '@angular/core'
import { HttpClient } from '@angular/common/http'
import { lastValueFrom } from 'rxjs'

import {
  injectMutation,
  injectQuery,
  QueryClient
} from '@tanstack/angular-query-experimental'

@Component({
  template: `
    <div>
      <button (click)="onAddTodo()">Add Todo</button>

      <ul>
        @for (todo of query.data(); track todo.title) {
          <li>{{ todo.title }}</li>
        }
      </ul>
    </div>
  `,
})
export class TodosComponent {
  todoService = inject(TodoService)
  queryClient = inject(QueryClient)

  query = injectQuery(() => ({
    queryKey: ['todos'],
    queryFn: () => this.todoService.getTodos(),
  }))

  mutation = injectMutation(() => ({
    mutationFn: (todo: Todo) => this.todoService.addTodo(todo),
    onSuccess: () => {
      this.queryClient.invalidateQueries({ queryKey: ['todos'] })
    },
  }))

  onAddTodo() {
    this.mutation.mutate({
      id: Date.now().toString(),
      title: 'Do Laundry',
    })
  }
}

@Injectable({ providedIn: 'root' })
export class TodoService {
  private http = inject(HttpClient)

  getTodos(): Promise<Todo[]> {
    return lastValueFrom(
      this.http.get<Todo[]>('https://jsonplaceholder.typicode.com/todos'),
    )
  }

  addTodo(todo: Todo): Promise<Todo> {
    return lastValueFrom(
      this.http.post<Todo>('https://jsonplaceholder.typicode.com/todos', todo),
    )
  }
}

interface Todo {
  id: string
  title: string
}
```

--------------------------------

### Define Angular App Component for Auto-Refetching Example (TypeScript)

Source: https://tanstack.com/query/v5/docs/framework/angular/examples/auto-refetching

This TypeScript code defines the root `AppComponent` for an Angular application. It utilizes `ChangeDetectionStrategy.OnPush` for optimized change detection and imports and renders `AutoRefetchingExampleComponent`, which is expected to encapsulate the auto-refetching functionality. This setup demonstrates how to integrate a specific component into the main application layout.

```typescript
import { ChangeDetectionStrategy, Component } from '@angular/core'
import { AutoRefetchingExampleComponent } from './components/auto-refetching.component'

@Component({
  changeDetection: ChangeDetectionStrategy.OnPush,
  selector: 'app-root',
  template: `<auto-refetching-example />`,
  imports: [AutoRefetchingExampleComponent],
})
export class AppComponent {}
```

--------------------------------

### TanStack Query Provider Setup - TypeScript/React

Source: https://tanstack.com/query/v5/docs/framework/react/examples/optimistic-updates-cache

Wraps application components with QueryClientProvider to enable TanStack Query functionality. Includes ReactQueryDevtools for debugging query state in development environment.

```typescript
export default function App() {
  return (
    <QueryClientProvider client={client}>
      <Example />
      <ReactQueryDevtools initialIsOpen />
    </QueryClientProvider>
  )
}
```

--------------------------------

### Initialize QueryClient and Provider in Svelte

Source: https://tanstack.com/query/v5/docs/framework/svelte/examples/simple

Sets up the TanStack Query environment by creating a QueryClient instance and wrapping the application with QueryClientProvider. This enables query caching, synchronization, and state management across the Svelte component tree. The SvelteQueryDevtools component provides development tools for inspecting queries.

```svelte
<script lang="ts">
  import { QueryClientProvider, QueryClient } from '@tanstack/svelte-query'
  import { SvelteQueryDevtools } from '@tanstack/svelte-query-devtools'
  import Simple from './lib/Simple.svelte'

  const queryClient = new QueryClient()
</script>

<QueryClientProvider client={queryClient}>
  <main>
    <Simple />
  </main>
  <SvelteQueryDevtools />
</QueryClientProvider>
```

--------------------------------

### Solid.js: Lazy Load Component with Dependent Query Waterfall

Source: https://tanstack.com/query/v5/docs/framework/solid/guides/prefetching

This Solid.js example demonstrates lazy loading a component (`GraphFeedItem`) and fetching its data using `useQuery`. The setup results in a request waterfall where the component's JavaScript loads only after the initial feed data is available, followed by the dependent data fetch.

```tsx
// This lazy loads the GraphFeedItem component, meaning
// it wont start loading until something renders it
const GraphFeedItem = Solid.lazy(() => import('./GraphFeedItem'))

function Feed() {
  const { data, isPending } = useQuery(() => {
    queryKey: ['feed'],
    queryFn: getFeed,
  })

  if (isPending) {
    return 'Loading feed...'
  }

  return (
    <>
      {data.map((feedItem) => {
        if (feedItem.type === 'GRAPH') {
          return <GraphFeedItem key={feedItem.id} feedItem={feedItem} />
        }

        return <StandardFeedItem key={feedItem.id} feedItem={feedItem} />
      })}
    </>
  )
}

// GraphFeedItem.tsx
function GraphFeedItem({ feedItem }) {
  const { data, isPending } = useQuery(() => {
    queryKey: ['graph', feedItem.id],
    queryFn: getGraphDataById,
  })

  ...
}
```

--------------------------------

### Import TanStack Query Dependencies - Solid.js

Source: https://tanstack.com/query/v5/docs/framework/solid/examples/basic-graphql-request

Sets up required imports for TanStack Query Solid integration, Solid.js utilities, GraphQL request client, and the Query DevTools. Defines the GraphQL endpoint and Post type interface for type safety.

```TypeScript
import { SolidQueryDevtools } from '@tanstack/solid-query-devtools'
import { For, Match, Switch, createSignal } from 'solid-js'
import { render } from 'solid-js/web'
import { gql, request } from 'graphql-request'
import type { Accessor, Setter } from 'solid-js'

const endpoint = 'https://graphqlzero.almansi.me/api'

type Post = {
  id: number
  title: string
  body: string
}
```

--------------------------------

### Create a New Svelte Project with create-svelte

Source: https://tanstack.com/query/v5/docs/framework/svelte/examples/optimistic-updates

These bash commands demonstrate how to initialize a new Svelte project using `npm create svelte@latest`. Users can choose to create the project in the current directory or specify a new directory name for their Svelte application.

```bash
# create a new project in the current directory
npm create svelte@latest

# create a new project in my-app
npm create svelte@latest my-app
```

--------------------------------

### React Root Element Initialization and Rendering

Source: https://tanstack.com/query/v5/docs/framework/react/examples/playground

TypeScript code that retrieves the root DOM element and initializes React 18+ with ReactDOM.createRoot, rendering the main Root component. This is the application entry point for mounting the React application.

```TypeScript
const rootElement = document.getElementById('root') as HTMLElement
ReactDOM.createRoot(rootElement).render(<Root />)
```

--------------------------------

### useMutationState - Get All Variables of Running Mutations

Source: https://tanstack.com/query/v5/docs/framework/solid/reference/useMutationState

Demonstrates how to use useMutationState to retrieve all variables from mutations with a 'pending' status. This example filters mutations by their status and extracts the variables property from each matching mutation's state.

```APIDOC
## useMutationState - Get All Variables of Running Mutations

### Description
Retrieve all variables from mutations currently in pending status using the useMutationState hook with status filtering.

### Hook Signature
```typescript
useMutationState({
  filters?: MutationFilters,
  select?: (mutation: Mutation) => TResult,
  queryClient?: QueryClient
}): Array<TResult>
```

### Parameters
- **filters** (MutationFilters) - Optional - Object to filter mutations by status, mutationKey, or other criteria
- **select** (function) - Optional - Transformation function to extract specific data from mutation state
- **queryClient** (QueryClient) - Optional - Custom QueryClient instance, otherwise uses nearest context

### Request Example
```tsx
import { useMutationState } from '@tanstack/solid-query'

const variables = useMutationState(() => ({
  filters: { status: 'pending' },
  select: (mutation) => mutation.state.variables
}))
```

### Response
- **Returns** (Array<TResult>) - Array of transformed mutation state values matching the filter criteria
```

--------------------------------

### Initialize React Query Client and Root Provider

Source: https://tanstack.com/query/v5/docs/framework/react/examples/playground

Sets up QueryClient with default configuration and wraps the application with QueryClientProvider. Includes state management for stale time, garbage collection time, error rate, and fetch time parameters that control query behavior. The Root component demonstrates how to configure global query defaults dynamically.

```typescript
const queryClient = new QueryClient()

function Root() {
  const [staleTime, setStaleTime] = React.useState(1000)
  const [gcTime, setGcTime] = React.useState(3000)
  const [localErrorRate, setErrorRate] = React.useState(errorRate)
  const [localFetchTimeMin, setLocalFetchTimeMin] = React.useState(queryTimeMin)
  const [localFetchTimeMax, setLocalFetchTimeMax] = React.useState(queryTimeMax)

  React.useEffect(() => {
    errorRate = localErrorRate
    queryTimeMin = localFetchTimeMin
    queryTimeMax = localFetchTimeMax
  }, [localErrorRate, localFetchTimeMax, localFetchTimeMin])

  React.useEffect(() => {
    queryClient.setDefaultOptions({
      queries: {
        staleTime,
        gcTime,
      },
    })
  }, [gcTime, staleTime])

  return (
    <QueryClientProvider client={queryClient}>
      {/* Configuration UI and nested components */}
      <ReactQueryDevtools initialIsOpen />
    </QueryClientProvider>
  )
}
```

--------------------------------

### Prefetch and block/parallel-fetch with TanStack Router (TSX)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/prefetching

Configures a route to declare required queries ahead of time and uses the QueryClient to prefetch data. Dependencies: TanStack Router primitives (RouterContext, Route) and TanStack Query (QueryClient, useQuery). Inputs: route-level query option objects; Outputs: prefetched cache entries used by useQuery. Limitation: example omits full setup and SSR hydration details.

```tsx
const queryClient = new QueryClient()
const routerContext = new RouterContext()
const rootRoute = routerContext.createRootRoute({
  component: () => { ... }
})

const articleRoute = new Route({
  getParentRoute: () => rootRoute,
  path: 'article',
  beforeLoad: () => {
    return {
      articleQueryOptions: { queryKey: ['article'], queryFn: fetchArticle },
      commentsQueryOptions: { queryKey: ['comments'], queryFn: fetchComments },
    }
  },
  loader: async ({
    context: { queryClient },
    routeContext: { articleQueryOptions, commentsQueryOptions },
  }) => {
    // Fetch comments asap, but don't block
    queryClient.prefetchQuery(commentsQueryOptions)

    // Don't render the route at all until article has been fetched
    await queryClient.prefetchQuery(articleQueryOptions)
  },
  component: ({ useRouteContext }) => {
    const { articleQueryOptions, commentsQueryOptions } = useRouteContext()
    const articleQuery = useQuery(articleQueryOptions)
    const commentsQuery = useQuery(commentsQueryOptions)

    return (
      ...
    )
  },
  errorComponent: () => 'Oh crap!',
})
```

--------------------------------

### useQuery Hook Basic Caching with Default Settings

Source: https://tanstack.com/query/v5/docs/framework/solid/guides/caching

Demonstrates the fundamental usage of the useQuery hook with a query key and query function. This shows how TanStack Query handles data caching, stale marking, and network requests using default configurations (gcTime of 5 minutes and staleTime of 0).

```javascript
useQuery({ queryKey: ['todos'], queryFn: fetchTodos })
```

--------------------------------

### Get Pending Mutation Variables with useMutationState

Source: https://tanstack.com/query/v5/docs/framework/react/reference/useMutationState

This example demonstrates how to retrieve the variables of all currently pending mutations using the `useMutationState` hook. It filters for mutations with a 'pending' status and selects their associated variables.

```tsx
import { useMutationState } from '@tanstack/react-query'

const variables = useMutationState({
  filters: { status: 'pending' },
  select: (mutation) => mutation.state.variables,
})
```

--------------------------------

### Import React Query and Dependencies

Source: https://tanstack.com/query/v5/docs/framework/react/examples/playground

Imports core React Query hooks and utilities (QueryClient, QueryClientProvider, useQuery, useMutation, useQueryClient) along with React Query Devtools for debugging. These imports provide the foundation for data fetching, caching, and state management.

```typescript
import React from 'react'
import ReactDOM from 'react-dom/client'
import {
  QueryClient,
  QueryClientProvider,
  useMutation,
  useQuery,
  useQueryClient,
} from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
import './styles.css'
```

--------------------------------

### Mount Svelte Application in main.ts

Source: https://tanstack.com/query/v5/docs/framework/svelte/examples/simple

Mounts the root Svelte component (App.svelte) to the DOM element with id 'app'. This bootstraps the Svelte application with TypeScript support and establishes the component tree root.

```typescript
import { mount } from 'svelte'
import './app.css'
import App from './App.svelte'

const app = mount(App, {
  target: document.querySelector('#app')!,
})

export default app
```

--------------------------------

### Get Pending Mutation Variables with useMutationState (TanStack Solid-Query)

Source: https://tanstack.com/query/v5/docs/framework/solid/reference/useMutationState

This example demonstrates how to use `useMutationState` from `@tanstack/solid-query` to retrieve the `variables` property of all mutations that are currently in a 'pending' state. It applies a filter for `status: 'pending'` and selects the `mutation.state.variables`.

```tsx
import { useMutationState } from '@tanstack/solid-query'

const variables = useMutationState(() => {
  filters: { status: 'pending' },
  select: (mutation) => mutation.state.variables,
})
```

--------------------------------

### Customize QueryClient context key with an existing client in TypeScript

Source: https://tanstack.com/query/v5/docs/framework/vue/guides/custom-client

This example combines providing a pre-instantiated `QueryClient` with specifying a custom `queryClientKey` in the `VueQueryPlugin` options. It enables fine-grained control over both the client instance and its identifier within the Vue context, offering flexibility for complex setups.

```tsx
const myClient = new QueryClient(queryClientConfig)
const vueQueryPluginOptions: VueQueryPluginOptions = {
  queryClient: myClient,
  queryClientKey: 'Foo',
}
app.use(VueQueryPlugin, vueQueryPluginOptions)
```

--------------------------------

### Next.js SSG with React-Query Prefetching

Source: https://tanstack.com/query/v5/docs/framework/react/examples/nextjs

Demonstrates server-side prefetching using React-Query's QueryClient in Next.js getStaticProps. This example shows how to prefetch data at build time, dehydrate the query state, and pass it to the client component for instant data availability. The pattern enables static site generation with dynamic data synchronization.

```typescript
import React from 'react'
import { QueryClient, dehydrate } from '@tanstack/react-query'
import { Header, InfoBox, Layout, PostList } from '../components'
import { fetchPosts } from '../hooks/usePosts'

const Home = () => {
  return (
    <Layout>
      <Header />
      <InfoBox>‚ÑπÔ∏è This page shows how to use SSG with React-Query.</InfoBox>
      <PostList />
    </Layout>
  )
}

export async function getStaticProps() {
  const queryClient = new QueryClient()

  await queryClient.prefetchQuery({
    queryKey: ['posts', 10],
    queryFn: () => fetchPosts(10),
  })

  return {
    props: {
      dehydratedState: dehydrate(queryClient),
    },
  }
}

export default Home
```

--------------------------------

### Install @tanstack/svelte-query v6

Source: https://tanstack.com/query/v5/docs/framework/svelte/migrate-from-v5-to-v6

Instructions for installing the latest version of `@tanstack/svelte-query`, which depends on `@tanstack/query-core` v5 and requires Svelte v5.25.0 or newer. Use your package manager's equivalent command.

```shell
pnpm add @tanstack/svelte-query@latest
```

--------------------------------

### Get Search Parameters with Solid.js Signals

Source: https://tanstack.com/query/v5/docs/framework/solid/examples/astro

Utility function that creates a reactive signal for URL search parameters in a Solid.js application. Listens to browser popstate events to update the search signal when URL parameters change. Returns the current search parameter value or an empty string as fallback.

```typescript
import { createSignal } from 'solid-js'

export const getSearchParams = (init: string) => {
  const [search, setSearch] = createSignal(init)
  if (typeof window !== 'undefined') {
    window.addEventListener('popstate', () => {
      const location = window.location
      const params = new URLSearchParams(location.search)
      setSearch(params.get('id') || '')
    })
  }
  return search
}
```

--------------------------------

### TypeScript Configuration for React and ES2020

Source: https://tanstack.com/query/v5/docs/framework/react/examples/simple

TypeScript compiler configuration optimized for React development with ES2020 target, JSX support, and strict type checking. Includes bundler mode resolution, DOM typings, and linting rules for code quality.

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "Bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src", "eslint.config.js"]
}
```

--------------------------------

### Initialize Sample Data and Type Definitions

Source: https://tanstack.com/query/v5/docs/framework/react/examples/playground

Establishes the data structure for the playground with a list of fruit todos and their associated types. Defines global configuration variables for error simulation and query timing. Provides TypeScript type definitions (Todos and Todo) for type safety throughout the application.

```typescript
let id = 0
let list = [
  'apple',
  'banana',
  'pineapple',
  'grapefruit',
  'dragonfruit',
  'grapes',
].map((d) => ({ id: id++, name: d, notes: 'These are some notes' }))

type Todos = typeof list
type Todo = Todos[0]

let errorRate = 0.05
let queryTimeMin = 1000
let queryTimeMax = 2000
```

--------------------------------

### Fetch All Posts with TanStack Query in SolidJS

Source: https://tanstack.com/query/v5/docs/framework/solid/examples/basic

This `createPosts` hook utilizes TanStack Query's `useQuery` in SolidJS to asynchronously fetch a list of posts from a JSON Placeholder API. It defines a `queryKey` for caching and a `queryFn` that handles the API request and parses the JSON response. The hook returns the query state, including data, loading status, and any errors.

```tsx
function createPosts() {
  return useQuery(() => ({
    queryKey: ['posts'],
    queryFn: async (): Promise<Array<Post>> => {
      const response = await fetch('https://jsonplaceholder.typicode.com/posts')
      return await response.json()
    },
  }))
}
```

--------------------------------

### Create Angular Component with Signals and TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/angular/examples/basic

Defines a basic Angular component using OnPush change detection strategy and Angular signals for state management. This component imports PostComponent and PostsComponent, serving as the root component for the example application.

```typescript
import { ChangeDetectionStrategy, Component, signal } from '@angular/core'
import { PostComponent } from './components/post.component'
import { PostsComponent } from './components/posts.component'

@Component({
  changeDetection: ChangeDetectionStrategy.OnPush,
  selector: 'basic-example',
  templateUrl: './app.component.html',
  imports: [PostComponent, PostsComponent],
})
export class BasicExampleComponent {
  readonly postId = signal(-1)
}
```

--------------------------------

### Implement TanStack Query with GraphQL in React for Post Management

Source: https://tanstack.com/query/v5/docs/framework/react/examples/basic-graphql-request

This comprehensive TypeScript React example sets up a QueryClientProvider to manage application-wide data fetching. It defines custom hooks (`usePosts`, `usePost`) for querying a GraphQL API for post lists and individual post details using `graphql-request`. The `Posts` and `Post` components render the fetched data, handle loading and error states, and demonstrate how `useQueryClient` can be used to check for cached data to enhance user experience.

```tsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import {
  QueryClient,
  QueryClientProvider,
  useQuery,
  useQueryClient,
} from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
import { gql, request } from 'graphql-request'

const endpoint = 'https://graphqlzero.almansi.me/api'

const queryClient = new QueryClient()

type Post = {
  id: number
  title: string
  body: string
}

function App() {
  const [postId, setPostId] = React.useState(-1)

  return (
    <QueryClientProvider client={queryClient}>
      <p>
        As you visit the posts below, you will notice them in a loading state
        the first time you load them. However, after you return to this list and
        click on any posts you have already visited again, you will see them
        load instantly and background refresh right before your eyes!{' '}
        <strong>
          (You may need to throttle your network speed to simulate longer
          loading sequences)
        </strong>
      </p>
      {postId > -1 ? (
        <Post postId={postId} setPostId={setPostId} />
      ) : (
        <Posts setPostId={setPostId} />
      )}
      <ReactQueryDevtools initialIsOpen />
    </QueryClientProvider>
  )
}

function usePosts() {
  return useQuery({
    queryKey: ['posts'],
    queryFn: async () => {
      const {
        posts: { data },
      } = await request<{ posts: { data: Array<Post> } }>(
        endpoint,
        gql`
          query {
            posts {
              data {
                id
                title
              }
            }
          }
        `,
      )
      return data
    },
  })
}

function Posts({
  setPostId,
}: {
  setPostId: React.Dispatch<React.SetStateAction<number>>
}) {
  const queryClient = useQueryClient()
  const { status, data, error, isFetching } = usePosts()

  return (
    <div>
      <h1>Posts</h1>
      <div>
        {status === 'pending' ? (
          'Loading...'
        ) : status === 'error' ? (
          <span>Error: {error.message}</span>
        ) : (
          <>
            <div>
              {data.map((post) => (
                <p key={post.id}>
                  <a
                    onClick={() => setPostId(post.id)}
                    href="#"
                    style={
                      // We can find the existing query data here to show bold links for
                      // ones that are cached
                      queryClient.getQueryData(['post', post.id])
                        ? {
                            fontWeight: 'bold',
                            color: 'green',
                          }
                        : {}
                    }
                  >
                    {post.title}
                  </a>
                </p>
              ))}
            </div>
            <div>{isFetching ? 'Background Updating...' : ' '}</div>
          </>
        )}
      </div>
    </div>
  )
}

function usePost(postId: number) {
  return useQuery({
    queryKey: ['post', postId],
    queryFn: async () => {
      const { post } = await request<{ post: Post }>(
        endpoint,
        gql`
        query {
          post(id: ${postId}) {
            id
            title
            body
          }
        }
        `,
      )

      return post
    },
    enabled: !!postId,
  })
}

function Post({
  postId,
  setPostId,
}: {
  postId: number
  setPostId: React.Dispatch<React.SetStateAction<number>>
}) {
  const { status, data, error, isFetching } = usePost(postId)

  return (
    <div>
      <div>
        <a onClick={() => setPostId(-1)} href="#">
          Back
        </a>
      </div>
      {!postId || status === 'pending' ? (
        'Loading...'
      ) : status === 'error' ? (
        <span>Error: {error.message}</span>
      ) : (
        <>
          <h1>{data.title}</h1>
          <div>
            <p>{data.body}</p>
          </div>
          <div>{isFetching ? 'Background Updating...' : ' '}</div>
        </>
      )}
    </div>
  )
}

const rootElement = document.getElementById('root') as HTMLElement
ReactDOM.createRoot(rootElement).render(<App />)

```

--------------------------------

### GET /useQuery/return-value

Source: https://tanstack.com/query/v5/docs/framework/solid/reference/useQuery

Provides a structured reference for the useQuery return store. Use this to understand each property returned by useQuery and how to interpret fetch and error states.

```APIDOC
## GET /useQuery/return-value

### Description
Returns the SolidJS store produced by useQuery. Documents the store shape and each property returned by the hook, including status flags, timestamps, data/error values, fetch state, counters, and the refetch API.

### Method
GET

### Endpoint
/useQuery/return-value

### Parameters
#### Path Parameters
- **None**

#### Query Parameters
- **None**

#### Request Body
- **None**

### Request Example
{
  "example": "no request body required"
}

### Response
#### Success Response (200)
- **status** (QueryStatus) - Will be `pending`, `error`, or `success`.
  - `pending`: no cached data and no finished attempt yet.
  - `error`: the query attempt resulted in an error; see `error` property.
  - `success`: query returned data successfully or was disabled and uses `initialData`.
- **isPending** (boolean) - Derived from `status`; convenience boolean for pending state.
- **isSuccess** (boolean) - Derived from `status`; convenience boolean for success state.
- **isError** (boolean) - Derived from `status`; convenience boolean for error state.
- **isLoadingError** (boolean) - True if the query failed while fetching for the first time.
- **isRefetchError** (boolean) - True if the query failed during a refetch.
- **data** (Resource<TData>) - Defaults to `undefined`. The last successfully resolved data. This is a SolidJS resource and will suspend under a Suspense boundary if accessed while unresolved.
- **dataUpdatedAt** (number) - Timestamp when the query last became `success`.
- **error** (null | TError) - Defaults to `null`. The error object when the query throws.
- **errorUpdatedAt** (number) - Timestamp when the query last became `error`.
- **isStale** (boolean) - True if cache was invalidated or data is older than `staleTime`.
- **isPlaceholderData** (boolean) - True if placeholder data is being shown.
- **isFetched** (boolean) - True if the query has been fetched at least once.
- **isFetchedAfterMount** (boolean) - True if the query was fetched after component mount; useful to avoid showing previously cached data.
- **fetchStatus** (FetchStatus) - `fetching`, `paused`, or `idle`. `fetching` indicates the queryFn is executing (initial fetch or background refetch). See Network Mode docs for details.
- **isFetching** (boolean) - Derived from `fetchStatus`; true when fetching.
- **isPaused** (boolean) - Derived from `fetchStatus`; true when paused.
- **isRefetching** (boolean) - True when a background refetch is in-flight (does not include initial `pending`). Equivalent to `isFetching && !isPending`.
- **isLoading** (boolean) - True when the first fetch for the query is in-flight. Equivalent to `isFetching && isPending`.
- **isInitialLoading** (boolean) - Deprecated alias for `isLoading` (will be removed in next major version).
- **failureCount** (number) - Incremented on each failure; reset to 0 on success.
- **failureReason** (null | TError) - The failure reason for retry logic; reset to null on success.
- **errorUpdateCount** (number) - Sum of all error occurrences.
- **refetch** (function) - Signature: `(options: { throwOnError: boolean, cancelRefetch: boolean }) => Promise<UseQueryResult>`; Manually triggers a refetch. By default errors are logged; set `throwOnError: true` to propagate. `cancelRefetch` defaults to `true` (cancels an in-flight request before starting a new one); set to `false` to avoid refetch if a request is already running.

#### Response Example
{
  "status": "success",
  "isPending": false,
  "isSuccess": true,
  "isError": false,
  "isLoadingError": false,
  "isRefetchError": false,
  "data": { "items": [1, 2, 3] },
  "dataUpdatedAt": 1620000000000,
  "error": null,
  "errorUpdatedAt": 0,
  "isStale": false,
  "isPlaceholderData": false,
  "isFetched": true,
  "isFetchedAfterMount": true,
  "fetchStatus": "idle",
  "isFetching": false,
  "isPaused": false,
  "isRefetching": false,
  "isLoading": false,
  "isInitialLoading": false,
  "failureCount": 0,
  "failureReason": null,
  "errorUpdateCount": 0
}

### Notes
- `data` is a SolidJS resource: accessing it inside a `<Suspense>` boundary will suspend if not yet available.
- Use `isFetchedAfterMount` to differentiate showing cached data vs data fetched after component mount.
- `refetch` options control error propagation and refetch cancellation behavior.
```

--------------------------------

### Install TanStack React Query Devtools

Source: https://tanstack.com/query/v5/docs/framework/react/devtools

Install the TanStack React Query Devtools package using various package managers. For Next.js 13+ App Directory, it must be installed as a development dependency.

```bash
npm i @tanstack/react-query-devtools
```

```bash
pnpm add @tanstack/react-query-devtools
```

```bash
yarn add @tanstack/react-query-devtools
```

```bash
bun add @tanstack/react-query-devtools
```

--------------------------------

### Install TanStack Svelte Query Devtools Package

Source: https://tanstack.com/query/v5/docs/framework/svelte/devtools

These commands install the `@tanstack/svelte-query-devtools` package using different JavaScript package managers. This package is required to enable and use the TanStack Query Devtools in your Svelte application.

```bash
npm i @tanstack/svelte-query-devtools
```

```bash
pnpm add @tanstack/svelte-query-devtools
```

```bash
yarn add @tanstack/svelte-query-devtools
```

```bash
bun add @tanstack/svelte-query-devtools
```

--------------------------------

### Fetch Data with useQuery Hook in Solid.js

Source: https://tanstack.com/query/v5/docs/framework/solid/examples/simple

Uses the useQuery hook to fetch GitHub repository data from the TanStack/query repository. The hook manages async data fetching with automatic caching and provides state properties for loading, error, and data conditions.

```typescript
function Example() {
  const state = useQuery(() => ({
    queryKey: ['repoData'],
    queryFn: async () => {
      const response = await fetch(
        'https://api.github.com/repos/TanStack/query',
      )
      return await response.json()
    },
  }))

  return (
    <Switch>
      <Match when={state.isPending}>Loading...</Match>
      <Match when={state.error}>
        {'An error has occurred: ' + (state.error as Error).message}
      </Match>
      <Match when={state.data !== undefined}>
        <div>
          <h1>{state.data.name}</h1>
          <p>{state.data.description}</p>
          <strong>üëÄ {state.data.subscribers_count}</strong>{' '}
          <strong>‚ú® {state.data.stargazers_count}</strong>{' '}
          <strong>üç¥ {state.data.forks_count}</strong>
          <div>{state.isFetching ? 'Updating...' : ''}</div>
        </div>
      </Match>
    </Switch>
  )
}
```

--------------------------------

### Initialize TanStack Query Client

Source: https://tanstack.com/query/v5/docs/framework/react/examples/basic

Initializes a new instance of `QueryClient`, which is the core of TanStack Query for managing caches and queries. This client is then passed to the `PersistQueryClientProvider` to enable data fetching and caching throughout the React application.

```typescript
const queryClient = new QueryClient()
```

--------------------------------

### Await vue-query suspense in an async setup (Vue SFC)

Source: https://tanstack.com/query/v5/docs/framework/vue/guides/suspense

Demonstrates making a component's setup() async and using useQuery with its suspense helper to suspend until data is ready. Dependencies: Vue 3 and @tanstack/vue-query; Inputs: remote fetcher; Outputs: setup returns resolved data for template usage. Limitation: API is experimental and may change.

```vue
<script>
import { defineComponent } from 'vue'
import { useQuery } from '@tanstack/vue-query'

const todoFetcher = async () =>
  await fetch('https://jsonplaceholder.cypress.io/todos').then((response) =>
    response.json(),
  )
export default defineComponent({
  name: 'SuspendableComponent',
  async setup() {
    const { data, suspense } = useQuery(['todos'], todoFetcher)
    await suspense()

    return { data }
  },
})
</script>
```

--------------------------------

### Define Angular Root Component with Router Links

Source: https://tanstack.com/query/v5/docs/framework/angular/examples/devtools-panel

This Angular `AppComponent` serves as the root component for the application, configuring the main layout. It includes navigation links using `routerLink` for 'basic' and 'lazy' devtools panel examples and utilizes `router-outlet` to display routed content. The component uses `OnPush` change detection for optimized performance.

```ts
import { ChangeDetectionStrategy, Component } from '@angular/core'
import { RouterLink, RouterOutlet } from '@angular/router'

@Component({
  changeDetection: ChangeDetectionStrategy.OnPush,
  selector: 'app-root',
  template: `
    <ul>
      <li>
        <a routerLink="basic">Basic devtools panel example</a>
      </li>
      <li>
        <a routerLink="lazy">Lazy load devtools panel example</a>
      </li>
    </ul>

    <router-outlet />
  `,
  imports: [RouterOutlet, RouterLink],
})
export class AppComponent {}
```

--------------------------------

### Main SolidJS App Component with TanStack Query Provider and Routing

Source: https://tanstack.com/query/v5/docs/framework/solid/examples/basic

This `App` component is the root of the SolidJS application, managing the display of either the post list or a single post detail based on the `postId` state. It wraps the entire application with `QueryClientProvider` and `SolidQueryDevtools` for global query context and debugging. This component orchestrates the user interface and data flow through conditional rendering.

```tsx
const App: Component = () => {
  const [postId, setPostId] = createSignal(-1)

  return (
    <QueryClientProvider client={queryClient}>
      <SolidQueryDevtools />
      <p>
        As you visit the posts below, you will notice them in a loading state
        the first time you load them. However, after you return to this list and
        click on any posts you have already visited again, you will see them
        load instantly and background refresh right before your eyes!{' '}
        <strong>
          (You may need to throttle your network speed to simulate longer
          loading sequences)
        </strong>
      </p>
      {postId() > -1 ? (
        <Post postId={postId()} setPostId={setPostId} />
      ) : (
        <Posts setPostId={setPostId} />
      )}
    </QueryClientProvider>
  )
}

render(() => <App />, document.getElementById('root') as HTMLElement)
```

--------------------------------

### Initialize TanStack Query Client and Imports for SolidJS

Source: https://tanstack.com/query/v5/docs/framework/solid/examples/basic

This snippet sets up the `QueryClient` for TanStack Query within a SolidJS application, including necessary imports from `@tanstack/solid-query` and SolidJS itself. It configures global `defaultOptions` for queries, such as `gcTime` for cache management. The `Post` type definition is also included, defining the structure of the data to be fetched.

```tsx
/* @refresh reload */
import {
  QueryClient,
  QueryClientProvider,
  useQuery,
} from '@tanstack/solid-query'
import { SolidQueryDevtools } from '@tanstack/solid-query-devtools'
import { For, Match, Switch, createSignal } from 'solid-js'
import { render } from 'solid-js/web'
import type { Component, Setter } from 'solid-js'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: 1000 * 60 * 60 * 24, // 24 hours
    },
  },
})

type Post = {
  id: number
  title: string
  body: string
}
```

--------------------------------

### Passing Signals and Store Values to Solid Query Arguments

Source: https://tanstack.com/query/v5/docs/framework/solid/quick-start

Solid Query automatically handles reactivity when signals or store values are passed directly into the function arguments of its primitives. This allows for seamless updates of queries as the underlying signal or store values change, eliminating the need for manual observers.

```tsx
import {
  QueryClient,
  QueryClientProvider,
  useQuery,
} from '@tanstack/solid-query'
import { createSignal, For } from 'solid-js'

const queryClient = new QueryClient()

function Example() {
  const [enabled, setEnabled] = createSignal(false)
  const [todo, setTodo] = createSignal(0)

  // ‚úÖ passing a signal directly is safe and observers update
  // automatically when the value of a signal changes
  const todosQuery = useQuery(() => ({
    queryKey: ['todos'],
    queryFn: fetchTodos,
    enabled: enabled(),
  }))

  const todoDetailsQuery = useQuery(() => ({
    queryKey: ['todo', todo()],
    queryFn: fetchTodo,
    enabled: todo() > 0,
  }))

  return (
    <div>
      <Switch>
        <Match when={todosQuery.isPending}>
          <p>Loading...</p>
        </Match>
        <Match when={todosQuery.isError}>
          <p>Error: {todosQuery.error.message}</p>
        </Match>
        <Match when={todosQuery.isSuccess}>
          <For each={todosQuery.data}>
            {(todo) => (
              <button onClick={() => setTodo(todo.id)}>{todo.title}</button>
            )}
          </For>
        </Match>
      </Switch>
      <button onClick={() => setEnabled(!enabled())}>Toggle enabled</button>
    </div>
  )
}

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Example />
    </QueryClientProvider>
  )
}
```

--------------------------------

### Retrieve Latest Mutation Data by Key using useMutationState (Vue Query)

Source: https://tanstack.com/query/v5/docs/framework/vue/reference/useMutationState

Building on accessing specific mutation data, this example demonstrates how to get the most recent `data` for a mutation identified by `mutationKey`. It uses `useMutationState` to filter by `mutationKey` and select all `data` entries, then accesses the last element of the returned array to get the latest invocation's data. Each `mutate` call adds a new entry to the mutation cache for a defined `gcTime`.

```tsx
import { useMutation, useMutationState } from '@tanstack/vue-query'

const mutationKey = ['posts']

// Some mutation that we want to get the state for
const mutation = useMutation({
  mutationKey,
  mutationFn: (newPost) => {
    return axios.post('/posts', newPost)
  },
})

const data = useMutationState({
  // this mutation key needs to match the mutation key of the given mutation (see above)
  filters: { mutationKey },
  select: (mutation) => mutation.state.data,
})

// Latest mutation data
const latest = data[data.length - 1]
```

--------------------------------

### Set Placeholder Data with a Direct Value in TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/react/guides/placeholder-query-data

This example demonstrates how to provide static placeholder data directly to a `useQuery` hook. It allows the UI to render immediately with predefined data while the actual `queryFn` fetches the real data in the background, starting the query in a success state with `isPlaceholderData` set to true.

```tsx
function Todos() {
  const result = useQuery({
    queryKey: ['todos'],
    queryFn: () => fetch('/todos'),
    placeholderData: placeholderTodos,
  })
}
```

--------------------------------

### Remix Root Setup with TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/react/guides/ssr

Sets up the QueryClientProvider at the root of the Remix application. This ensures that the QueryClient is available throughout the application for managing queries. It initializes the QueryClient with default options suitable for SSR.

```tsx
// app/root.tsx
import { Outlet } from '@remix-run/react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

export default function MyApp() {
  const [queryClient] = React.useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            // With SSR, we usually want to set some default staleTime
            // above 0 to avoid refetching immediately on the client
            staleTime: 60 * 1000,
          },
        },
      }),
  )

  return (
    <QueryClientProvider client={queryClient}>
      <Outlet />
    </QueryClientProvider>
  )
}
```

--------------------------------

### Install React Testing Libraries via npm

Source: https://tanstack.com/query/v5/docs/framework/react/guides/testing

Installs @testing-library/react-hooks and react-test-renderer as dev dependencies. Required for testing React Query hooks in React 17 and earlier. Use npm install command.

```sh
npm install @testing-library/react-hooks react-test-renderer --save-dev
```

--------------------------------

### Prefetch Query on Mouse Enter with TanStack React Query

Source: https://tanstack.com/query/v5/docs/framework/react/examples/prefetching

React component that implements query prefetching by calling queryClient.prefetchQuery() on mouse enter events. The example fetches characters from an API, prefetches individual character data with a stale time of 10 seconds, and visually indicates prefetched items with bold text. It uses useQuery and useQueryClient hooks from TanStack Query for data management.

```typescript
import React from 'react'
import { useQuery, useQueryClient } from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'

const getCharacters = async (): Promise<{
  results: Array<{ id: number; name: string }>
}> => {
  await new Promise((r) => setTimeout(r, 500))
  const response = await fetch('https://rickandmortyapi.com/api/character/')
  return await response.json()
}

const getCharacter = async (selectedChar: number) => {
  await new Promise((r) => setTimeout(r, 500))
  const response = await fetch(
    `https://rickandmortyapi.com/api/character/${selectedChar}`,
  )
  return await response.json()
}

export default function Example() {
  const queryClient = useQueryClient()
  const rerender = React.useState(0)[1]
  const [selectedChar, setSelectedChar] = React.useState(1)

  const charactersQuery = useQuery({
    queryKey: ['characters'],
    queryFn: getCharacters,
  })

  const characterQuery = useQuery({
    queryKey: ['character', selectedChar],
    queryFn: () => getCharacter(selectedChar),
  })

  return (
    <div className="App">
      <p>
        Hovering over a character will prefetch it, and when it's been
        prefetched it will turn <strong>bold</strong>. Clicking on a prefetched
        character will show their stats below immediately.
      </p>
      <h2>Characters</h2>
      {charactersQuery.isPending ? (
        'Loading...'
      ) : (
        <>
          <ul>
            {charactersQuery.data?.results.map((char) => (
              <li
                key={char.id}
                onClick={() => {
                  setSelectedChar(char.id)
                }}
                onMouseEnter={async () => {
                  await queryClient.prefetchQuery({
                    queryKey: ['character', char.id],
                    queryFn: () => getCharacter(char.id),
                    staleTime: 10 * 1000,
                  })

                  setTimeout(() => {
                    rerender({})
                  }, 1)
                }}
              >
                <div
                  style={
                    queryClient.getQueryData(['character', char.id])
                      ? {
                          fontWeight: 'bold',
                        }
                      : {}
                  }
                >
                  {char.id} - {char.name}
                </div>
              </li>
            ))}
          </ul>

          <h3>Selected Character</h3>
          {characterQuery.isPending ? (
            'Loading...'
          ) : (
            <>
              <pre>{JSON.stringify(characterQuery.data, null, 2)}</pre>
            </>
          )}
          <ReactQueryDevtools initialIsOpen />
        </>
      )}
    </div>
  )
}
```

--------------------------------

### Main App Component with QueryClientProvider

Source: https://tanstack.com/query/v5/docs/framework/react/examples/basic-graphql-request

Root React component that wraps the application with TanStack Query's QueryClientProvider and ReactQueryDevtools. Manages post ID state and conditionally renders either the Posts list or individual Post detail view.

```typescript
function App() {
  const [postId, setPostId] = React.useState(-1)

  return (
    <QueryClientProvider client={queryClient}>
      {postId > -1 ? (
        <Post postId={postId} setPostId={setPostId} />
      ) : (
        <Posts setPostId={setPostId} />
      )}
      <ReactQueryDevtools initialIsOpen />
    </QueryClientProvider>
  )
}
```

--------------------------------

### Using Function Arguments with Solid Query Primitives

Source: https://tanstack.com/query/v5/docs/framework/solid/quick-start

Solid Query primitives, such as `useQuery`, `createMutation`, and `useIsFetching`, require arguments to be provided as functions. This ensures that their values are reactively tracked within Solid. In contrast, React Query accepts direct object arguments.

```tsx
// ‚ùå react version
useQuery({
  queryKey: ['todos', todo],
  queryFn: fetchTodos,
})

```

```tsx
// ‚úÖ solid version
useQuery(() => ({
  queryKey: ['todos', todo],
  queryFn: fetchTodos,
}))
```

--------------------------------

### React DOM Root Initialization with QueryClientProvider

Source: https://tanstack.com/query/v5/docs/framework/react/examples/playground

Initializes React 18 root element and renders the Root component wrapped with QueryClientProvider for TanStack Query v5 context. Includes React Query Devtools import for debugging query state and behavior.

```typescript
import React from 'react'
import ReactDOM from 'react-dom/client'
import {
  QueryClient,
  QueryClientProvider,
  useMutation,
  useQuery,
  useQueryClient,
} from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
import './styles.css'

const queryClient = new QueryClient()

const rootElement = document.getElementById('root') as HTMLElement
ReactDOM.createRoot(rootElement).render(<Root />)
```

--------------------------------

### Set Global Default Retry Delay (TanStack Vue Query)

Source: https://tanstack.com/query/v5/docs/framework/vue/guides/query-retries

This example shows how to configure a global `retryDelay` using the `VueQueryPlugin` options. It sets the default retry delay to double with each attempt, starting at 1000ms and not exceeding 30 seconds, following the standard exponential back-off strategy.

```ts
import { VueQueryPlugin } from '@tanstack/vue-query'

const vueQueryPluginOptions = {
  queryClientConfig: {
    defaultOptions: {
      queries: {
        retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
      },
    },
  },
}
app.use(VueQueryPlugin, vueQueryPluginOptions)
```

--------------------------------

### React Chat Application with TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/react/examples/chat

A complete chat application component that integrates TanStack Query's QueryClient and useQuery hook for managing chat message queries. The App component sets up the QueryClientProvider and ReactQueryDevtools, while the ChatMessage component fetches responses using chatQueryOptions, and the Example component manages the UI with message input and display functionality.

```typescript
import ReactDOM from 'react-dom/client'
import {
  QueryClient,
  QueryClientProvider,
  useQuery,
} from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'

import './style.css'
import { useState } from 'react'
import { chatQueryOptions } from './chat'
import { Message } from './message'

const queryClient = new QueryClient()

export default function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <ReactQueryDevtools />
      <Example />
    </QueryClientProvider>
  )
}

function ChatMessage({ question }: { question: string }) {
  const { error, data = [], isFetching } = useQuery(chatQueryOptions(question))

  if (error) return 'An error has occurred: ' + error.message

  return (
    <div>
      <Message message={{ content: question, isQuestion: true }} />
      <Message
        inProgress={isFetching}
        message={{ content: data.join(' '), isQuestion: false }}
      />
    </div>
  )
}

function Example() {
  const [questions, setQuestions] = useState<Array<string>>([])
  const [currentQuestion, setCurrentQuestion] = useState('')

  const submitMessage = () => {
    setQuestions([...questions, currentQuestion])
    setCurrentQuestion('')
  }

  return (
    <div className="flex flex-col h-screen max-w-3xl mx-auto p-4">
      <h1 className="text-3xl font-bold text-gray-800">
        TanStack Chat Example
      </h1>
      <div className="overflow-y-auto mb-4 space-y-4">
        {questions.map((question) => (
          <ChatMessage key={question} question={question} />
        ))}
      </div>

      <div className="flex items-center space-x-2">
        <input
          className="flex-1 p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-100"
          value={currentQuestion}
          onChange={(e) => setCurrentQuestion(e.target.value)}
          onKeyDown={(e) => {
            if (e.key === 'Enter') {
              submitMessage()
            }
          }}
          placeholder="Type your message..."
        />
        <button
          onClick={submitMessage}
          disabled={!currentQuestion.trim()}
          className="flex items-center gap-2 bg-blue-600 hover:bg-blue-700 text-white font-semibold px-4 py-2 rounded-2xl shadow-md transition"
        >
          <span>Send</span>
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <path d="M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z" />
            <path d="m21.854 2.147-10.94 10.939" />
          </svg>
        </button>
      </div>
    </div>
  )
}

const rootElement = document.getElementById('root') as HTMLElement
ReactDOM.createRoot(rootElement).render(<App />)
```

--------------------------------

### Get Pending Mutation Variables with useMutationState (Vue Query)

Source: https://tanstack.com/query/v5/docs/framework/vue/reference/useMutationState

This example demonstrates how to use `useMutationState` to retrieve the `variables` property from all mutations currently in a 'pending' state within the `MutationCache`. It filters mutations by their `status` and then selects the `variables` from each matching mutation's state.

```tsx
import { useMutationState } from '@tanstack/vue-query'

const variables = useMutationState({
  filters: { status: 'pending' },
  select: (mutation) => mutation.state.variables,
})
```

--------------------------------

### Install ESLint Plugin Query via npm package managers

Source: https://tanstack.com/query/v5/docs/eslint/eslint-plugin-query

Install the @tanstack/eslint-plugin-query package as a development dependency using various package managers including npm, pnpm, yarn, and bun.

```bash
npm i -D @tanstack/eslint-plugin-query
```

```bash
pnpm add -D @tanstack/eslint-plugin-query
```

```bash
yarn add -D @tanstack/eslint-plugin-query
```

```bash
bun add -D @tanstack/eslint-plugin-query
```

--------------------------------

### TypeScript: Example of Injecting QueryClient

Source: https://tanstack.com/query/v5/docs/framework/angular/reference/functions/injectqueryclient

Illustrates a basic usage of `injectQueryClient` to retrieve a `QueryClient` instance. This client is then ready for use with TanStack Query operations.

```typescript
const queryClient = injectQueryClient();
```

--------------------------------

### Basic Data Fetching with Solid Query `useQuery`

Source: https://tanstack.com/query/v5/docs/framework/solid/reference/useQuery

This example demonstrates the fundamental usage of the `useQuery` hook to fetch a list of todos from an API. It shows how to define `queryKey` and `queryFn`, and how to conditionally render UI based on the query's loading, error, and success states using SolidJS's `Show` component. The `queryFn` handles API calls and error checking, throwing an error if the response is not `ok`.

```tsx
import { useQuery } from '@tanstack/solid-query'

function App() {
  const todos = useQuery(() => ({
    queryKey: 'todos',
    queryFn: async () => {
      const response = await fetch('/api/todos')
      if (!response.ok) {
        throw new Error('Failed to fetch todos')
      }
      return response.json()
    },
  }))

  return (
    <div>
      <Show when={todos.isError}>
        <div>Error: {todos.error.message}</div>
      </Show>
      <Show when={todos.isLoading}>
        <div>Loading...</div>
      </Show>
      <Show when={todos.isSuccess}>
        <div>
          <div>Todos:</div>
          <ul>
            <For each={todos.data}>{(todo) => <li>{todo.title}</li>}</For>
          </ul>
        </div>
      </Show>
    </div>
  )
}
```

--------------------------------

### Prefetching Data with TanStack Query in Next.js App Router

Source: https://tanstack.com/query/v5/docs/framework/react/examples/nextjs-app-prefetching

This React component demonstrates how to prefetch data on the server-side using TanStack Query's `prefetchQuery` within a Next.js App Router setup. It utilizes `HydrationBoundary` to ensure the prefetched data is available and rehydrated on the client-side, preventing a loading state. The `getQueryClient` function is expected to provide a new QueryClient instance for each request to avoid state sharing issues, and `pokemonOptions` defines the query configuration.

```tsx
import React from 'react'
import { HydrationBoundary, dehydrate } from '@tanstack/react-query'
import { pokemonOptions } from '@/app/pokemon'
import { getQueryClient } from '@/app/get-query-client'
import { PokemonInfo } from './pokemon-info'

export default function Home() {
  const queryClient = getQueryClient()

  void queryClient.prefetchQuery(pokemonOptions)

  return (
    <main>
      <h1>Pokemon Info</h1>
      <HydrationBoundary state={dehydrate(queryClient)}>
        <PokemonInfo />
      </HydrationBoundary>
    </main>
  )
}
```

--------------------------------

### Manual Parallel Queries with TanStack Query (TypeScript)

Source: https://tanstack.com/query/v5/docs/framework/angular/guides/parallel-queries

This example demonstrates how to perform fixed-size parallel queries in TanStack Query by using multiple `injectQuery` instances side-by-side within an Angular component. Each `injectQuery` call runs concurrently to fetch different data sets (users, teams, projects), maximizing fetching concurrency without additional setup.

```typescript
export class AppComponent {
  // The following queries will execute in parallel
  usersQuery = injectQuery(() => ({ queryKey: ['users'], queryFn: fetchUsers }))
  teamsQuery = injectQuery(() => ({ queryKey: ['teams'], queryFn: fetchTeams }))
  projectsQuery = injectQuery(() => ({
    queryKey: ['projects'],
    queryFn: fetchProjects,
  }))
}
```

--------------------------------

### Setup QueryClientProvider in Svelte root

Source: https://tanstack.com/query/v5/docs/framework/svelte/overview

Initialize and configure the QueryClientProvider component near the root of your Svelte project. This provider wraps your application to enable query client functionality across all child components. It accepts a QueryClient instance that manages all query and mutation state.

```svelte
<script lang="ts">
  import { QueryClient, QueryClientProvider } from '@tanstack/svelte-query'
  import Example from './lib/Example.svelte'

  const queryClient = new QueryClient()
</script>

<QueryClientProvider client={queryClient}>
  <Example />
</QueryClientProvider>
```

--------------------------------

### Initialize broadcastQueryClient in TypeScript

Source: https://tanstack.com/query/v5/docs/framework/react/plugins/broadcastQueryClient

This example demonstrates how to import and initialize the `broadcastQueryClient` utility from `@tanstack/query-broadcast-client-experimental`. It creates a new `QueryClient` instance and then passes it to `broadcastQueryClient` along with an optional `broadcastChannel` name for inter-tab communication.

```tsx
import { broadcastQueryClient } from '@tanstack/query-broadcast-client-experimental'

const queryClient = new QueryClient()

broadcastQueryClient({
  queryClient,
  broadcastChannel: 'my-app',
})
```

--------------------------------

### Define Angular Root Component for Optimistic Updates (TypeScript)

Source: https://tanstack.com/query/v5/docs/framework/angular/examples/optimistic-updates

This Angular component defines the root application (`AppComponent`) with `OnPush` change detection. It imports and renders the `OptimisticUpdatesComponent` as its main template, serving as the entry point for the optimistic update example.

```typescript
import { ChangeDetectionStrategy, Component } from '@angular/core'
import { OptimisticUpdatesComponent } from './components/optimistic-updates.component'

@Component({
  changeDetection: ChangeDetectionStrategy.OnPush,
  selector: 'app-root',
  template: `<optimistic-updates />`,
  imports: [OptimisticUpdatesComponent]
})
export class AppComponent {}
```

--------------------------------

### Install Vue Query Devtools Package

Source: https://tanstack.com/query/v5/docs/framework/vue/devtools

Install the @tanstack/vue-query-devtools package using various package managers (npm, pnpm, yarn, or bun). This is a required dependency for integrating devtools into your Vue 3 application.

```bash
npm i @tanstack/vue-query-devtools
```

```bash
pnpm add @tanstack/vue-query-devtools
```

```bash
yarn add @tanstack/vue-query-devtools
```

```bash
bun add @tanstack/vue-query-devtools
```

--------------------------------

### Initialize basic React Query `useQuery` hook

Source: https://tanstack.com/query/v5/docs/framework/react/guides/queries

This snippet demonstrates the minimal setup for `useQuery` in TanStack React Query. It takes a unique `queryKey` (an array) and a `queryFn` (a promise-returning function) to fetch data, providing the core functionality for managing asynchronous data.

```tsx
import { useQuery } from '@tanstack/react-query'

function App() {
  const info = useQuery({ queryKey: ['todos'], queryFn: fetchTodoList })
}
```

--------------------------------

### Initialize Query with `injectQuery` in Angular

Source: https://tanstack.com/query/v5/docs/framework/angular/guides/queries

Demonstrates the basic setup of a data query using `injectQuery` in an Angular component. It requires a `queryKey` for identification and caching, and a `queryFn` which is an asynchronous function that fetches the data.

```ts
import { injectQuery } from '@tanstack/angular-query-experimental'

export class TodosComponent {
  info = injectQuery(() => ({ queryKey: ['todos'], queryFn: fetchTodoList }))
}
```

--------------------------------

### Fetch Posts List with GraphQL Query - Solid.js

Source: https://tanstack.com/query/v5/docs/framework/solid/examples/basic-graphql-request

Creates a reusable query hook using useQuery to fetch a list of posts from a GraphQL endpoint. Returns post data with id and title fields. Handles pending, error, and success states with proper TypeScript typing for the GraphQL response structure.

```TypeScript
function createPosts() {
  return useQuery(() => ({
    queryKey: ['posts'],
    queryFn: async () => {
      const {
        posts: { data },
      } = await request<{ posts: { data: Array<Post> } }>(
        endpoint,
        gql`
          query {
            posts {
              data {
                id
                title
              }
            }
          }
        `,
      )
      return data
    },
  }))
}
```

--------------------------------

### Get Active Mutation Count with useIsMutating in Solid Query

Source: https://tanstack.com/query/v5/docs/framework/solid/reference/useIsMutating

This snippet demonstrates how to use the `useIsMutating` hook from `@tanstack/solid-query` to retrieve the total number of ongoing mutations or mutations matching a specific `mutationKey`. It shows examples for both a global count and a filtered count for mutations related to 'posts', returning a number indicating active mutations.

```tsx
import { useIsMutating } from '@tanstack/solid-query'
// How many mutations are fetching?
const isMutating = useIsMutating()
// How many mutations matching the posts prefix are fetching?
const isMutatingPosts = useIsMutating({ mutationKey: ['posts'] })
```

--------------------------------

### Example: Using queryOptions for type-safe query configuration (TypeScript)

Source: https://tanstack.com/query/v5/docs/framework/angular/reference/functions/queryoptions

This example demonstrates how to use the `queryOptions` function to define a query with a specific `queryKey` and `queryFn`. It highlights how the return type of `queryFn` (a `Promise<number>`) correctly types the `queryKey` and, consequently, the data retrieved from the `QueryClient` as `number | undefined`.

```typescript
 const { queryKey } = queryOptions({
    queryKey: ['key'],
    queryFn: () => Promise.resolve(5),
    //  ^?  Promise<number>
  })

  const queryClient = new QueryClient()
  const data = queryClient.getQueryData(queryKey)
  //    ^?  number | undefined
```

--------------------------------

### Initialize and Subscribe to InfiniteQueryObserver (TSX)

Source: https://tanstack.com/query/v5/docs/reference/InfiniteQueryObserver

This example demonstrates how to create an instance of `InfiniteQueryObserver` in TypeScript/React Query, configuring it with a `queryKey`, `queryFn`, and pagination logic using `getNextPageParam` and `getPreviousPageParam`. It also shows how to subscribe to the observer's results and immediately unsubscribe after the first update.

```tsx
const observer = new InfiniteQueryObserver(queryClient, {
  queryKey: ['posts'],
  queryFn: fetchPosts,
  getNextPageParam: (lastPage, allPages) => lastPage.nextCursor,
  getPreviousPageParam: (firstPage, allPages) => firstPage.prevCursor,
})

const unsubscribe = observer.subscribe((result) => {
  console.log(result)
  unsubscribe()
})
```

--------------------------------

### Fetch data with useQuery hook and handle states

Source: https://tanstack.com/query/v5/docs/framework/react/examples/simple

Use the useQuery hook to fetch GitHub repository data with a unique query key and async query function. The hook returns isPending, error, data, and isFetching states for managing loading, error, and success UI states. Handles three states: loading, error, and success with data display.

```typescript
function Example() {
  const { isPending, error, data, isFetching } = useQuery({
    queryKey: ['repoData'],
    queryFn: async () => {
      const response = await fetch(
        'https://api.github.com/repos/TanStack/query',
      )
      return await response.json()
    },
  })

  if (isPending) return 'Loading...'

  if (error) return 'An error has occurred: ' + error.message

  return (
    <div>
      <h1>{data.full_name}</h1>
      <p>{data.description}</p>
      <strong>üëÄ {data.subscribers_count}</strong>{' '}
      <strong>‚ú® {data.stargazers_count}</strong>{' '}
      <strong>üç¥ {data.forks_count}</strong>
      <div>{isFetching ? 'Updating...' : ''}</div>
    </div>
  )
}
```

--------------------------------

### Configure Vite with Svelte Plugin

Source: https://tanstack.com/query/v5/docs/framework/svelte/examples/simple

Defines the Vite build configuration for a Svelte project, enabling the Svelte plugin to transform .svelte files during development and production builds. This configuration is essential for Hot Module Replacement (HMR) and optimized bundling.

```typescript
import { defineConfig } from 'vite'
import { svelte } from '@sveltejs/vite-plugin-svelte'

export default defineConfig({
  plugins: [svelte()],
})
```

--------------------------------

### Configure QueryClient with Cache Settings in TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/solid/examples/basic

Sets up a QueryClient instance with a garbage collection time of 24 hours to keep cached data persistent. This configuration determines how long inactive queries remain in the cache before being garbage collected.

```TypeScript
gcTime: 1000 * 60 * 60 * 24, // 24 hours
```

--------------------------------

### Prefetch with Suspense using usePrefetchQuery (TSX)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/prefetching

This TSX example shows prefetching in a layout component with usePrefetchQuery before a Suspense boundary, allowing parallel fetching without blocking renders. It uses TanStack Query v5's usePrefetchQuery and useSuspenseQuery, depending on a QueryClient. Input is an ID; output is a suspense-wrapped component, but note that primary data rendering is not blocked, though secondary prefetch might not start immediately if misused.

```tsx
function ArticleLayout({ id }) {
  usePrefetchQuery({
    queryKey: ['article-comments', id],
    queryFn: getArticleCommentsById,
  })

  return (
    <Suspense fallback="Loading article">
      <Article id={id} />
    </Suspense>
  )
}

function Article({ id }) {
  const { data: articleData, isPending } = useSuspenseQuery({
    queryKey: ['article', id],
    queryFn: getArticleById,
  })

  ...
}
```

--------------------------------

### Import SolidQueryDevtools Component

Source: https://tanstack.com/query/v5/docs/framework/solid/devtools

This line imports the `SolidQueryDevtools` component from the installed package. Once imported, the component can be used within your Solid.js application to enable the devtools.

```tsx
import { SolidQueryDevtools } from '@tanstack/solid-query-devtools'
```

--------------------------------

### Solid.js App Component with Query Provider

Source: https://tanstack.com/query/v5/docs/framework/solid/examples/default-query-function

Main application component that wraps the entire app with QueryClientProvider and SolidQueryDevtools. Uses Solid.js signals and Show component to conditionally render either a posts list or individual post detail based on the selected post ID.

```typescript
function App() {
  const [postId, setPostId] = createSignal(-1)

  return (
    <QueryClientProvider client={queryClient}>
      <SolidQueryDevtools />
      <p>
        As you visit the posts below, you will notice them in a loading state
        the first time you load them. However, after you return to this list and
        click on any posts you have already visited again, you will see them
        load instantly and background refresh right before your eyes!{' '}
        <strong>
          (You may need to throttle your network speed to simulate longer
          loading sequences)
        </strong>
      </p>
      <Show when={postId() > -1} fallback={<Posts setPostId={setPostId} />}>
        <Post postId={postId()} setPostId={setPostId} />
      </Show>
    </QueryClientProvider>
  )
}
```

--------------------------------

### Configure ESLint Plugin Query with legacy config recommended setup

Source: https://tanstack.com/query/v5/docs/eslint/eslint-plugin-query

Enable all recommended rules for the TanStack Query ESLint plugin using the legacy .eslintrc JSON format. Extends the recommended configuration preset provided by the plugin.

```json
{
  "extends": ["plugin:@tanstack/query/recommended"]
}
```

--------------------------------

### Next.js App Setup with TanStack Query Hydration

Source: https://tanstack.com/query/v5/docs/framework/react/guides/ssr

Shows how to set up TanStack Query and hydration in a Next.js application's `_app.tsx` file to reduce boilerplate. This approach centralizes the QueryClientProvider and HydrationBoundary, allowing child components to consume them directly.

```tsx
// _app.tsx
import {
  HydrationBoundary,
  QueryClient,
  QueryClientProvider,
} from '@tanstack/react-query'

export default function MyApp({ Component, pageProps }) {
  const [queryClient] = React.useState(() => new QueryClient())

  return (
    <QueryClientProvider client={queryClient}>
      <HydrationBoundary state={pageProps.dehydratedState}>
        <Component {...pageProps} />
      </HydrationBoundary>
    </QueryClientProvider>
  )
}

// pages/posts.tsx
// Remove PostsRoute with the HydrationBoundary and instead export Posts directly:
export default function Posts() { ... }
```

--------------------------------

### Conditional Rendering with Solid.js Switch/Match

Source: https://tanstack.com/query/v5/docs/framework/solid/examples/simple

Implements UI state management using Solid.js Switch and Match components to conditionally render loading state, error messages, or fetched data. Displays repository statistics including subscribers, stars, and forks count.

```typescript
<Switch>
  <Match when={state.isPending}>Loading...</Match>
  <Match when={state.error}>
    {'An error has occurred: ' + (state.error as Error).message}
  </Match>
  <Match when={state.data !== undefined}>
    <div>
      <h1>{state.data.name}</h1>
      <p>{state.data.description}</p>
      <strong>üëÄ {state.data.subscribers_count}</strong>{' '}
      <strong>‚ú® {state.data.stargazers_count}</strong>{' '}
      <strong>üç¥ {state.data.forks_count}</strong>
      <div>{state.isFetching ? 'Updating...' : ''}</div>
    </div>
  </Match>
</Switch>
```

--------------------------------

### API Response Structure with Cursor-Based Pagination

Source: https://tanstack.com/query/v5/docs/framework/solid/guides/infinite-queries

Example API endpoint responses demonstrating cursor-based pagination where each response includes a data array and a nextCursor for fetching subsequent pages.

```plaintext
fetch('/api/projects?cursor=0')
// { data: [...], nextCursor: 3}
fetch('/api/projects?cursor=3')
// { data: [...], nextCursor: 6}
fetch('/api/projects?cursor=6')
// { data: [...], nextCursor: 9}
fetch('/api/projects?cursor=9')
// { data: [...] }
```

--------------------------------

### SolidJS Component to Display and Interact with Post List

Source: https://tanstack.com/query/v5/docs/framework/solid/examples/basic

The `Posts` SolidJS component renders a list of post titles, dynamically fetched using the `createPosts` hook. It employs SolidJS `Switch` and `Match` components to display loading, error, or data states. Clicking a post title updates the application state, and cached posts are visually distinguished with bold, green text.

```tsx
function Posts(props: { setPostId: Setter<number> }) {
  const state = createPosts()

  return (
    <div>
      <h1>Posts</h1>
      <div>
        <Switch>
          <Match when={state.status === 'pending'}>Loading...</Match>
          <Match when={state.status === 'error'}>
            <span>Error: {(state.error as Error).message}</span>
          </Match>
          <Match when={state.data !== undefined}>
            <>
              <div>
                <For each={state.data}>
                  {(post) => (
                    <p>
                      <a
                        onClick={() => props.setPostId(post.id)}
                        href="#"
                        style={
                          // We can access the query data here to show bold links for
                          // ones that are cached
                          queryClient.getQueryData(['post', post.id])
                            ? {
                                'font-weight': 'bold',
                                color: 'green',
                              }
                            : {}
                        }
                      >
                        {post.title}
                      </a>
                    </p>
                  )}
                </For>
              </div>
              <div>{state.isFetching ? 'Background Updating...' : ' '}</div>
            </>
          </Match>
        </Switch>
      </div>
    </div>
  )
}
```

--------------------------------

### Initialize TanStack QueryCache with Lifecycle Callbacks

Source: https://tanstack.com/query/v5/docs/reference/QueryCache

Initialize a new `QueryCache` instance to manage query states and data. This example demonstrates how to configure global `onError`, `onSuccess`, and `onSettled` callbacks that will be triggered by any query events within this cache.

```tsx
import { QueryCache } from '@tanstack/react-query'

const queryCache = new QueryCache({
  onError: (error) => {
    console.log(error)
  },
  onSuccess: (data) => {
    console.log(data)
  },
  onSettled: (data, error) => {
    console.log(data, error)
  },
})

const query = queryCache.find(['posts'])
```

--------------------------------

### Manual Parallel Queries with useQuery (React)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/parallel-queries

Demonstrates how to run multiple `useQuery` hooks in parallel. This approach is suitable when the number of queries is static and known at render time. It requires no special setup beyond calling the hooks.

```tsx
function App () {
  // The following queries will execute in parallel
  const usersQuery = useQuery({ queryKey: ['users'], queryFn: fetchUsers })
  const teamsQuery = useQuery({ queryKey: ['teams'], queryFn: fetchTeams })
  const projectsQuery = useQuery({ queryKey: ['projects'], queryFn: fetchProjects })
  ...
}
```

--------------------------------

### Display Single Post Detail with Background Refresh - Solid.js

Source: https://tanstack.com/query/v5/docs/framework/solid/examples/basic-graphql-request

Renders a single post detail view with back navigation and displays loading/error/success states. Shows isFetching indicator for background updates. Uses Switch/Match for conditional rendering based on query state and post availability.

```TypeScript
function Post(props: { postId: number; setPostId: Setter<number> }) {
  const state = createPost(() => props.postId)

  return (
    <div>
      <div>
        <a onClick={() => props.setPostId(-1)} href="#">
          Back
        </a>
      </div>
      <Switch>
        <Match when={!props.postId || state.status === 'pending'}>
          Loading...
        </Match>
        <Match when={state.status === 'error'}>
          <span>Error: {(state.error as Error).message}</span>
        </Match>
        <Match when={state.data !== undefined}>
          <>
            <h1>{state.data?.title}</h1>
            <div>
              <p>{state.data?.body}</p>
            </div>
            <div>{state.isFetching ? 'Background Updating...' : ' '}</div>
          </>
        </Match>
      </Switch>
    </div>
  )
}
```

--------------------------------

### SolidJS createResource for basic data fetching

Source: https://tanstack.com/query/v5/docs/framework/solid/overview

This SolidJS code snippet demonstrates basic server-side data fetching using `createResource`. It fetches repository data from the GitHub API and uses `Suspense` for loading states and `ErrorBoundary` for error handling, showcasing SolidJS's built-in capabilities for managing asynchronous operations.

```tsx
import { createResource, ErrorBoundary, Suspense } from 'solid-js'
import { render } from 'solid-js/web'

function App() {
  const [repository] = createResource(async () => {
    const result = await fetch('https://api.github.com/repos/TanStack/query')
    if (!result.ok) throw new Error('Failed to fetch data')
    return result.json()
  })

  return (
    <div>
      <div>Static Content</div>
      {/* An error while fetching will be caught by the ErrorBoundary */}
      <ErrorBoundary fallback={<div>Something went wrong!</div>}>
        {/* Suspense will trigger a loading state while the data is being fetched */}
        <Suspense fallback={<div>Loading...</div>}>
          <div>{repository()?.updated_at}</div>
        </Suspense>
      </ErrorBoundary>
    </div>
  )
}

const root = document.getElementById('root')

render(() => <App />, root!)
```

--------------------------------

### Initialize QueryClient with Default Query Function

Source: https://tanstack.com/query/v5/docs/framework/react/examples/default-query-function

Sets up the QueryClient with a default query function that handles data fetching. This eliminates the need to specify a queryFn for each individual query, reducing boilerplate code.

```typescript
queryFn: defaultQueryFn,
},
```

--------------------------------

### Configure Svelte Compiler with Runes Support

Source: https://tanstack.com/query/v5/docs/framework/svelte/examples/simple

Configures the Svelte compiler to enable runes (Svelte 5 reactivity syntax) and preprocesses files using Vite's preprocessor. This configuration allows usage of modern Svelte 5 features like $state, $derived, and other runes.

```javascript
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte'

export default {
  preprocess: vitePreprocess(),
  compilerOptions: {
    runes: true,
  },
}
```

--------------------------------

### PersistQueryClientProvider React Component Setup

Source: https://tanstack.com/query/v5/docs/framework/react/plugins/persistQueryClient

React component that provides query client persistence with proper lifecycle management. Handles async restoration, prevents race conditions during mounting, and manages subscription/unsubscription automatically. Replaces standard QueryClientProvider for persisted configurations.

```tsx
import { PersistQueryClientProvider } from '@tanstack/react-query-persist-client'
import { createAsyncStoragePersister } from '@tanstack/query-async-storage-persister'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: 1000 * 60 * 60 * 24, // 24 hours
    },
  },
})

const persister = createAsyncStoragePersister({
  storage: window.localStorage,
})

ReactDOM.createRoot(rootElement).render(
  <PersistQueryClientProvider
    client={queryClient}
    persistOptions={{ persister }}
  >
    <App />
  </PersistQueryClientProvider>,
)
```

--------------------------------

### Define Post Type and Fetch Posts with useQuery in TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/solid/examples/basic

Defines a Post interface with id, title, and body properties, then creates a createPosts hook using TanStack Query's useQuery to fetch an array of posts from JSONPlaceholder API. Returns query state including data, status, and error information.

```TypeScript
type Post = {
  id: number
  title: string
  body: string
}

function createPosts() {
  return useQuery(() => ({
    queryKey: ['posts'],
    queryFn: async (): Promise<Array<Post>> => {
      const response = await fetch('https://jsonplaceholder.typicode.com/posts')
      return await response.json()
    },
  }))
}
```

--------------------------------

### useMutation Hook Configuration

Source: https://tanstack.com/query/v5/docs/framework/solid/reference/useMutation

Comprehensive guide to configuring the useMutation hook with meta information and custom QueryClient. Learn how to store additional metadata on mutation cache entries and use custom QueryClient instances.

```APIDOC
## useMutation Hook - Configuration Parameters

### Description
Configures metadata and QueryClient settings for mutation instances in TanStack Query v5.

### Parameters

#### meta (Optional)
- **Type**: `Record<string, unknown>`
- **Required**: No
- **Description**: Stores additional information on the mutation cache entry that can be used as needed. It will be accessible wherever the mutation is available (e.g., `onError`, `onSuccess` functions of the `MutationCache`).

#### queryClient (Optional)
- **Type**: `QueryClient`
- **Required**: No
- **Description**: Use this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.

### Configuration Example
```javascript
const mutation = useMutation({
  mutationFn: async (variables) => {
    // mutation logic
  },
  meta: {
    customData: "value",
    userId: 123
  },
  queryClient: customQueryClient
});
```
```

--------------------------------

### Render React App with React DOM in TSX

Source: https://tanstack.com/query/v5/docs/framework/react/examples/algolia

Initializes and renders a React application using ReactDOM.createRoot() in a TypeScript React environment. This is the standard entry point for mounting a React app to a DOM element with proper type safety.

```tsx
import ReactDOM from 'react-dom/client'

import App from './App'

const rootElement = document.getElementById('root') as HTMLElement
ReactDOM.createRoot(rootElement).render(<App />)
```

--------------------------------

### Main React Application Component with TanStack Query Persistence

Source: https://tanstack.com/query/v5/docs/framework/react/examples/basic

The `App` component is the main entry point of the application, managing the `postId` state to switch between the `Posts` list and `Post` detail views. It wraps the application with `PersistQueryClientProvider` to enable caching and persistence for TanStack Query, using the configured `persister`.

```typescript
function App() {
  const [postId, setPostId] = React.useState(-1)

  return (
    <PersistQueryClientProvider
      client={queryClient}
      persistOptions={{ persister }}
    >
      <p>
        As you visit the posts below, you will notice them in a loading state
        the first time you load them. However, after you return to this list and
        click on any posts you have already visited again, you will see them
        load instantly and background refresh right before your eyes!{' '}
        <strong>
          (You may need to throttle your network speed to simulate longer
          loading sequences)
        </strong>
      </p>
      {postId > -1 ? (
        <Post postId={postId} setPostId={setPostId} />
      ) : (
        <Posts setPostId={setPostId} />
      )}
      <ReactQueryDevtools initialIsOpen />
    </PersistQueryClientProvider>
  )
}
```

--------------------------------

### Initialize Vue Query Plugin

Source: https://tanstack.com/query/v5/docs/framework/vue/installation

Initializes the Vue Query plugin within your Vue application. This step is crucial before using any Vue Query hooks or features. It requires an instance of your Vue application.

```tsx
import { VueQueryPlugin } from '@tanstack/vue-query'

app.use(VueQueryPlugin)
```

--------------------------------

### TypeScript: Example of mutationOptions usage in a service and component

Source: https://tanstack.com/query/v5/docs/framework/angular/reference/functions/mutationoptions

This example demonstrates how to define and encapsulate mutation options within an Angular service using `mutationOptions`, including `mutationFn`, `mutationKey`, and `onSuccess` callbacks. It also shows how to inject and use this defined mutation within an Angular component to update data.

```ts
export class QueriesService {
  private http = inject(HttpClient)
  private queryClient = inject(QueryClient)

  updatePost(id: number) {
    return mutationOptions({
      mutationFn: (post: Post) => Promise.resolve(post),
      mutationKey: ["updatePost", id],
      onSuccess: (newPost) => {
        //           ^? newPost: Post
        this.queryClient.setQueryData(["posts", id], newPost)
      },
    });
  }
}

class ComponentOrService {
  queries = inject(QueriesService)
  id = signal(0)
  mutation = injectMutation(() => this.queries.updatePost(this.id()))

  save() {
    this.mutation.mutate({ title: 'New Title' })
  }
}
```

--------------------------------

### Basic useQuery Hook Structure and Configuration in TSX

Source: https://tanstack.com/query/v5/docs/framework/react/reference/useQuery

This snippet illustrates the comprehensive structure of the `useQuery` hook from TanStack Query, demonstrating the destructuring of its various return values (e.g., data, error, loading states) and the wide range of configuration options it accepts. It highlights essential parameters like `queryKey` and `queryFn`, alongside advanced options for caching, retries, refetching intervals, and network behavior. This example serves as a reference for integrating `useQuery` into a React component for robust data management.

```tsx
const {
  data,
  dataUpdatedAt,
  error,
  errorUpdatedAt,
  failureCount,
  failureReason,
  fetchStatus,
  isError,
  isFetched,
  isFetchedAfterMount,
  isFetching,
  isInitialLoading,
  isLoading,
  isLoadingError,
  isPaused,
  isPending,
  isPlaceholderData,
  isRefetchError,
  isRefetching,
  isStale,
  isSuccess,
  isEnabled,
  promise,
  refetch,
  status,
} = useQuery(
  {
    queryKey,
    queryFn,
    gcTime,
    enabled,
    networkMode,
    initialData,
    initialDataUpdatedAt,
    meta,
    notifyOnChangeProps,
    placeholderData,
    queryKeyHashFn,
    refetchInterval,
    refetchIntervalInBackground,
    refetchOnMount,
    refetchOnReconnect,
    refetchOnWindowFocus,
    retry,
    retryOnMount,
    retryDelay,
    select,
    staleTime,
    structuralSharing,
    subscribed,
    throwOnError,
  },
  queryClient,
)
```

--------------------------------

### useInfiniteQuery: Bi-Directional Fetching (React)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-react-query-3

Illustrates the configuration for `useInfiniteQuery` with bi-directional fetching support. It includes options and properties for both forward (`getNextPageParam`, `hasNextPage`, `fetchNextPage`) and backward (`getPreviousPageParam`, `hasPreviousPage`, `fetchPreviousPage`) data fetching.

```tsx
const {
  data,
  fetchNextPage,
  fetchPreviousPage,
  hasNextPage,
  hasPreviousPage,
  isFetchingNextPage,
  isFetchingPreviousPage,
} = useInfiniteQuery(
  'projects',
  ({ pageParam = 0 }) => fetchProjects(pageParam),
  {
    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
    getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,
  },
)
```

--------------------------------

### Build Nuxt 3 Application for Production (Bash)

Source: https://tanstack.com/query/v5/docs/framework/vue/examples/nuxt3

This `yarn build` command compiles and optimizes the Nuxt 3 application for a production environment. It prepares all static assets and code for deployment, ensuring optimal performance, bundle size, and efficiency in a live setting.

```bash
yarn build
```

--------------------------------

### Fetch and Display Posts List with Solid.js useQuery Hook

Source: https://tanstack.com/query/v5/docs/framework/solid/examples/default-query-function

Implements a Posts component that uses the useQuery hook to fetch a list of posts from the API. The component handles loading, error, and success states using Solid.js Switch/Match components. It displays visual indicators for cached posts by checking the query cache and applying styling.

```typescript
function Posts(props: { setPostId: Setter<number> }) {
  const state = useQuery<any[]>(() => ({ queryKey: ['/posts'] }))

  return (
    <div>
      <h1>Posts</h1>
      <div>
        <Switch>
          <Match when={state.status === 'pending'}>Loading...</Match>
          <Match when={state.status === 'error'}>
            <span>Error: {(state.error as Error).message}</span>
          </Match>
          <Match when={state.data !== undefined}>
            <>
              <div>
                <For each={state.data}>
                  {(post) => (
                    <p>
                      <a
                        onClick={() => props.setPostId(post.id)}
                        href="#"
                        style={
                          queryClient.getQueryData(['post', post.id])
                            ? {
                                'font-weight': 'bold',
                                color: 'green',
                              }
                            : {}
                        }
                      >
                        {post.title}
                      </a>
                    </p>
                  )}
                </For>
              </div>
              <div>{state.isFetching ? 'Background Updating...' : ' '}</div>
            </>
          </Match>
        </Switch>
      </div>
    </div>
  )
}
```

--------------------------------

### useMutation Async/Await with mutateAsync (React)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-react-query-3

Shows how to use the `mutateAsync` function from `useMutation` with `async/await` for promise-based operations. This is the recommended approach when you need to handle mutation results or errors asynchronously.

```tsx
const { mutateAsync } = useMutation({ mutationFn: addTodo })

try {
  const data = await mutateAsync('todo')
  console.log(data)
} catch (error) {
  console.error(error)
} finally {
  console.log('settled')
}
```

--------------------------------

### Incorrect TanStack Query Key Usage (ESLint Rule)

Source: https://tanstack.com/query/v5/docs/eslint/exhaustive-deps

These examples demonstrate incorrect usage of TanStack Query keys where variables used within the `queryFn` (like `todoId` or `id`) are not included in the `queryKey` array. This violates the exhaustive dependencies rule, potentially leading to stale data or incorrect caching. The first example uses a hardcoded key, while the second defines a factory function with a missing dependency in its key.

```tsx
/* eslint "@tanstack/query/exhaustive-deps": "error" */

useQuery({
  queryKey: ['todo'],
  queryFn: () => api.getTodo(todoId),
})
```

```tsx
const todoQueries = {
  detail: (id) => ({ queryKey: ['todo'], queryFn: () => api.getTodo(id) }),
}
```

--------------------------------

### Define Query Options with queryOptions in Angular

Source: https://tanstack.com/query/v5/docs/framework/angular/guides/query-options

Shows how to create a service with queryOptions helper for TypeScript type inference and query co-location. Includes usage examples with injectQuery and queryClient methods.

```typescript
import { queryOptions } from '@tanstack/angular-query-experimental'

@Injectable({
  providedIn: 'root',
})
export class QueriesService {
  private http = inject(HttpClient)

  post(postId: number) {
    return queryOptions({
      queryKey: ['post', postId],
      queryFn: () => {
        return lastValueFrom(
          this.http.get<Post>(
            `https://jsonplaceholder.typicode.com/posts/${postId}`,
          ),
        )
      },
    })
  }
}

// usage:

postId = input.required({
  transform: numberAttribute,
})
queries = inject(QueriesService)

postQuery = injectQuery(() => this.queries.post(this.postId()))

queryClient.prefetchQuery(this.queries.post(23))
queryClient.setQueryData(this.queries.post(42).queryKey, newPost)
```

--------------------------------

### Define Root Angular Application Component (`app.component.ts`)

Source: https://tanstack.com/query/v5/docs/framework/angular/examples/simple

This TypeScript snippet defines the `AppComponent`, which serves as the root component for the Angular application. It utilizes `ChangeDetectionStrategy.OnPush` for optimized change detection and imports `SimpleExampleComponent` for rendering within its template. This component is the main entry point for the application's user interface.

```typescript
import { ChangeDetectionStrategy, Component } from '@angular/core'
import { SimpleExampleComponent } from './components/simple-example.component'

@Component({
  selector: 'app-root',
  changeDetection: ChangeDetectionStrategy.OnPush,
  imports: [SimpleExampleComponent],
  template: `<simple-example />`,
})
export class AppComponent {}
```

--------------------------------

### useInfiniteQuery: Single Direction Fetching (React)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-react-query-3

Shows the basic configuration for `useInfiniteQuery` supporting single-direction fetching (forward). It includes renamed properties like `hasNextPage` and `fetchNextPage`, and the `getNextPageParam` option.

```tsx
const { data, fetchNextPage, hasNextPage, isFetchingNextPage } = 
  useInfiniteQuery(
    'projects',
    ({ pageParam = 0 }) => fetchProjects(pageParam),
    {
      getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
    },
  )
```

--------------------------------

### useMutation Callbacks with mutate (React)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-react-query-3

Demonstrates using the `mutate` function from `useMutation` with callbacks (`onSuccess`, `onError`, `onSettled`). This function is intended for scenarios where promise-like behavior is not required.

```tsx
const { mutate } = useMutation({ mutationFn: addTodo })

mutate('todo', {
  onSuccess: (data) => {
    console.log(data)
  },
  onError: (error) => {
    console.error(error)
  },
  onSettled: () => {
    console.log('settled')
  },
})
```

--------------------------------

### SvelteKit Layout Load Function for QueryClient Setup

Source: https://tanstack.com/query/v5/docs/framework/svelte/ssr

This SvelteKit `load` function, typically in `+layout.ts`, initializes a new `QueryClient` instance. It configures `defaultOptions.queries.enabled` to `browser`, ensuring queries are disabled on the server. The `queryClient` instance is then returned, making it available for subsequent page `load` functions and components for prefetching and data hydration.

```ts
import { browser } from '$app/environment'
import { QueryClient } from '@tanstack/svelte-query'

export async function load() {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        enabled: browser,
      },
    },
  })

  return { queryClient }
}
```

--------------------------------

### useInfiniteQuery Load More UI Implementation

Source: https://tanstack.com/query/v5/docs/framework/solid/guides/infinite-queries

Complete Solid Query implementation of useInfiniteQuery for a projects list with load more button. Demonstrates fetching initial data, handling pagination state, rendering pages, and managing loading states with proper error handling.

```tsx
import { useInfiniteQuery } from '@tanstack/solid-query'

function Projects() {
  const fetchProjects = async ({ pageParam }) => {
    const res = await fetch('/api/projects?cursor=' + pageParam)
    return res.json()
  }

  const {
    data,
    error,
    fetchNextPage,
    hasNextPage,
    isFetching,
    isFetchingNextPage,
    status,
  } = useInfiniteQuery(() => ({
    queryKey: ['projects'],
    queryFn: fetchProjects,
    initialPageParam: 0,
    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
  }))

  return status === 'pending' ? (
    <p>Loading...</p>
  ) : status === 'error' ? (
    <p>Error: {error.message}</p>
  ) : (
    <>
      {data.pages.map((group, i) => (
        <React.Fragment key={i}>
          {group.data.map((project) => (
            <p key={project.id}>{project.name}</p>
          ))}
        </React.Fragment>
      ))}
      <div>
        <button
          onClick={() => fetchNextPage()}
          disabled={!hasNextPage || isFetching}
        >
          {isFetchingNextPage
            ? 'Loading more...'
            : hasNextPage
              ? 'Load More'
              : 'Nothing more to load'}
        </button>
      </div>
      <div>{isFetching && !isFetchingNextPage ? 'Fetching...' : null}</div>
    </>
  )
}
```

--------------------------------

### Compressed Storage with lz-string

Source: https://tanstack.com/query/v5/docs/framework/react/plugins/createSyncStoragePersister

Example of implementing custom serialization using lz-string compression to store more data in localStorage than the default size limit allows.

```tsx
import { QueryClient } from '@tanstack/react-query'
import { persistQueryClient } from '@tanstack/react-query-persist-client'
import { createSyncStoragePersister } from '@tanstack/query-sync-storage-persister'

import { compress, decompress } from 'lz-string'

const queryClient = new QueryClient({
  defaultOptions: { queries: { staleTime: Infinity } },
})

persistQueryClient({
  queryClient: queryClient,
  persister: createSyncStoragePersister({
    storage: window.localStorage,
    serialize: (data) => compress(JSON.stringify(data)),
    deserialize: (data) => JSON.parse(decompress(data)),
  }),
  maxAge: Infinity,
})
```

--------------------------------

### Sync Storage Persister with Retry Strategy

Source: https://tanstack.com/query/v5/docs/framework/react/plugins/createSyncStoragePersister

Example of configuring a sync storage persister with the removeOldestQuery predefined retry strategy to handle storage failures.

```tsx
const localStoragePersister = createSyncStoragePersister({
  storage: window.localStorage,
  retry: removeOldestQuery,
})
```

--------------------------------

### Define Vue App Component with TanStack Query and State Management

Source: https://tanstack.com/query/v5/docs/framework/vue/examples/basic

This Vue.js component, 'App.vue', serves as the main entry point for the application. It manages the state of visited posts using Vue's reactivity system and conditionally renders either a list of posts ('Posts') or a single post view ('Post') based on the `postId`. It integrates `VueQueryDevtools` for development and debugging purposes.

```vue
<script lang="ts">
import { defineComponent, ref } from 'vue'
import { VueQueryDevtools } from '@tanstack/vue-query-devtools'

import Posts from './Posts.vue'
import Post from './Post.vue'

export default defineComponent({
  name: 'App',
  components: { Posts, Post, VueQueryDevtools },
  setup() {
    const visitedPosts = ref(new Set())
    const isVisited = (id: number) => visitedPosts.value.has(id)

    const postId = ref(-1)
    const setPostId = (id: number) => {
      visitedPosts.value.add(id)
      postId.value = id
    }

    return {
      isVisited,
      postId,
      setPostId,
    }
  },
})
</script>

<template>
  <h1>Vue Query - Basic</h1>
  <p>
    As you visit the posts below, you will notice them in a loading state the
    first time you load them. However, after you return to this list and click
    on any posts you have already visited again, you will see them load
    instantly and background refresh right before your eyes!
    <strong>
      (You may need to throttle your network speed to simulate longer loading
      sequences)
    </strong>
  </p>
  <Post v-if="postId > -1" :postId="postId" @setPostId="setPostId" />
  <Posts v-else :isVisited="isVisited" @setPostId="setPostId" />
  <VueQueryDevtools />
</template>

```

--------------------------------

### Create Root Component with OnPush Change Detection in Angular

Source: https://tanstack.com/query/v5/docs/framework/angular/examples/pagination

Defines the root AppComponent using Angular's OnPush change detection strategy for performance optimization. The component renders the ExampleComponent which contains the pagination logic. Uses Angular's standalone component pattern with the imports array.

```TypeScript
import { ChangeDetectionStrategy, Component } from '@angular/core'
import { ExampleComponent } from './components/example.component'

@Component({
  changeDetection: ChangeDetectionStrategy.OnPush,
  selector: 'app-root',
  template: `<example />`,
  imports: [ExampleComponent],
})
export class AppComponent {}
```

--------------------------------

### Configure TypeScript for Svelte Project

Source: https://tanstack.com/query/v5/docs/framework/svelte/examples/simple

Extends the Svelte TypeScript configuration with ESNext target, enables type checking for JavaScript and Svelte files, and configures module resolution. Includes source files from the src directory for type safety across the application.

```json
{
  "extends": "@tsconfig/svelte/tsconfig.json",
  "compilerOptions": {
    "target": "ESNext",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "resolveJsonModule": true,
    "allowJs": true,
    "checkJs": true,
    "isolatedModules": true
  },
  "include": [
    "src/**/*.d.ts",
    "src/**/*.ts",
    "src/**/*.js",
    "src/**/*.svelte",
    "vite.config.ts"
  ]
}
```

--------------------------------

### Configure ESLint Plugin Query with flat config recommended setup

Source: https://tanstack.com/query/v5/docs/eslint/eslint-plugin-query

Enable all recommended rules for the TanStack Query ESLint plugin using the modern flat config format (eslint.config.js). Imports the plugin and spreads the recommended configuration into the default export.

```javascript
import pluginQuery from '@tanstack/eslint-plugin-query'

export default [
  ...pluginQuery.configs['flat/recommended'],
  // Any other config...
]
```

--------------------------------

### Configure TanStack Query Storage Persister in React

Source: https://tanstack.com/query/v5/docs/framework/react/examples/basic

Sets up an asynchronous storage persister for TanStack Query using `window.localStorage`. This allows query cache data to be persisted across browser sessions, improving user experience by instantly loading cached data upon revisit.

```typescript
const persister = createAsyncStoragePersister({
  storage: window.localStorage,
})
```

--------------------------------

### Define Vue.js Root App Component with Post Navigation Logic

Source: https://tanstack.com/query/v5/docs/framework/vue/examples/persister

This Vue `App` component serves as the main entry point, handling the state for visited posts and the currently selected post ID. It utilizes Vue's `ref` for reactive state management and `Set` to efficiently track post visit status, dynamically rendering either a single `Post` component or a `Posts` list based on the `postId` state.

```vue
<script lang="ts">
import { defineComponent, ref } from 'vue'

import Posts from './Posts.vue'
import Post from './Post.vue'

export default defineComponent({
  name: 'App',
  components: { Posts, Post },
  setup() {
    const visitedPosts = ref(new Set())
    const isVisited = (id: number) => visitedPosts.value.has(id)

    const postId = ref(-1)
    const setPostId = (id: number) => {
      visitedPosts.value.add(id)
      postId.value = id
    }

    return {
      isVisited,
      postId,
      setPostId,
    }
  },
})
</script>

<template>
  <h1>Vue Query - Basic</h1>
  <p>
    As you visit the posts below, you will notice them in a loading state the
    first time you load them. However, after you return to this list and click
    on any posts you have already visited again, you will see them load
    instantly and background refresh right before your eyes!
    <strong>
      (You may need to throttle your network speed to simulate longer loading
      sequences)
    </strong>
  </p>
  <Post v-if="postId > -1" :postId="postId" @setPostId="setPostId" />
  <Posts v-else :isVisited="isVisited" @setPostId="setPostId" />
</template>
```

--------------------------------

### useMutationState - Get Data for Specific Mutations by Key

Source: https://tanstack.com/query/v5/docs/framework/solid/reference/useMutationState

Shows how to use useMutationState to retrieve data from specific mutations identified by a mutationKey. This is useful when you want to track the response data from particular mutation operations.

```APIDOC
## useMutationState - Get Data for Specific Mutations by Key

### Description
Retrieve mutation data for specific mutations identified by their mutationKey using useMutationState with key-based filtering.

### Hook Signature
```typescript
useMutationState({
  filters: { mutationKey: string[] },
  select: (mutation: Mutation) => TResult
}): Array<TResult>
```

### Parameters
- **filters.mutationKey** (string[]) - Required - Array identifying the specific mutation to track (must match the mutation's mutationKey)
- **select** (function) - Required - Transformation function to extract mutation.state.data

### Request Example
```tsx
import { useMutation, useMutationState } from '@tanstack/solid-query'

const mutationKey = ['posts']

const mutation = useMutation({
  mutationKey,
  mutationFn: (newPost) => {
    return axios.post('/posts', newPost)
  }
})

const data = useMutationState({
  filters: { mutationKey },
  select: (mutation) => mutation.state.data
})
```

### Response
- **Returns** (Array<TResult>) - Array containing the data from mutations matching the specified mutationKey
```

--------------------------------

### Render Posts List with Loading and Error States in Solid.js

Source: https://tanstack.com/query/v5/docs/framework/solid/examples/basic

Displays a posts list component using Solid.js with conditional rendering for pending, error, and success states. Implements visual caching indicators using queryClient.getQueryData() to highlight cached posts with bold green styling and displays background update status.

```TypeScript
function Posts(props: { setPostId: Setter<number> }) {
  const state = createPosts()

  return (
    <div>
      <h1>Posts</h1>
      <div>
        <Switch>
          <Match when={state.status === 'pending'}>Loading...</Match>
          <Match when={state.status === 'error'}>
            <span>Error: {(state.error as Error).message}</span>
          </Match>
          <Match when={state.data !== undefined}>
            <>
              <div>
                <For each={state.data}>
                  {(post) => (
                    <p>
                      <a
                        onClick={() => props.setPostId(post.id)}
                        href="#"
                        style={
                          queryClient.getQueryData(['post', post.id])
                            ? {
                                'font-weight': 'bold',
                                color: 'green',
                              }
                            : {}
                        }
                      >
                        {post.title}
                      </a>
                    </p>
                  )}
                </For>
              </div>
              <div>{state.isFetching ? 'Background Updating...' : ' '}</div>
            </>
          </Match>
        </Switch>
      </div>
    </div>
  )
}
```

--------------------------------

### Prefetching Infinite Queries with TanStack Query (TypeScript)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/prefetching

This example illustrates how to prefetch multiple pages of an infinite query using `queryClient.prefetchInfiniteQuery`. It specifies the `queryKey`, `queryFn`, `initialPageParam`, and a `getNextPageParam` function, along with the number of pages to prefetch, to proactively load paginated data into the cache.

```tsx
const prefetchProjects = async () => {
  // The results of this query will be cached like a normal query
  await queryClient.prefetchInfiniteQuery({
    queryKey: ['projects'],
    queryFn: fetchProjects,
    initialPageParam: 0,
    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
    pages: 3, // prefetch the first 3 pages
  })
}
```

--------------------------------

### React App with TanStack Query Integration

Source: https://tanstack.com/query/v5/docs/framework/react/examples/simple

Main React application component that renders a GitHub repository information display using TanStack Query for data fetching. The component displays repository statistics including subscribers, stargazers, and forks count, with a loading state indicator when data is being updated.

```typescript
const rootElement = document.getElementById('root') as HTMLElement
ReactDOM.createRoot(rootElement).render()
```

--------------------------------

### Proper Case String Formatter

Source: https://tanstack.com/query/v5/docs/framework/solid/examples/astro

Utility function that converts a string to proper case by capitalizing the first character and preserving the rest of the string. Simple text transformation helper commonly used for display formatting.

```typescript
export const properCase = (str: string) =>
  str.charAt(0).toUpperCase() + str.slice(1)
```

--------------------------------

### Create QueryClient (React Query / TypeScript)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-react-query-3

Creates a new QueryClient instance from react-query. Dependency: react-query package. Input: optional configuration object; Output: QueryClient instance. Limitation: QueryCache and MutationCache are created automatically unless provided explicitly.

```tsx
import { QueryClient } from 'react-query'

const queryClient = new QueryClient()
```

--------------------------------

### Render Single Post Component with Background Update Indicator

Source: https://tanstack.com/query/v5/docs/framework/react/examples/basic-graphql-request

React component that displays a single post's full content retrieved from usePost hook. Manages loading, error, and fetching states with visual feedback. Includes back navigation to return to posts list.

```typescript
function Post({
  postId,
  setPostId,
}: {
  postId: number
  setPostId: React.Dispatch<React.SetStateAction<number>>
}) {
  const { status, data, error, isFetching } = usePost(postId)

  return (
    <div>
      <div>
        <a onClick={() => setPostId(-1)} href="#">
          Back
        </a>
      </div>
      {!postId || status === 'pending' ? (
        'Loading...'
      ) : status === 'error' ? (
        <span>Error: {error.message}</span>
      ) : (
        <>
          <h1>{data.title}</h1>
          <div>
            <p>{data.body}</p>
          </div>
          <div>{isFetching ? 'Background Updating...' : ' '}</div>
        </>
      )}
    </div>
  )
}
```

--------------------------------

### React DOM Root Rendering with TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/react/examples/rick-morty

Initialize React application by creating a root element and rendering the main App component. This is the entry point for a TanStack Query application, typically used with a QueryClientProvider wrapper in the App component. The code uses React 18+ createRoot API with TypeScript type assertion for the root DOM element.

```typescript
import ReactDOM from 'react-dom/client'
import App from './App'

const rootElement = document.getElementById('root') as HTMLElement
ReactDOM.createRoot(rootElement).render(<App />)
```

--------------------------------

### Integrating Solid Query `useQuery` with SolidJS Suspense and ErrorBoundary

Source: https://tanstack.com/query/v5/docs/framework/solid/reference/useQuery

This example demonstrates how to leverage SolidJS `Suspense` and `ErrorBoundary` components to manage loading and error states for `useQuery`. By setting `throwOnError: true` in the query options, `useQuery` will throw errors that can be caught by an `ErrorBoundary`, and pending states will activate `Suspense` fallbacks. This provides a declarative and component-based approach to UI state management during data fetching.

```tsx
import { useQuery } from '@tanstack/solid-query'

function App() {
  const todos = useQuery(() => ({
    queryKey: 'todos',
    queryFn: async () => {
      const response = await fetch('/api/todos')
      if (!response.ok) {
        throw new Error('Failed to fetch todos')
      }
      return response.json()
    },
    throwOnError: true,
  }))

  return (
    <ErrorBoundary fallback={<div>Error: {todos.error.message}</div>}>
      <Suspense fallback={<div>Loading...</div>}>
        <div>
          <div>Todos:</div>
          <ul>
            <For each={todos.data}>{(todo) => <li>{todo.title}</li>}</For>
          </ul>
        </div>
      </Suspense>
    </ErrorBoundary>
  )
}
```

--------------------------------

### Implement `useInfiniteQuery` Hook for Infinite Data Fetching in TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/solid/reference/useInfiniteQuery

This code snippet demonstrates the basic structure and essential options for using the `useInfiniteQuery` hook. It shows how to destructure various return values and configure key parameters like `queryKey`, `queryFn` for fetching pages, `initialPageParam` for the starting page, and `getNextPageParam`/`getPreviousPageParam` for defining pagination logic.

```tsx
const {
  fetchNextPage,
  fetchPreviousPage,
  hasNextPage,
  hasPreviousPage,
  isFetchingNextPage,
  isFetchingPreviousPage,
  promise,
  ...result
} = useInfiniteQuery(() => {
  queryKey,
  queryFn: ({ pageParam }) => fetchPage(pageParam),
  initialPageParam: 1,
  ...options,
  getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) =>
    lastPage.nextCursor,
  getPreviousPageParam: (firstPage, allPages, firstPageParam, allPageParams) =>
    firstPage.prevCursor,
})
```

--------------------------------

### App Component with QueryClientProvider

Source: https://tanstack.com/query/v5/docs/framework/react/examples/default-query-function

Root React component that wraps the application with QueryClientProvider, enabling TanStack Query functionality throughout the app. Manages post selection state and renders either Posts list or Post detail view.

```typescript
function App() {
  const [postId, setPostId] = React.useState(-1)

  return (
    <QueryClientProvider client={queryClient}>
      <p>
        As you visit the posts below, you will notice them in a loading state
        the first time you load them. However, after you return to this list and
        click on any posts you have already visited again, you will see them
        load instantly and background refresh right before your eyes!{' '}
        <strong>
          (You may need to throttle your network speed to simulate longer
          loading sequences)
        </strong>
      </p>
      {postId > -1 ? (
        <Post postId={postId} setPostId={setPostId} />
      ) : (
        <Posts setPostId={setPostId} />
      )}
      <ReactQueryDevtools initialIsOpen />
    </QueryClientProvider>
  )
}
```

--------------------------------

### Fetch Posts List with useQuery Hook

Source: https://tanstack.com/query/v5/docs/framework/react/examples/basic-graphql-request

Custom hook that fetches a list of posts using TanStack Query's useQuery. Executes a GraphQL query to retrieve post IDs and titles. Returns query status, data, error, and fetching state for use in components.

```typescript
function usePosts() {
  return useQuery({
    queryKey: ['posts'],
    queryFn: async () => {
      const {
        posts: { data },
      } = await request<{ posts: { data: Array<Post> } }>(endpoint, gql`
        query {
          posts {
            data {
              id
              title
            }
          }
        }
      `)
      return data
    },
  })
}
```

--------------------------------

### Configure TanStack Query Persister with QueryClient in TypeScript

Source: https://tanstack.com/query/v5/docs/framework/react/plugins/createPersister

This example demonstrates how to initialize `experimental_createQueryPersister` with `AsyncStorage` and integrate it into a `QueryClient`'s default options. It sets up automatic query persistence for all queries, specifying a `maxAge` for persisted data and a `gcTime` for in-memory garbage collection.

```tsx
import AsyncStorage from '@react-native-async-storage/async-storage'
import { QueryClient } from '@tanstack/react-query'
import { experimental_createQueryPersister } from '@tanstack/query-persist-client-core'

const persister = experimental_createQueryPersister({
  storage: AsyncStorage,
  maxAge: 1000 * 60 * 60 * 12, // 12 hours
})

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: 1000 * 30, // 30 seconds
      persister: persister.persisterFn,
    },
  },
})
```

--------------------------------

### GET /injectIsMutating

Source: https://tanstack.com/query/v5/docs/framework/angular/reference/functions/injectismutating

Injects an Angular signal that tracks the number of mutations currently being fetched across the application. This is useful for implementing global loading indicators.

```APIDOC
## GET /injectIsMutating

### Description
Injects a signal that tracks the number of mutations currently fetching. This function provides a mechanism to observe the count of active mutations across your application, making it suitable for global loading indicators.

### Method
GET

### Endpoint
/injectIsMutating

### Parameters
#### Path Parameters
(None)

#### Query Parameters
(None)

#### Request Body
- **filters?** (`MutationFilters<unknown, Error, unknown, unknown>`) - Optional - The filters to apply to the query.
- **options?** (`InjectIsMutatingOptions`) - Optional - Additional configuration

### Request Example
{}

### Response
#### Success Response (200)
- **Return Value** (`Signal<number>`) - A signal that emits the number of currently fetching mutations.

#### Response Example
{
  "currentMutations": 1
}
```

--------------------------------

### queryClient.ensureQueryData

Source: https://tanstack.com/query/v5/docs/reference/QueryClient

Asynchronously gets cached data. If the data is not found or is stale (and `revalidateIfStale` is true), it will fetch the query and return its results.

```APIDOC
## SDK Method: queryClient.ensureQueryData

### Description
`ensureQueryData` is an asynchronous function that can be used to get an existing query's cached data. If the query does not exist, `queryClient.fetchQuery` will be called and its results returned.

### Method
SDK Method

### Endpoint
`await queryClient.ensureQueryData(options: QueryOptions)`

### Parameters
#### Request Body (Options)
- **queryKey** (QueryKey) - Required - The unique key for the query.
- **queryFn** (Function) - Required - The asynchronous function that fetches the data if not present.
- **revalidateIfStale** (boolean) - Optional - Defaults to `false`. If `true`, stale data will be refetched in the background, but cached data will be returned immediately.

### Request Example
```json
{
  "queryKey": ["products", 5],
  "queryFn": "() => fetch('/api/products/5').then(res => res.json())",
  "revalidateIfStale": true
}
```

### Response
#### Success Response (Promise<TData>)
- **Promise<TData>** - A promise that resolves with the query data, either from cache or a fresh fetch.

#### Response Example
```json
{
  "productId": 5,
  "name": "Example Product",
  "price": 29.99
}
```
```

--------------------------------

### SolidJS Component to Display Single Post Details

Source: https://tanstack.com/query/v5/docs/framework/solid/examples/basic

The `Post` SolidJS component displays the full title and body of a single post, utilizing the `createPost` hook to fetch its data. It handles loading and error states with a `Switch` statement. A 'Back' link allows users to return to the post list by resetting the `postId` state, enhancing navigation within the application.

```tsx
function Post(props: { postId: number; setPostId: Setter<number> }) {
  const state = createPost(props.postId)

  return (
    <div>
      <div>
        <a onClick={() => props.setPostId(-1)} href="#">
          Back
        </a>
      </div>
      <Switch>
        <Match when={!props.postId || state.status === 'pending'}>
          Loading...
        </Match>
        <Match when={state.status === 'error'}>
          <span>Error: {(state.error as Error).message}</span>
        </Match>
        <Match when={state.data !== undefined}>
          <>
            <h1>{state.data?.title}</h1>
            <div>
              <p>{state.data?.body}</p>
            </div>
            <div>{state.isFetching ? 'Background Updating...' : ' '}</div>
          </>
        </Match>
      </Switch>
    </div>
  )
}
```

--------------------------------

### Simplify useQuery Object Syntax in TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-react-query-3

The configuration for `useQuery` has been streamlined. Options previously nested under a `config` property are now directly passed as top-level properties within the `useQuery` object, simplifying the API for query options.

```tsx
// Old:
useQuery({
  queryKey: 'posts',
  queryFn: fetchPosts,
  config: { staleTime: Infinity },
})

// New:
useQuery({
  queryKey: 'posts',
  queryFn: fetchPosts,
  staleTime: Infinity,
})
```

--------------------------------

### useQuery Return Object - Fetch and Loading Properties

Source: https://tanstack.com/query/v5/docs/framework/react/reference/useQuery

Detailed documentation of fetch status properties, loading indicators, and utility booleans that help track query execution and data fetching states.

```APIDOC
## useQuery Fetch and Loading Properties

### Description
Properties that track the query fetching state, loading progress, and related utility flags.

### Fetch Status Properties

#### fetchStatus: FetchStatus
- **Type**: `'fetching' | 'paused' | 'idle'`
- **Values**:
  - `fetching`: queryFn is executing, includes initial pending and background refetches
  - `paused`: Query wanted to fetch but has been paused
  - `idle`: Query is not fetching
- **Description**: Current fetch status of the query. See Network Mode guide for more information

#### isFetching: boolean
- **Type**: `boolean`
- **Description**: Derived boolean from fetchStatus variable. True when fetchStatus is 'fetching'

#### isPaused: boolean
- **Type**: `boolean`
- **Description**: Derived boolean from fetchStatus variable. True when fetchStatus is 'paused'

#### isFetched: boolean
- **Type**: `boolean`
- **Description**: True if the query has been fetched at least once

#### isFetchedAfterMount: boolean
- **Type**: `boolean`
- **Description**: True if the query has been fetched after the component mounted. Can be used to not show previously cached data

### Loading State Properties

#### isLoading: boolean
- **Type**: `boolean`
- **Description**: True whenever the first fetch for a query is in-flight. Same as `isFetching && isPending`

#### isInitialLoading: boolean
- **Type**: `boolean`
- **Deprecated**: Yes - will be removed in the next major version
- **Description**: Alias for isLoading

#### isRefetching: boolean
- **Type**: `boolean`
- **Description**: True whenever a background refetch is in-flight. Does not include initial pending. Same as `isFetching && !isPending`

### Query Control Properties

#### isEnabled: boolean
- **Type**: `boolean`
- **Description**: True if this query observer is enabled, false otherwise

#### failureCount: number
- **Type**: `number`
- **Description**: The failure count for the query. Incremented every time query fails. Reset to 0 when query succeeds
```

--------------------------------

### React DOM Root Mounting in TypeScript

Source: https://tanstack.com/query/v5/docs/framework/react/examples/chat

Initializes and renders the React application by mounting the App component to the DOM root element. Uses React 18's createRoot API and includes TypeScript type assertion for the root HTML element. This is the entry point for the React application initialization.

```typescript
const rootElement = document.getElementById('root') as HTMLElement
ReactDOM.createRoot(rootElement).render(<App />)
```

--------------------------------

### Fetch All Posts with TanStack Query Hook in React

Source: https://tanstack.com/query/v5/docs/framework/react/examples/basic

A custom React hook `usePosts` that leverages TanStack Query's `useQuery` to fetch a list of all posts from a JSONPlaceholder API. It defines the `queryKey` as `['posts']` and uses an `async` function for `queryFn` to retrieve and parse the data, making it available to components.

```typescript
function usePosts() {
  return useQuery({
    queryKey: ['posts'],
    queryFn: async (): Promise<Array<Post>> => {
      const response = await fetch('https://jsonplaceholder.typicode.com/posts')
      return await response.json()
    },
  })
}
```

--------------------------------

### Retrieve Mutation Data by MutationKey using useMutationState

Source: https://tanstack.com/query/v5/docs/framework/react/reference/useMutationState

This example shows how to fetch data for mutations associated with a specific `mutationKey`. It uses `useMutationState` with filters to match the provided `mutationKey` and selects the mutation's data.

```tsx
import { useMutation, useMutationState } from '@tanstack/react-query'

const mutationKey = ['posts']

// Some mutation that we want to get the state for
const mutation = useMutation({
  mutationKey,
  mutationFn: (newPost) => {
    return axios.post('/posts', newPost)
  },
})

const data = useMutationState({
  // this mutation key needs to match the mutation key of the given mutation (see above)
  filters: { mutationKey },
  select: (mutation) => mutation.state.data,
})
```

--------------------------------

### Initialize TanStack Query Client and React App in Shadow DOM

Source: https://tanstack.com/query/v5/docs/framework/react/examples/shadow-dom

This React TypeScript example demonstrates how to initialize a TanStack Query client and render a React application within a browser's Shadow DOM. It sets up the QueryClientProvider for data fetching and integrates ReactQueryDevtools, ensuring the devtools correctly target the Shadow DOM for inspection.

```tsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import './index.css'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
import { DogList } from './DogList'

const appRoot = document.getElementById('root')

if (appRoot) {
  const queryClient = new QueryClient()
  const shadowRoot = appRoot.attachShadow({ mode: 'open' })
  const root = ReactDOM.createRoot(shadowRoot)

  root.render(
    <React.StrictMode>
      <QueryClientProvider client={queryClient}>
        <div
          style={{
            width: '100vw',
            padding: '30px',
          }}
        >
          <h2>Dog Breeds</h2>
          <DogList />
        </div>
        <ReactQueryDevtools
          initialIsOpen={false}
          buttonPosition="bottom-left"
          shadowDOMTarget={appRoot.shadowRoot!}
        />
      </QueryClientProvider>
    </React.StrictMode>,
  )
}
```

--------------------------------

### GET /useQuery/result

Source: https://tanstack.com/query/v5/docs/framework/vue/reference/useQuery

Represents the structure returned by a useQuery (query observer) in TanStack Query v5. Use this reference to understand all returned properties, derived booleans, timestamps, error/data fields and utility functions such as refetch and promise.

```APIDOC
## GET /useQuery/result

### Description
Represents the result returned by a useQuery (query observer) in TanStack Query v5. This document lists all properties, derived booleans, timestamps, error/data fields, and utility methods available on the result.

### Method
GET

### Endpoint
/useQuery/result

### Parameters
#### Path Parameters
- **None**

#### Query Parameters
- **None**

#### Request Body
- **meta** (any) - Optional - Additional information stored on the query cache entry; accessible via QueryFunctionContext and the query.
- **queryClient** (QueryClient) - Optional - Custom QueryClient to use; otherwise the one from the nearest context will be used.
- **refetchOptions** (object) - Optional - Options passed when calling refetch: { "throwOnError": boolean, "cancelRefetch": boolean }

### Request Example
{
  "meta": {"userId": 123},
  "queryClient": "QueryClientInstance",
  "refetchOptions": {"throwOnError": false, "cancelRefetch": true}
}

### Response
#### Success Response (200)
- **status** (QueryStatus) - Will be "pending", "error", or "success" describing overall query status.
- **isPending** (boolean) - true when status is "pending".
- **isSuccess** (boolean) - true when status is "success".
- **isError** (boolean) - true when status is "error".
- **isLoadingError** (boolean) - true if the query failed on its first fetch.
- **isRefetchError** (boolean) - true if the query failed while refetching.
- **data** (TData | undefined) - Last successfully resolved data; defaults to undefined.
- **dataUpdatedAt** (number) - Timestamp when status most recently became "success".
- **error** (TError | null) - Error object if an error was thrown; defaults to null.
- **errorUpdatedAt** (number) - Timestamp when status most recently became "error".
- **isStale** (boolean) - true when data is invalidated or older than staleTime.
- **isPlaceholderData** (boolean) - true when placeholder data is being shown.
- **isFetched** (boolean) - true when the query has been fetched at least once.
- **isFetchedAfterMount** (boolean) - true if fetched after component mount (useful to hide stale cached data).
- **fetchStatus** (FetchStatus) - One of "fetching", "paused", "idle".
- **isFetching** (boolean) - Derived from fetchStatus, true when fetching.
- **isPaused** (boolean) - Derived from fetchStatus, true when paused.
- **isRefetching** (boolean) - true for background refetches (isFetching && !isPending).
- **isLoading** (boolean) - true for initial fetch in-flight (isFetching && isPending).
- **isInitialLoading** (boolean) - deprecated alias for isLoading.
- **isEnabled** (boolean) - true if observer is enabled.
- **failureCount** (number) - Number of consecutive failures; resets on success.
- **failureReason** (TError | null) - Last failure reason for retries; resets on success.
- **errorUpdateCount** (number) - Sum of all errors received.
- **refetch** (function) - (options: { throwOnError: boolean, cancelRefetch: boolean }) => Promise<UseQueryResult> - Manually refetch the query. Option "cancelRefetch" defaults to true; when false, no refetch occurs if a request is already running.
- **promise** (Promise<TData>) - Stable promise resolved with query data when experimental_prefetchInRender is enabled on the QueryClient.

#### Response Example
{
  "status": "success",
  "isPending": false,
  "isSuccess": true,
  "isError": false,
  "isLoadingError": false,
  "isRefetchError": false,
  "data": {"id": 1, "name": "Item"},
  "dataUpdatedAt": 1690000000000,
  "error": null,
  "errorUpdatedAt": 0,
  "isStale": false,
  "isPlaceholderData": false,
  "isFetched": true,
  "isFetchedAfterMount": true,
  "fetchStatus": "idle",
  "isFetching": false,
  "isPaused": false,
  "isRefetching": false,
  "isLoading": false,
  "isInitialLoading": false,
  "isEnabled": true,
  "failureCount": 0,
  "failureReason": null,
  "errorUpdateCount": 0,
  "refetch": "async function (options) { ... }",
  "promise": "Promise<TData>"
}

```

--------------------------------

### useMutationState - Access Latest Mutation Data

Source: https://tanstack.com/query/v5/docs/framework/solid/reference/useMutationState

Demonstrates how to access the most recent mutation invocation data using useMutationState. Each invocation of mutate adds a new entry to the cache, and this example shows how to retrieve the latest one.

```APIDOC
## useMutationState - Access Latest Mutation Data

### Description
Access the latest mutation invocation data by retrieving the last item from the useMutationState results. Each mutate invocation creates a new cache entry that persists for the gcTime duration.

### Hook Signature
```typescript
useMutationState({
  filters: { mutationKey: string[] },
  select: (mutation: Mutation) => TResult
}): Array<TResult>
```

### Parameters
- **filters.mutationKey** (string[]) - Required - Array identifying the specific mutation to track
- **select** (function) - Required - Transformation function to extract mutation state data

### Request Example
```tsx
import { useMutation, useMutationState } from '@tanstack/solid-query'

const mutationKey = ['posts']

const mutation = useMutation({
  mutationKey,
  mutationFn: (newPost) => {
    return axios.post('/posts', newPost)
  }
})

const data = useMutationState({
  filters: { mutationKey },
  select: (mutation) => mutation.state.data
})

const latest = data[data.length - 1]
```

### Response
- **Returns** (TResult) - The data from the most recent mutation invocation, accessed via the last array index
```

--------------------------------

### Create new Svelte project with create-svelte

Source: https://tanstack.com/query/v5/docs/framework/svelte/examples/basic

Initialize a new Svelte project using npm create-svelte command. This command generates a new Svelte project structure with all necessary dependencies and configuration files for development.

```bash
npm create svelte@latest
```

```bash
npm create svelte@latest my-app
```

--------------------------------

### Implement useInfiniteQuery with Max Pages and Bidirectional Pagination

Source: https://tanstack.com/query/v5/docs/framework/react/examples/infinite-query-with-max-pages

Configures infinite query hook with cursor-based pagination, supporting both forward and backward navigation with a maximum of 3 pages. Includes query key, fetch function, page parameters, and pagination state management for loading indicators.

```typescript
const {
  status,
  data,
  error,
  isFetching,
  isFetchingNextPage,
  isFetchingPreviousPage,
  fetchNextPage,
  fetchPreviousPage,
  hasNextPage,
  hasPreviousPage,
} = useInfiniteQuery({
  queryKey: ['projects'],
  queryFn: async ({ pageParam }) => {
    const response = await fetch(`/api/projects?cursor=${pageParam}`)
    return await response.json()
  },
  initialPageParam: 0,
  getPreviousPageParam: (firstPage) => firstPage.previousId ?? undefined,
  getNextPageParam: (lastPage) => lastPage.nextId ?? undefined,
  maxPages: 3,
})
```

--------------------------------

### useInfiniteQuery: Reversed Data Fetching Order (React)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-react-query-3

Demonstrates how to configure `useInfiniteQuery` to fetch data in reverse order, effectively displaying the latest data first. This involves using the `select` option to reverse both the `pages` and `pageParams` arrays.

```tsx
const { data, fetchNextPage, hasNextPage, isFetchingNextPage } = 
  useInfiniteQuery(
    'projects',
    ({ pageParam = 0 }) => fetchProjects(pageParam),
    {
      select: (data) => ({
        pages: [...data.pages].reverse(),
        pageParams: [...data.pageParams].reverse(),
      }),
      getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
    },
  )
```

--------------------------------

### Get Query State with getQueryState

Source: https://tanstack.com/query/v5/docs/reference/QueryClient

Synchronously retrieve an existing query's state including metadata like dataUpdatedAt. Returns undefined if query doesn't exist.

```tsx
const state = queryClient.getQueryState(queryKey)
console.log(state.dataUpdatedAt)
```

--------------------------------

### Mock patchTodo API Function for Updating Todos

Source: https://tanstack.com/query/v5/docs/framework/react/examples/playground

Simulates updating an existing todo by matching ID and replacing with new values. Reconstructs list immutably and returns the updated Todo object with configurable error rate and delay simulation.

```typescript
function patchTodo(todo?: Todo): Promise<Todo> {
  console.info('patchTodo', todo)
  return new Promise((resolve, reject) => {
    setTimeout(
      () => {
        if (Math.random() < errorRate) {
          return reject(new Error(JSON.stringify({ patchTodo: todo }, null, 2)))
        }
        list = list.map((d) => {
          if (d.id === todo.id) {
            return todo
          }
          return d
        })
        resolve(todo)
      },
      queryTimeMin + Math.random() * (queryTimeMax - queryTimeMin),
    )
  })
}
```

--------------------------------

### QueriesObserver Constructor

Source: https://tanstack.com/query/v5/docs/reference/QueriesObserver

Creates a new QueriesObserver instance that allows you to observe multiple queries. The observer accepts a QueryClient instance and an array of query configurations, then provides a subscribe method to listen for updates.

```APIDOC
## QueriesObserver Constructor

### Description
Initializes a new QueriesObserver instance to observe multiple queries and subscribe to their changes.

### Syntax
```tsx
const observer = new QueriesObserver(queryClient, queries)
```

### Parameters
- **queryClient** (QueryClient) - Required - The QueryClient instance managing queries
- **queries** (Query[]) - Required - Array of query configuration objects with queryKey and queryFn properties

### Returns
- **observer** (QueriesObserver) - An observer instance with subscribe method

### Request Example
```tsx
const observer = new QueriesObserver(queryClient, [
  { queryKey: ['post', 1], queryFn: fetchPost },
  { queryKey: ['post', 2], queryFn: fetchPost },
])
```

### Response
#### Observer Instance
- **subscribe** (function) - Method to subscribe to observer updates, returns unsubscribe function

### Response Example
```tsx
const unsubscribe = observer.subscribe((result) => {
  console.log(result)
  unsubscribe()
})
```

### Notes
- The observer configuration options are identical to those of the `useQueries` hook
- The subscribe method returns an unsubscribe function to stop listening for updates
- This API is useful for observing queries outside of React components
```

--------------------------------

### Define Vue Component Props for userId

Source: https://tanstack.com/query/v5/docs/framework/vue/reactivity

This snippet defines the `userId` prop for a Vue component using the `<script setup lang="ts">` syntax, indicating that the component expects a string-type `userId` prop.

```vue
<script setup lang="ts">
const props = defineProps<{
  userId: string
}>()
</script>
```

--------------------------------

### Linear Backoff Retry Strategy

Source: https://tanstack.com/query/v5/docs/framework/solid/reference/useMutation

Example retry delay function implementing linear backoff for mutation retry attempts. This strategy increases the delay linearly between retries, providing a simpler alternative to exponential backoff.

```typescript
retryDelay: (attempt) => attempt * 1000
```

--------------------------------

### Invalidate TanStack Query Cache

Source: https://tanstack.com/query/v5/docs/framework/react/guides/query-invalidation

Demonstrates basic usage of `queryClient.invalidateQueries()` to either invalidate all queries in the cache or specifically invalidate queries whose keys start with a given prefix, such as `['todos']`.

```tsx
// Invalidate every query in the cache
queryClient.invalidateQueries()
// Invalidate every query with a key that starts with `todos`
queryClient.invalidateQueries({ queryKey: ['todos'] })
```

--------------------------------

### Reverse Infinite Query Page Order with TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/solid/guides/infinite-queries

This example shows how to display pages in reversed order using the `select` option in `useInfiniteQuery`. It manipulates the `pages` and `pageParams` arrays by reversing them before the data is returned, effectively changing the display order.

```tsx
useInfiniteQuery(() => {
  queryKey: ['projects'],
  queryFn: fetchProjects,
  select: (data) => ({
    pages: [...data.pages].reverse(),
    pageParams: [...data.pageParams].reverse(),
  }),
})
```

--------------------------------

### Handling Destructuring with Solid Query Primitives

Source: https://tanstack.com/query/v5/docs/framework/solid/quick-start

Unlike React Query, Solid Query primitives (e.g., `useQuery`) return a reactive store and do not support destructuring directly outside of a reactive context. Properties of the returned store must be accessed via dot notation within JSX or other reactive scopes to maintain reactivity.

```tsx
// ‚ùå react version -- supports destructing outside reactive context
// const { isPending, error, data } = useQuery({
//   queryKey: ['repoData'],
//   queryFn: () =>
//     fetch('https://api.github.com/repos/tannerlinsley/react-query').then(
//       (res) => res.json()
//     ),
// })

```

```tsx
import {
  QueryClient,
  QueryClientProvider,
  useQuery,
} from '@tanstack/solid-query'
import { Match, Switch } from 'solid-js'

const queryClient = new QueryClient()

export default function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Example />
    </QueryClientProvider>
  )
}

function Example() {
  // ‚úÖ solid version -- does not support destructuring outside reactive context
  const query = useQuery(() => ({
    queryKey: ['repoData'],
    queryFn: () =>
      fetch('https://api.github.com/repos/tannerlinsley/react-query').then(
        (res) => res.json(),
      ),
  }))

  // ‚úÖ access query properties in JSX reactive context
  return (
    <Switch>
      <Match when={query.isPending}>Loading...</Match>
      <Match when={query.isError}>Error: {query.error.message}</Match>
      <Match when={query.isSuccess}>
        <div>
          <h1>{query.data.name}</h1>
          <p>{query.data.description}</p>
          <strong>üëÄ {query.data.subscribers_count}</strong>{' '}
          <strong>‚ú® {query.data.stargazers_count}</strong>{' '}
          <strong>üç¥ {query.data.forks_count}</strong>
        </div>
      </Match>
    </Switch>
  )
}
```

--------------------------------

### Root Component with QueryClient Configuration

Source: https://tanstack.com/query/v5/docs/framework/react/examples/playground

React component managing TanStack Query v5 settings including staleTime, gcTime (garbage collection time), error rate, and fetch delays. Uses useState for configuration state and useEffect to update global variables and QueryClient default options dynamically.

```typescript
function Root() {
  const [staleTime, setStaleTime] = React.useState(1000)
  const [gcTime, setGcTime] = React.useState(3000)
  const [localErrorRate, setErrorRate] = React.useState(errorRate)
  const [localFetchTimeMin, setLocalFetchTimeMin] = React.useState(queryTimeMin)
  const [localFetchTimeMax, setLocalFetchTimeMax] = React.useState(queryTimeMax)

  React.useEffect(() => {
    errorRate = localErrorRate
    queryTimeMin = localFetchTimeMin
    queryTimeMax = localFetchTimeMax
  }, [localErrorRate, localFetchTimeMax, localFetchTimeMin])

  React.useEffect(() => {
    queryClient.setDefaultOptions({
      queries: {
        staleTime,
        gcTime,
      },
    })
  }, [gcTime, staleTime])

  return (
    <QueryClientProvider client={queryClient}>
      <p>
        The "staleTime" and "gcTime" durations have been altered in this example
        to show how query stale-ness and query caching work on a granular level
      </p>
      <div>
        Stale Time:{' '}
        <input
          type="number"
          min="0"
          step="1000"
          value={staleTime}
          onChange={(e) => setStaleTime(parseFloat(e.target.value))}
          style={{ width: '100px' }}
        />
      </div>
      <div>
        Garbage collection Time:{' '}
        <input
          type="number"
          min="0"
          step="1000"
          value={gcTime}
          onChange={(e) => setGcTime(parseFloat(e.target.value))}
          style={{ width: '100px' }}
        />
      </div>
    </QueryClientProvider>
  )
}
```

--------------------------------

### Get Specific Mutation Defaults with `queryClient.getMutationDefaults` (TypeScript/JavaScript)

Source: https://tanstack.com/query/v5/docs/reference/QueryClient

Retrieves the default options specifically configured for mutations that match a given mutation key. This allows inspection of pre-configured options for particular mutation operations.

```typescript
const defaultOptions = queryClient.getMutationDefaults(['addPost'])
```

--------------------------------

### Query Function Parameters: QueryFunctionContext (React)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-react-query-3

Shows an alternative to inline functions for passing parameters to query functions using `QueryFunctionContext`. This method accesses query key parameters via `context.queryKey`.

```tsx
useQuery(['post', id], (context) => fetchPost(context.queryKey[1]))
```

--------------------------------

### Implement React TanStack Query Pagination with Prefetching

Source: https://tanstack.com/query/v5/docs/framework/react/examples/pagination

This React component demonstrates client-side pagination using TanStack Query. It fetches project data page by page, utilizing `keepPreviousData` to display the current data while new data loads. The component also prefetches the next page's data to improve performance and user experience, and includes basic navigation controls and loading/error state handling.

```tsx
import React from 'react'
import {
  QueryClient,
  QueryClientProvider,
  keepPreviousData,
  useQuery,
  useQueryClient,
} from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'

const queryClient = new QueryClient()

export default function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Example />
    </QueryClientProvider>
  )
}

const fetchProjects = async (
  page = 0,
): Promise<{
  projects: Array<{ name: string; id: number }>
  hasMore: boolean
}> => {
  const response = await fetch(`/api/projects?page=${page}`)
  return await response.json()
}

function Example() {
  const queryClient = useQueryClient()
  const [page, setPage] = React.useState(0)

  const { status, data, error, isFetching, isPlaceholderData } = useQuery({
    queryKey: ['projects', page],
    queryFn: () => fetchProjects(page),
    placeholderData: keepPreviousData,
    staleTime: 5000,
  })

  // Prefetch the next page!
  React.useEffect(() => {
    if (!isPlaceholderData && data?.hasMore) {
      queryClient.prefetchQuery({
        queryKey: ['projects', page + 1],
        queryFn: () => fetchProjects(page + 1),
      })
    }
  }, [data, isPlaceholderData, page, queryClient])

  return (
    <div>
      <p>
        In this example, each page of data remains visible as the next page is
        fetched. The buttons and capability to proceed to the next page are also
        supressed until the next page cursor is known. Each page is cached as a
        normal query too, so when going to previous pages, you'll see them
        instantaneously while they are also refetched invisibly in the
        background.
      </p>
      {status === 'pending' ? (
        <div>Loading...</div>
      ) : status === 'error' ? (
        <div>Error: {error.message}</div>
      ) : (
        // `data` will either resolve to the latest page's data
        // or if fetching a new page, the last successful page's data
        <div>
          {data.projects.map((project) => (
            <p key={project.id}>{project.name}</p>
          ))}
        </div>
      )}
      <div>Current Page: {page + 1}</div>
      <button
        onClick={() => setPage((old) => Math.max(old - 1, 0))}
        disabled={page === 0}
      >
        Previous Page
      </button>{' '}
      <button
        onClick={() => {
          setPage((old) => (data?.hasMore ? old + 1 : old))
        }}
        disabled={isPlaceholderData || !data?.hasMore}
      >
        Next Page
      </button>
      {
        // Since the last page's data potentially sticks around between page requests,
        // we can use `isFetching` to show a background loading
        // indicator since our `status === 'pending'` state won't be triggered
        isFetching ? <span> Loading...</span> : null
      }{' '}
      <ReactQueryDevtools initialIsOpen />
    </div>
  )
}
```

--------------------------------

### Using HydrationBoundary in TanStack React Query

Source: https://tanstack.com/query/v5/docs/framework/react/reference/hydration

This example demonstrates how to wrap your application with `HydrationBoundary` from `@tanstack/react-query`. It takes a `dehydratedState` prop, which contains the state to be rehydrated, allowing server-side rendered data to be available on the client.

```tsx
import { HydrationBoundary } from '@tanstack/react-query'

function App() {
  return <HydrationBoundary state={dehydratedState}>...</HydrationBoundary>
}
```

--------------------------------

### Manage Multiple Query Views with Dynamic Filters

Source: https://tanstack.com/query/v5/docs/framework/react/examples/playground

Demonstrates managing multiple query instances with different filters using React state. The App component allows adding/removing filtered todo lists and invalidating all queries globally. Shows how useQueryClient enables advanced cache management operations.

```typescript
function App() {
  const queryClient = useQueryClient()
  const [editingIndex, setEditingIndex] = React.useState<number | null>(null)
  const [views, setViews] = React.useState(['', 'fruit', 'grape'])

  return (
    <div className="App">
      <div>
        <button onClick={() => queryClient.invalidateQueries()}>
          Force Refetch All
        </button>
      </div>
      {views.map((view, index) => (
        <div key={index}>
          <Todos
            initialFilter={view}
            setEditingIndex={setEditingIndex}
            onRemove={() => {
              setViews((old) => [...old, ''])
            }}
          />
        </div>
      ))}
      <button
        onClick={() => {
          setViews((old) => [...old, ''])
        }}
      >
        Add Filter List
      </button>
    </div>
  )
}
```

--------------------------------

### Main React Application Structure with TanStack Query Devtools

Source: https://tanstack.com/query/v5/docs/framework/react/examples/playground

This code defines the main `App` component, which orchestrates the todo application. It initializes global state for views, provides a button to invalidate all queries, and renders `Todos` components for different filters, along with `EditTodo` and `AddTodo` components. It depends on `useQueryClient` for query invalidation and manages the overall UI flow.

```typescript
function App() {
  const queryClient = useQueryClient()
  const [editingIndex, setEditingIndex] = React.useState<number | null>(null)
  const [views, setViews] = React.useState(['', 'fruit', 'grape'])
  // const [views, setViews] = React.useState([""]);

  return (
    <div className="App">
      <div>
        <button onClick={() => queryClient.invalidateQueries()}>
          Force Refetch All
        </button>
      </div>
      <br />
      <hr />
      {views.map((view, index) => (
        <div key={index}>
          <Todos
            initialFilter={view}
            setEditingIndex={setEditingIndex}
            onRemove={() => {
              setViews((old) => [...old, ''])
            }}
          />
          <br />
        </div>
      ))}
      <button
        onClick={() => {
          setViews((old) => [...old, ''])
        }}
      >
        Add Filter List
      </button>
      <hr />
      {editingIndex !== null ? (
        <>
          <EditTodo
            editingIndex={editingIndex}
            setEditingIndex={setEditingIndex}
          />
          <hr />
        </>
      ) : null}
      <AddTodo />
    </div>
  )
}
```

--------------------------------

### Fetch Data with useQuery Hook

Source: https://tanstack.com/query/v5/docs/framework/react/examples/playground

Uses the useQuery hook to fetch todos with a dynamic filter parameter. The query key includes the filter state to create separate cache entries for different filters. Returns status, data, loading state, error information, and refetch function for controlling data fetching.

```typescript
function Todos({
  initialFilter = '',
  setEditingIndex,
}: {
  initialFilter: string
  setEditingIndex: React.Dispatch<React.SetStateAction<number | null>>
}) {
  const [filter, setFilter] = React.useState(initialFilter)

  const { status, data, isFetching, error, failureCount, refetch } = useQuery({
    queryKey: ['todos', { filter }],
    queryFn: fetchTodos,
  })

  return (
    <div>
      {/* Component JSX */}
    </div>
  )
}
```

--------------------------------

### Consume Flexible Vue-Query Composable with Static and Reactive Values

Source: https://tanstack.com/query/v5/docs/framework/vue/reactivity

This TypeScript example demonstrates the versatile consumption of the `MaybeRef`-enabled `useUserProjects` composable. It shows how the same composable can be used with a static string for a one-time fetch or with a reactive `ref` to enable automatic re-fetching on changes.

```typescript
// Fetches the user 1's projects, userId is not expected to change.
const { data: projects } = useUserProjects('1')

// Fetches the user 1's projects, queries will react to changes on userId.
const userId = ref('1')

// Make some changes to userId...

// Query re-fetches based on any changes to userId.
const { data: projects } = useUserProjects(userId)
```

--------------------------------

### infiniteQueryOptions Function Signature

Source: https://tanstack.com/query/v5/docs/framework/svelte/reference/functions/infinitequeryoptions

Defines the infiniteQueryOptions function with five generic type parameters for infinite query configuration. Takes CreateInfiniteQueryOptions as input and returns the same type, enabling type-safe infinite query setup with pagination support. Used in TanStack Query's Svelte Query implementation.

```typescript
function infiniteQueryOptions<
  TQueryFnData,
  TError,
  TData,
  TQueryKey,
  TPageParam,
>(
  options,
): CreateInfiniteQueryOptions<
  TQueryFnData,
  TError,
  TData,
  TQueryFnData,
  TQueryKey,
  TPageParam
>
```

--------------------------------

### useMutation Hook Usage with Options and Callbacks

Source: https://tanstack.com/query/v5/docs/framework/solid/reference/useMutation

Complete example demonstrating the useMutation hook initialization with configuration options and mutation execution with callbacks. Returns mutation state properties (data, error, status) and methods (mutate, mutateAsync, reset). The hook accepts a configuration object with mutation function and lifecycle callbacks, plus an optional QueryClient instance.

```typescript
const {
  data,
  error,
  isError,
  isIdle,
  isPending,
  isPaused,
  isSuccess,
  failureCount,
  failureReason,
  mutate,
  mutateAsync,
  reset,
  status,
  submittedAt,
  variables,
} = useMutation(() => 
  {
    mutationFn,
    gcTime,
    meta,
    mutationKey,
    networkMode,
    onError,
    onMutate,
    onSettled,
    onSuccess,
    retry,
    retryDelay,
    scope,
    throwOnError,
  },
  queryClient,
)

mutate(variables, {
  onError,
  onSettled,
  onSuccess,
})
```

--------------------------------

### Configure VueQueryPlugin with QueryClientConfig in TypeScript

Source: https://tanstack.com/query/v5/docs/framework/vue/guides/custom-client

This example demonstrates how to configure `VueQueryPlugin` by providing a `QueryClientConfig` object. The plugin will internally create a new `QueryClient` instance using the specified configuration, allowing for default options like `staleTime` to be set across all queries.

```tsx
const vueQueryPluginOptions: VueQueryPluginOptions = {
  queryClientConfig: {
    defaultOptions: { queries: { staleTime: 3600 } },
  },
}
app.use(VueQueryPlugin, vueQueryPluginOptions)
```

--------------------------------

### Infinite Query Page Params: QueryFunctionContext (React)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-react-query-3

Illustrates the updated way to handle page parameters in `useInfiniteQuery`. Page parameters are now accessed via `QueryFunctionContext.pageParam`, differing from previous versions where they were appended to the query key.

```tsx
// Old
useInfiniteQuery(['posts'], (_key, pageParam = 0) => fetchPosts(pageParam))

// New
useInfiniteQuery(['posts'], ({ pageParam = 0 }) => fetchPosts(pageParam))
```

--------------------------------

### Flattened Waterfall with Query Hoisting

Source: https://tanstack.com/query/v5/docs/framework/solid/guides/request-waterfalls

Optimizes the previous example by hoisting both queries to the parent Article component, allowing them to fetch in parallel. The comments data is passed down as a prop to the Comments component. For suspense implementations, use useQueries instead to combine the queries into a single request.

```typescript
function Article({ id }) {
  const { data: articleData, isPending: articlePending } = useQuery(() => {
    queryKey: ['article', id],
    queryFn: getArticleById,
  })

  const { data: commentsData, isPending: commentsPending } = useQuery(() => {
    queryKey: ['article-comments', id],
    queryFn: getArticleCommentsById,
  })

  if (articlePending) {
    return 'Loading article...'
  }

  return (
    <>
      <ArticleHeader articleData={articleData} />
      <ArticleBody articleData={articleData} />
      {commentsPending ? (
        'Loading comments...'
      ) : (
        <Comments commentsData={commentsData} />
      )}
    </>
  )
}
```

--------------------------------

### Fetch Todos with Abort Signal Handling

Source: https://tanstack.com/query/v5/docs/framework/react/examples/playground

Async function that fetches a filtered list of todos from an API endpoint. Accepts a signal parameter for request cancellation support and a destructured queryKey containing the filter parameter. Logs the filter for debugging and sets up an abort event listener for cleanup.

```TypeScript/React
function fetchTodos({ signal, queryKey: [, { filter }] }): Promise<Todos> {
  console.info('fetchTodos', { filter })

  if (signal) {
    signal.addEventListener('abort', () => {
      // Cleanup logic on request abort
    })
  }
  // API call implementation continues...
}
```

--------------------------------

### useMutation Return Object (React)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-react-query-3

Illustrates the change in `useMutation`'s return type from an array to an object. This provides direct access to mutation state and functions like `mutate`, `status`, and `reset` as properties of the returned object.

```tsx
// Old:
const [mutate, { status, reset }] = useMutation()

// New:
const { mutate, status, reset } = useMutation()
```

--------------------------------

### Retrieve Specific Mutation Data with mutationKey using useMutationState (TanStack Solid-Query)

Source: https://tanstack.com/query/v5/docs/framework/solid/reference/useMutationState

This example illustrates how to use `useMutationState` to fetch the `data` from mutations associated with a specific `mutationKey`. It also shows a `useMutation` hook definition for context, ensuring the `mutationKey` matches for filtering.

```tsx
import { useMutation, useMutationState } from '@tanstack/solid-query'

const mutationKey = ['posts']

// Some mutation that we want to get the state for
const mutation = useMutation(() => {
  mutationKey,
  mutationFn: (newPost) => {
    return axios.post('/posts', newPost)
  },
})

const data = useMutationState(() => {
  // this mutation key needs to match the mutation key of the given mutation (see above)
  filters: { mutationKey },
  select: (mutation) => mutation.state.data,
})
```

--------------------------------

### React Component State Management with Hooks

Source: https://tanstack.com/query/v5/docs/framework/react/examples/auto-refetching

Manages component state for interval timing and input value using React.useState hooks. These state values control the refetch interval dynamically and capture user input for mutations.

```typescript
const queryClient = useQueryClient()
const [intervalMs, setIntervalMs] = React.useState(1000)
const [value, setValue] = React.useState('')
```

--------------------------------

### useQuery Configuration - QueryClient and Meta Parameters

Source: https://tanstack.com/query/v5/docs/framework/react/reference/useQuery

Documentation of additional configuration parameters for useQuery including custom QueryClient and meta information storage on cache entries.

```APIDOC
## useQuery Configuration Parameters

### Description
Additional configuration parameters available when setting up useQuery for custom QueryClient and metadata management.

### queryClient Parameter

#### queryClient?: QueryClient
- **Type**: `QueryClient | undefined`
- **Default**: Uses QueryClient from nearest context
- **Description**: Use this to use a custom QueryClient. Otherwise, the one from the nearest context will be used
- **Usage**: Allows you to override the default context-based QueryClient with a specific instance

### meta Parameter

#### meta?: Record<string, any>
- **Type**: `Record<string, any> | undefined`
- **Description**: If set, stores additional information on the query cache entry that can be used as needed
- **Access**:
  - Accessible wherever the query is available
  - Part of the QueryFunctionContext provided to the queryFn
  - Useful for storing custom metadata like tags, categories, or tracking information

### Configuration Example
```javascript
const queryClient = new QueryClient();

const result = useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodos,
  queryClient: queryClient,
  meta: {
    tag: 'important',
    category: 'user-data',
    customField: 'custom-value'
  }
});
```
```

--------------------------------

### Fetch Todos with Filter and Abort Signal Handling

Source: https://tanstack.com/query/v5/docs/framework/react/examples/playground

Async function that fetches a filtered list of todos with abort signal support and simulated network delay. Returns a Promise that rejects randomly based on errorRate for testing error scenarios. Filters todos by name matching the provided filter parameter.

```TypeScript
function fetchTodos({ signal, queryKey: [, { filter }] }): Promise<Todos> {
  console.info('fetchTodos', { filter })

  if (signal) {
    signal.addEventListener('abort', () => {
      console.info('cancelled', filter)
    })
  }

  return new Promise((resolve, reject) => {
    setTimeout(
      () => {
        if (Math.random() < errorRate) {
          return reject(
            new Error(JSON.stringify({ fetchTodos: { filter } }, null, 2)),
          )
        }
        resolve(list.filter((d) => d.name.includes(filter)))
      },
      queryTimeMin + Math.random() * (queryTimeMax - queryTimeMin),
    )
  })
}
```

--------------------------------

### Fetch data with Solid Query useQuery in a Suspense-enabled component

Source: https://tanstack.com/query/v5/docs/framework/solid/guides/suspense

This example demonstrates using `useQuery` from `@tanstack/solid-query` within a component designed for Solid's `Suspense` API. The `queryFn` defines an asynchronous data fetcher, and accessing `query.data` directly within a `Suspense` boundary automatically pauses rendering until the data is available, making it suitable for fetch-on-render scenarios.

```tsx
import { useQuery } from '@tanstack/solid-query'

const todoFetcher = async () =>
  await fetch('https://jsonplaceholder.cypress.io/todos').then((response) =>
    response.json(),
  )

function SuspendableComponent() {
  const query = useQuery(() => ({
    queryKey: ['todos'],
    queryFn: todoFetcher,
  }))

  // Accessing query.data directly inside a <Suspense> boundary
  // automatically triggers suspension until data is ready
  return <div>Data: {JSON.stringify(query.data)}</div>
}
```

--------------------------------

### Display TanStack Query Data in Svelte Component

Source: https://tanstack.com/query/v5/docs/framework/svelte/examples/simple

This Svelte component (`Simple.svelte`) renders data fetched using TanStack Query. It conditionally displays a loading message, an error message if the query fails, or the repository's full name, description, and various metrics (subscribers, stargazers, forks) upon successful data retrieval.

```svelte
# Simple
{#if query.isPending} Loading... {/if} {#if query.error} An error has occurred: {query.error.message} {/if} {#if query.isSuccess} 
# {query.data.full_name}
{query.data.description}
**üëÄ {query.data.subscribers_count}**{' '} **‚ú® {query.data.stargazers_count}**{' '} **üç¥ {query.data.forks_count}**
{/if} 
```

--------------------------------

### Auto Refetching with useQuery and refetchInterval

Source: https://tanstack.com/query/v5/docs/framework/react/examples/auto-refetching

Fetches data from an API endpoint with automatic refetching at specified intervals using the refetchInterval option. Returns query status, data, error, and isFetching state for UI rendering and loading indicators.

```typescript
const { status, data, error, isFetching } = useQuery({
  queryKey: ['todos'],
  queryFn: async (): Promise<Array<string>> => {
    const response = await fetch('/api/data')
    return await response.json()
  },
  // Refetch the data every second
  refetchInterval: intervalMs,
})
```

--------------------------------

### Build production version of Svelte app

Source: https://tanstack.com/query/v5/docs/framework/svelte/examples/basic

Create an optimized production build of the Svelte application. The build output can be previewed locally before deployment using the preview command.

```bash
npm run build
```

```bash
npm run preview
```

--------------------------------

### Query Function Parameters: Inline Functions (React)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-react-query-3

Demonstrates how to pass parameters to query functions using inline functions in `useQuery`. This is the suggested approach in v5, replacing automatic spreading of query key parts.

```tsx
// Old
useQuery(['post', id], (_key, id) => fetchPost(id))

// New
useQuery(['post', id], () => fetchPost(id))
```

--------------------------------

### Non-Reactive Query Call with Direct Prop Access (Vue/TS)

Source: https://tanstack.com/query/v5/docs/framework/vue/reactivity

This example demonstrates an incorrect way to use `props.userId` directly with `useUserProjects`. This approach will not react to changes in `props.userId` because direct property access on reactive variables can lead to a loss of reactivity.

```ts
// Won't react to changes in props.userId.
const { data: projects } = useUserProjects(props.userId)
```

--------------------------------

### useQuery Return Object - Methods and Utilities

Source: https://tanstack.com/query/v5/docs/framework/react/reference/useQuery

Documentation of the refetch method and promise property that provide manual query control and stable promise resolution for advanced query management.

```APIDOC
## useQuery Methods and Utilities

### Description
Methods and utilities provided by useQuery for manual query control and promise-based data handling.

### refetch Method

#### refetch(options?: { throwOnError: boolean, cancelRefetch: boolean }): Promise<UseQueryResult>
- **Type**: `Function`
- **Returns**: `Promise<UseQueryResult>`
- **Description**: A function to manually refetch the query
- **Parameters**:
  - `throwOnError: boolean` (Optional)
    - Default: `false`
    - If true, errors will be thrown instead of only logged
  - `cancelRefetch: boolean` (Optional)
    - Default: `true`
    - If true (default), a currently running request will be cancelled before a new request is made
    - If false, no refetch will be made if there is already a request running

### promise Property

#### promise: Promise<TData>
- **Type**: `Promise<TData>`
- **Description**: A stable promise that will be resolved with the data of the query
- **Requirements**: Requires the `experimental_prefetchInRender` feature flag to be enabled on the QueryClient

### Request Example
```javascript
const { data, refetch, promise } = useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodos
});

// Manual refetch with error handling
await refetch({ throwOnError: true, cancelRefetch: true });

// Use stable promise
const data = await promise;
```
```

--------------------------------

### Resetting TanStack Query Mutation State

Source: https://tanstack.com/query/v5/docs/framework/react/guides/mutations

This example demonstrates how to clear the `error` or `data` state of a mutation using the `reset` function provided by `useMutation`. This is useful for dismissing error messages or preparing the mutation for another attempt.

```tsx
const CreateTodo = () => {
  const [title, setTitle] = useState('')
  const mutation = useMutation({ mutationFn: createTodo })

  const onCreateTodo = (e) => {
    e.preventDefault()
    mutation.mutate({ title })
  }

  return (
    <form onSubmit={onCreateTodo}>
      {mutation.error && (
        <h5 onClick={() => mutation.reset()}>{mutation.error}</h5>
      )}
      <input
        type="text"
        value={title}
        onChange={(e) => setTitle(e.target.value)}
      />
      <br />
      <button type="submit">Create Todo</button>
    </form>
  )
}
```

--------------------------------

### Fetch and Cache Query Data (TanStack React Query)

Source: https://tanstack.com/query/v5/docs/reference/QueryClient

This example illustrates the basic usage of `queryClient.fetchQuery` to asynchronously retrieve and cache data for a specific `queryKey`. It resolves with the fetched data or throws an error, which is caught and logged, ensuring robust data fetching.

```tsx
try {
  const data = await queryClient.fetchQuery({ queryKey, queryFn })
} catch (error) {
  console.log(error)
}
```

--------------------------------

### Create and subscribe to a QueriesObserver (TSX)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-react-query-3

Observe multiple queries together by instantiating a QueriesObserver with an array of query option objects. Returns a subscribe method to receive batched results for all queries; useful for coordinating or reacting to changes across several queries outside React components.

```tsx
const observer = new QueriesObserver(queryClient, [
  { queryKey: ['post', 1], queryFn: fetchPost },
  { queryKey: ['post', 2], queryFn: fetchPost },
])

const unsubscribe = observer.subscribe((result) => {
  console.log(result)
  unsubscribe()
})
```

--------------------------------

### Visual Indicator for Data Fetching State

Source: https://tanstack.com/query/v5/docs/framework/react/examples/auto-refetching

Renders a dynamic CSS-styled indicator that changes appearance based on the isFetching state. The indicator turns green when data is being fetched and becomes transparent when idle, with smooth transitions.

```typescript
<span
  style={{
    display: 'inline-block',
    marginLeft: '.5rem',
    width: 10,
    height: 10,
    background: isFetching ? 'green' : 'transparent',
    transition: !isFetching ? 'all .3s ease' : 'none',
    borderRadius: '100%',
    transform: 'scale(2)',
  }}
/>
```

--------------------------------

### Integrating GraphQL Request with AbortSignal for Query Cancellation in TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/solid/guides/query-cancellation

This example shows how to integrate `AbortSignal` with `graphql-request` for cancelling GraphQL queries. For `graphql-request` versions 4.0.0 and above, the `signal` can be directly passed to the `client.request` method, enabling automatic cancellation.

```tsx
const client = new GraphQLClient(endpoint)

const query = useQuery(() => {
  queryKey: ['todos'],
  queryFn: ({ signal }) => {
    client.request({ document: query, signal })
  },
})
```

--------------------------------

### Display Posts List with Caching Indicators - Solid.js

Source: https://tanstack.com/query/v5/docs/framework/solid/examples/basic-graphql-request

Renders a list of posts using Solid.js For loop with conditional styling to indicate cached vs uncached data. Uses queryClient.getQueryData() to check if post data exists in cache and applies bold green styling to cached posts. Displays loading and error states using Switch/Match components.

```TypeScript
function Posts(props: { setPostId: Setter<number> }) {
  const state = createPosts()

  return (
    <div>
      <h1>Posts</h1>
      <div>
        <Switch>
          <Match when={state.status === 'pending'}>Loading...</Match>
          <Match when={state.status === 'error'}>
            <span>Error: {(state.error as Error).message}</span>
          </Match>
          <Match when={state.data !== undefined}>
            <>
              <div>
                <For each={state.data}>
                  {(post: any) => (
                    <p>
                      <a
                        onClick={() => props.setPostId(post.id)}
                        href="#"
                        style={
                          queryClient.getQueryData(['post', post.id])
                            ? {
                                'font-weight': 'bold',
                                color: 'green',
                              }
                            : {}
                        }
                      >
                        {post.title}
                      </a>
                    </p>
                  )}
                </For>
              </div>
              <div>{state.isFetching ? 'Background Updating...' : ' '}</div>
            </>
          </Match>
        </Switch>
      </div>
    </div>
  )
}
```

--------------------------------

### Configure Default Query Function in TanStack Query with Solid.js

Source: https://tanstack.com/query/v5/docs/framework/solid/examples/default-query-function

Creates a default query function that automatically handles API requests based on query keys. This function receives the query key and constructs API endpoints dynamically, reducing boilerplate code throughout the application. The query client is configured with this default function and wrapped around the app with QueryClientProvider.

```typescript
const defaultQueryFn: QueryFunction<unknown> = async ({ queryKey }) => {
  const response = await fetch(
    `https://jsonplaceholder.typicode.com${queryKey[0]}`,
    {
      method: 'GET',
    },
  )
  return response.json()
}

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryFn: defaultQueryFn,
    },
  },
})
```

--------------------------------

### Conditionally Render TanStack Query Data and Devtools in React

Source: https://tanstack.com/query/v5/docs/framework/react/examples/prefetching

This snippet shows how to conditionally render UI elements based on the `isPending` state of a TanStack Query. While the query is loading, it displays 'Loading...'. Once data is fetched, it formats and displays the `characterQuery.data` as JSON. It also includes the `ReactQueryDevtools` for debugging.

```javascript
{characterQuery.isPending ? (
            'Loading...'
          ) : (
            <>
              <pre>{JSON.stringify(characterQuery.data, null, 2)}</pre>
            </>
          )}
          <ReactQueryDevtools initialIsOpen />
```

--------------------------------

### Mock fetchTodoById API Function with ID Lookup

Source: https://tanstack.com/query/v5/docs/framework/react/examples/playground

Simulates fetching a single todo by ID with configurable error rate and variable delay. Returns a Promise resolving to a Todo object or rejecting with an error containing the requested ID. Demonstrates typed parameters and error serialization.

```typescript
function fetchTodoById({ id }: { id: number }): Promise<Todo> {
  console.info('fetchTodoById', { id })
  return new Promise((resolve, reject) => {
    setTimeout(
      () => {
        if (Math.random() < errorRate) {
          return reject(
            new Error(JSON.stringify({ fetchTodoById: { id } }, null, 2)),
          )
        }
        resolve(list.find((d) => d.id === id))
      },
      queryTimeMin + Math.random() * (queryTimeMax - queryTimeMin),
    )
  })
}
```

--------------------------------

### Render Basic Index Page for React Router Demo (TSX)

Source: https://tanstack.com/query/v5/docs/framework/react/examples/react-router

This React component serves as the default index page for a demo integrating React Router and React Query. It displays introductory text and links to the documentation for both libraries. While the component itself doesn't directly use TanStack Query, it sets the stage for a React Router application where TanStack Query would manage data fetching.

```tsx
export default function Index() {
  return (
    <p id="zero-state">
      This is a demo for integrating React Router with React Query.
      <br />
      Check out{' '}
      <a href="https://reactrouter.com/">
        the docs at reactrouter.com
      </a> and{' '}
      <a href="https://tanstack.com/query/v5/docs/">the docs at tanstack.com</a>
      .
    </p>
  )
}
```

--------------------------------

### Initialize QueryClient and Prefetch Data (TanStack React Query)

Source: https://tanstack.com/query/v5/docs/reference/QueryClient

This snippet demonstrates how to initialize a `QueryClient` instance in TanStack React Query, setting default options like `staleTime` for queries. It then shows an example of using `queryClient.prefetchQuery` to asynchronously fetch data (`fetchPosts`) and populate the cache, making the data immediately available for subsequent queries.

```tsx
import { QueryClient } from '@tanstack/react-query'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: Infinity,
    },
  },
})

await queryClient.prefetchQuery({ queryKey: ['posts'], queryFn: fetchPosts })
```

--------------------------------

### Schedule Callback with TanStack Query TimeoutManager (TypeScript)

Source: https://tanstack.com/query/v5/docs/reference/timeoutManager

This example illustrates how to use `timeoutManager.setTimeout` to schedule a callback function to execute after a specified delay. It returns a timer ID which can be a number or an object convertible to a number, allowing for subsequent cancellation using `timeoutManager.clearTimeout`.

```tsx
import { timeoutManager } from '@tanstack/react-query'

const timeoutId = timeoutManager.setTimeout(
  () => console.log('ran at:', new Date()),
  1000,
)

const timeoutIdNumber: number = Number(timeoutId)
```

--------------------------------

### Fetch Todos Query Hook with TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/react/examples/optimistic-updates-ui

Defines a custom useTodos hook that fetches todos from '/api/data' endpoint using useQuery. Returns a query object with data, loading, and error states. The hook abstracts the query configuration for reusable access throughout the component tree.

```typescript
type Todos = {
  items: ReadonlyArray<{
    id: string
    text: string
  }>
  ts: number
}

async function fetchTodos(): Promise<Todos> {
  const response = await fetch('/api/data')
  return await response.json()
}

function useTodos() {
  return useQuery({ queryKey: ['todos'], queryFn: fetchTodos })
}
```

--------------------------------

### Fetch and Display Posts List with useQuery - React TypeScript

Source: https://tanstack.com/query/v5/docs/framework/react/examples/default-query-function

Implements a Posts component that uses useQuery hook to fetch a list of posts. Displays loading, error, and success states, and uses queryClient to check cached queries for styling links of already-visited posts.

```typescript
function Posts({
  setPostId,
}: {
  setPostId: React.Dispatch<React.SetStateAction<number>>
}) {
  const queryClient = useQueryClient()

  const { status, data, error, isFetching } = useQuery<Array<Post>>({
    queryKey: ['/posts'],
  })

  return (
    <div>
      <h1>Posts</h1>
      <div>
        {status === 'pending' ? (
          'Loading...'
        ) : status === 'error' ? (
          <span>Error: {error.message}</span>
        ) : (
          <>
            <div>
              {data.map((post) => (
                <p key={post.id}>
                  <a
                    onClick={() => setPostId(post.id)}
                    href="#"
                    style={
                      queryClient.getQueryData([`/posts/${post.id}`])
                        ? {
                            fontWeight: 'bold',
                            color: 'green',
                          }
                        : {}
                    }
                  >
                    {post.title}
                  </a>
                </p>
              ))}
            </div>
            <div>{isFetching ? 'Background Updating...' : ' '}</div>
          </>
        )}
      </div>
    </div>
  )
}
```

--------------------------------

### Get Specific Query Defaults with `queryClient.getQueryDefaults` (TypeScript/JavaScript)

Source: https://tanstack.com/query/v5/docs/reference/QueryClient

Retrieves the default options specifically set for queries matching a given query key. If multiple query defaults match, they are merged based on their registration order, as defined by `setQueryDefaults`.

```typescript
const defaultOptions = queryClient.getQueryDefaults(['posts'])
```

--------------------------------

### Integrate Svelte Query Devtools in Floating Mode

Source: https://tanstack.com/query/v5/docs/framework/svelte/devtools

This Svelte component example demonstrates how to integrate `SvelteQueryDevtools` into your application using Floating Mode. Wrap your application with `QueryClientProvider` and then place the `<SvelteQueryDevtools />` component as high as possible in the component tree for optimal functionality. It provides a toggle button and remembers its state in localStorage.

```ts
<script>
  import { QueryClientProvider } from '@tanstack/svelte-query'
  import { SvelteQueryDevtools } from '@tanstack/svelte-query-devtools'
</script>

<QueryClientProvider client={queryClient}>
  {/* The rest of your application */}
  <SvelteQueryDevtools />
</QueryClientProvider>
```

--------------------------------

### Track Active Mutations with useIsMutating (React Query)

Source: https://tanstack.com/query/v5/docs/framework/react/reference/useIsMutating

This snippet demonstrates how to use the `useIsMutating` hook from `@tanstack/react-query` to get the count of active mutations. It shows both general usage and filtering mutations by a `mutationKey`. The hook returns a number indicating ongoing mutations.

```tsx
import { useIsMutating } from '@tanstack/react-query'
// How many mutations are fetching?
const isMutating = useIsMutating()
// How many mutations matching the posts prefix are fetching?
const isMutatingPosts = useIsMutating({ mutationKey: ['posts'] })
```

--------------------------------

### Illustrate Request Waterfall with Nested `useQuery` in React Components (TanStack Query)

Source: https://tanstack.com/query/v5/docs/framework/solid/guides/prefetching

This example demonstrates a common request waterfall pattern where a parent component (`Article`) fetches its data, and only after it's loaded, a child component (`Comments`) initiates its own data fetch. This sequential loading can lead to delayed user experiences.

```tsx
function Article({ id }) {
  const { data: articleData, isPending } = useQuery(() => {
    queryKey: ['article', id],
    queryFn: getArticleById,
  })

  if (isPending) {
    return 'Loading article...'
  }

  return (
    <>
      <ArticleHeader articleData={articleData} />
      <ArticleBody articleData={articleData} />
      <Comments id={id} />
    </>
  )
}

function Comments({ id }) {
  const { data, isPending } = useQuery(() => {
    queryKey: ['article-comments', id],
    queryFn: getArticleCommentsById,
  })

  ...
}
```

--------------------------------

### Configure ESLint Plugin Query with legacy config custom setup

Source: https://tanstack.com/query/v5/docs/eslint/eslint-plugin-query

Manually configure specific rules for the TanStack Query ESLint plugin using legacy .eslintrc JSON format. Add the plugin to the plugins array and define individual rule configurations.

```json
{
  "plugins": ["@tanstack/query"],
  "rules": {
    "@tanstack/query/exhaustive-deps": "error"
  }
}
```

--------------------------------

### Implementing Reactive Query Options with Solid Query `useQuery`

Source: https://tanstack.com/query/v5/docs/framework/solid/reference/useQuery

This snippet illustrates how to create dynamic queries where options, specifically the `queryKey` and `queryFn` parameters, react to changes in SolidJS signals. It uses `createSignal` to manage a filter state, which then updates the API request and re-fetches data automatically when buttons are clicked. This pattern is crucial for building interactive data-driven applications in SolidJS.

```tsx
import { useQuery } from '@tanstack/solid-query'

function App() {
  const [filter, setFilter] = createSignal('all')

  const todos = useQuery(() => ({
    queryKey: ['todos', filter()],
    queryFn: async () => {
      const response = await fetch(`/api/todos?filter=${filter()}`)
      if (!response.ok) {
        throw new Error('Failed to fetch todos')
      }
      return response.json()
    },
  }))

  return (
    <div>
      <div>
        <button onClick={() => setFilter('all')}>All</button>
        <button onClick={() => setFilter('active')}>Active</button>
        <button onClick={() => setFilter('completed')}>Completed</button>
      </div>
      <Show when={todos.isError}>
        <div>Error: {todos.error.message}</div>
      </Show>
      <Show when={todos.isLoading}>
        <div>Loading...</div>
      </Show>
      <Show when={todos.isSuccess}>
        <div>
          <div>Todos:</div>
          <ul>
            <For each={todos.data}>{(todo) => <li>{todo.title}</li>}</For>
          </ul>
        </div>
      </Show>
    </div>
  )
}
```

--------------------------------

### Provide QueryClient with QueryClientProvider (React / TypeScript)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-react-query-3

Demonstrates connecting a QueryClient to a React component tree using QueryClientProvider. Dependency: react-query and the created QueryClient. Input: client prop pointing to a QueryClient; Output: React context that hooks like useQuery can consume. Limitation: ensure the provider wraps components that use react-query hooks.

```tsx
import { QueryClient, QueryClientProvider } from 'react-query'

const queryClient = new QueryClient()

function App() {
  return <QueryClientProvider client={queryClient}>...</QueryClientProvider>
}
```

--------------------------------

### Configure Query Parameters with UI Controls

Source: https://tanstack.com/query/v5/docs/framework/react/examples/playground

Renders interactive input controls for adjusting query behavior at runtime, including stale time, garbage collection time, error rate, and fetch time bounds. These settings allow developers to experiment with different caching strategies and observe their effects on query performance.

```typescript
<div>
  Stale Time:{' '}
  <input
    type="number"
    min="0"
    step="1000"
    value={staleTime}
    onChange={(e) => setStaleTime(parseFloat(e.target.value))}
    style={{ width: '100px' }}
  />
</div>
<div>
  Garbage collection Time:{' '}
  <input
    type="number"
    min="0"
    step="1000"
    value={gcTime}
    onChange={(e) => setGcTime(parseFloat(e.target.value))}
    style={{ width: '100px' }}
  />
</div>
<div>
  Error Rate:{' '}
  <input
    type="number"
    min="0"
    max="1"
    step=".05"
    value={localErrorRate}
    onChange={(e) => setErrorRate(parseFloat(e.target.value))}
    style={{ width: '100px' }}
  />
</div>
```

--------------------------------

### Get Global Default Options with `queryClient.getDefaultOptions` (TypeScript/JavaScript)

Source: https://tanstack.com/query/v5/docs/reference/QueryClient

Retrieves the global default options configured for the `queryClient` instance. These options are either set during client creation or dynamically updated using `setDefaultOptions` and apply to all queries and mutations unless overridden.

```typescript
const defaultOptions = queryClient.getDefaultOptions()
```

--------------------------------

### Correct Infinite Query Property Order

Source: https://tanstack.com/query/v5/docs/eslint/infinite-query-property-order

Example showing correct property ordering in useInfiniteQuery with queryFn first, followed by getPreviousPageParam and getNextPageParam. This ordering ensures proper type inference and complies with the ESLint rule.

```typescript
/* eslint "@tanstack/query/infinite-query-property-order": "warn" */
import { useInfiniteQuery } from '@tanstack/react-query'

const query = useInfiniteQuery({
  queryKey: ['projects'],
  queryFn: async ({ pageParam }) => {
    const response = await fetch(`/api/projects?cursor=${pageParam}`)
    return await response.json()
  },
  initialPageParam: 0,
  getPreviousPageParam: (firstPage) => firstPage.previousId ?? undefined,
  getNextPageParam: (lastPage) => lastPage.nextId ?? undefined,
  maxPages: 3,
})
```

--------------------------------

### Use Query Hook with Destructuring - TypeScript/React

Source: https://tanstack.com/query/v5/docs/framework/react/examples/optimistic-updates-cache

Extracts isFetching status and remaining query information from useQuery hook using destructuring. The queryInfo object contains data, status, and error information needed for rendering.

```typescript
const { isFetching, ...queryInfo } = useQuery(todoListOptions)
```

--------------------------------

### Mutation with Optimistic Updates and Error Recovery

Source: https://tanstack.com/query/v5/docs/framework/react/examples/optimistic-updates-ui

Implements useMutation for adding new todos with POST request to '/api/data'. Includes error handling and query invalidation via onSettled callback to refetch todos after mutation completes. Enables optimistic UI updates by immediately reflecting user input before server confirmation.

```typescript
const addTodoMutation = useMutation({
  mutationFn: async (newTodo: string) => {
    const response = await fetch('/api/data', {
      method: 'POST',
      body: JSON.stringify({ text: newTodo }),
      headers: { 'Content-Type': 'application/json' },
    })
    if (!response.ok) {
      throw new Error('Something went wrong.')
    }
    return await response.json()
  },
  onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
})
```

--------------------------------

### Fetch Individual Post with Conditional Query Execution in Solid.js

Source: https://tanstack.com/query/v5/docs/framework/solid/examples/default-query-function

Implements a Post component that fetches a single post based on the postId prop. Uses the enabled option to conditionally execute the query only when a valid postId is provided. Displays loading, error, and success states with background refresh indicators.

```typescript
function Post(props: { postId: number; setPostId: Setter<number> }) {
  const state = useQuery<any>(() => ({
    queryKey: [`/posts/${props.postId}`],
    enabled: !!props.postId,
  }))

  return (
    <div>
      <div>
        <a onClick={() => props.setPostId(-1)} href="#">
          Back
        </a>
      </div>
      <Switch>
        <Match when={!props.postId || state.status === 'pending'}>
          Loading...
        </Match>
        <Match when={state.status === 'error'}>
          <span>Error: {(state.error as Error).message}</span>
        </Match>
        <Match when={state.data !== undefined}>
          <>
            <h1>{state.data.title}</h1>
            <div>
              <p>{state.data.body}</p>
            </div>
            <div>{state.isFetching ? 'Background Updating...' : ' '}</div>
          </>
        </Match>
      </Switch>
    </div>
  )
}
```

--------------------------------

### Serial Suspenseful Queries with useQuery in Solid Query

Source: https://tanstack.com/query/v5/docs/framework/solid/guides/request-waterfalls

This example illustrates a scenario in Solid Query with Suspense where multiple individual `useQuery` calls result in serial execution, causing separate roundtrips to the server. This pattern can lead to increased loading times as rendering is suspended until all queries complete sequentially.

```tsx
function App () {
  // The following queries will execute in serial, causing separate roundtrips to the server:
  const usersQuery = useQuery({ queryKey: ['users'], queryFn: fetchUsers })
  const teamsQuery = useQuery({ queryKey: ['teams'], queryFn: fetchTeams })
  const projectsQuery = useQuery({ queryKey: ['projects'], queryFn: fetchProjects })

  // Note that since the queries above suspend rendering, no data
  // gets rendered until all of the queries finished
  ...
}
```

--------------------------------

### Define TypeScript Post Type Interface

Source: https://tanstack.com/query/v5/docs/framework/react/examples/basic

Defines the TypeScript type `Post` for blog post objects. This type specifies the expected structure of a post, including its `id`, `title`, and `body` properties, ensuring type safety in data handling throughout the application.

```typescript
type Post = {
  id: number
  title: string
  body: string
}
```

--------------------------------

### Lazy Load TanStack Query Devtools for Production in React (TSX)

Source: https://tanstack.com/query/v5/docs/framework/react/devtools

This example shows how to lazy-load `ReactQueryDevtools` in a production environment using `React.lazy` and `React.Suspense`. It provides a mechanism (`window.toggleDevtools`) to dynamically load and display the devtools bundle only when needed, preventing it from being included in the initial production build.

```tsx
import * as React from 'react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
import { Example } from './Example'

const queryClient = new QueryClient()

const ReactQueryDevtoolsProduction = React.lazy(() =>
  import('@tanstack/react-query-devtools/build/modern/production.js').then(
    (d) => ({
      default: d.ReactQueryDevtools,
    }),
  ),
)

function App() {
  const [showDevtools, setShowDevtools] = React.useState(false)

  React.useEffect(() => {
    // @ts-expect-error
    window.toggleDevtools = () => setShowDevtools((old) => !old)
  }, [])

  return (
    <QueryClientProvider client={queryClient}>
      <Example />
      <ReactQueryDevtools initialIsOpen />
      {showDevtools && (
        <React.Suspense fallback={null}>
          <ReactQueryDevtoolsProduction />
        </React.Suspense>
      )}
    </QueryClientProvider>
  )
}

export default App
```

--------------------------------

### Fetch GitHub Repository Data with TanStack Query in React

Source: https://tanstack.com/query/v5/docs/framework/react/overview

This example demonstrates the basic usage of TanStack Query to fetch data from a remote API in a React application. It initializes a `QueryClient`, wraps the application with `QueryClientProvider`, and uses the `useQuery` hook to fetch GitHub repository details, handling loading, error, and successful data display.

```tsx
import {
  QueryClient,
  QueryClientProvider,
  useQuery,
} from '@tanstack/react-query'

const queryClient = new QueryClient()

export default function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Example />
    </QueryClientProvider>
  )
}

function Example() {
  const { isPending, error, data } = useQuery({
    queryKey: ['repoData'],
    queryFn: () =>
      fetch('https://api.github.com/repos/TanStack/query').then((res) =>
        res.json(),
      ),
  })

  if (isPending) return 'Loading...'

  if (error) return 'An error has occurred: ' + error.message

  return (
    <div>
      <h1>{data.name}</h1>
      <p>{data.description}</p>
      <strong>üëÄ {data.subscribers_count}</strong>{' '}
      <strong>‚ú® {data.stargazers_count}</strong>{' '}
      <strong>üç¥ {data.forks_count}</strong>
    </div>
  )
}
```

--------------------------------

### Define and use shared query options with TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/react/guides/query-options

This TypeScript example demonstrates how to use the `queryOptions` helper from `@tanstack/react-query` to define reusable query configurations. It shows a `groupOptions` function that encapsulates `queryKey`, `queryFn`, and `staleTime`, and then illustrates its usage with `useQuery`, `useSuspenseQuery`, `useQueries`, `prefetchQuery`, and `setQueryData`.

```ts
import { queryOptions } from '@tanstack/react-query'

function groupOptions(id: number) {
  return queryOptions({
    queryKey: ['groups', id],
    queryFn: () => fetchGroups(id),
    staleTime: 5 * 1000,
  })
}

// usage:

useQuery(groupOptions(1))
useSuspenseQuery(groupOptions(5))
useQueries({
  queries: [groupOptions(1), groupOptions(2)],
})
queryClient.prefetchQuery(groupOptions(23))
queryClient.setQueryData(groupOptions(42).queryKey, newGroups)
```

--------------------------------

### Implement Bi-directional Infinite List with useInfiniteQuery (TanStack Query)

Source: https://tanstack.com/query/v5/docs/framework/vue/guides/infinite-queries

This example demonstrates how to configure `useInfiniteQuery` for bi-directional infinite scrolling. It utilizes `getPreviousPageParam` to allow fetching data in both forward and backward directions, enabling a seamless bi-directional user experience.

```tsx
useInfiniteQuery({
  queryKey: ['projects'],
  queryFn: fetchProjects,
  initialPageParam: 0,
  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
  getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,
})
```

--------------------------------

### Consume Non-Reactive Vue-Query Composable with Ref.value

Source: https://tanstack.com/query/v5/docs/framework/vue/reactivity

This TypeScript example demonstrates consuming the initial `useUserProjects` composable. By extracting `userId.value` and passing it directly, Vue-Query loses its ability to track changes to the `userId` ref, preventing automatic re-fetching when `userId.value` is updated.

```typescript
// Reactive user ID ref.
const userId = ref('1')
// Fetches the user 1's projects.
const { data: projects } = useUserProjects(userId.value)

const onChangeUser = (newUserId: string) => {
  // Edits the userId, but the query will not re-fetch.
  userId.value = newUserId
}
```

--------------------------------

### Combine useQueries Results into a Single Value (TypeScript)

Source: https://tanstack.com/query/v5/docs/framework/solid/reference/useQueries

Illustrates the use of the 'combine' option within `useQueries` to transform an array of individual query results into a single, custom-structured object. This example aggregates data and pending status from multiple post queries.

```tsx
const ids = [1, 2, 3]
const combinedQueries = useQueries(() => {
  queries: ids.map((id) => ({
    queryKey: ['post', id],
    queryFn: () => fetchPost(id),
  })),
  combine: (results) => {
    return {
      data: results.map((result) => result.data),
      pending: results.some((result) => result.isPending),
    }
  },
})
```

--------------------------------

### Invalidate All or Prefix-Matched Queries (TanStack Query)

Source: https://tanstack.com/query/v5/docs/framework/angular/guides/query-invalidation

Demonstrates how to invalidate all cached queries or only those whose keys start with a specific prefix using `queryClient.invalidateQueries()`. This is useful for clearing the entire cache or updating data related to a specific domain like 'todos'.

```tsx
// Invalidate every query in the cache
queryClient.invalidateQueries()
// Invalidate every query with a key that starts with `todos`
queryClient.invalidateQueries({ queryKey: ['todos'] })
```

--------------------------------

### Form Submission with Mutation Trigger - TypeScript/React

Source: https://tanstack.com/query/v5/docs/framework/react/examples/optimistic-updates-cache

Handles form submission by preventing default behavior and calling the mutation with text input value. Demonstrates conditional button disabling based on mutation pending state.

```typescript
<form
  onSubmit={(e) => {
    e.preventDefault()
    addTodoMutation.mutate(text)
  }}
>
  <input
    type="text"
    onChange={(event) => setText(event.target.value)}
    value={text}
  />
  <button disabled={addTodoMutation.isPending}>Create</button>
</form>
```

--------------------------------

### Configure TanStack Query for SvelteKit SSR

Source: https://tanstack.com/query/v5/docs/framework/svelte/ssr

This Svelte component sets up the `QueryClientProvider` for TanStack Query within a SvelteKit application. It utilizes the `browser` module from `$app/environment` to conditionally enable queries, ensuring they are disabled on the server-side to prevent unnecessary asynchronous execution after HTML delivery. This setup is crucial for optimizing SSR performance.

```svelte
<script lang="ts">
  import { browser } from '$app/environment'
  import { QueryClient, QueryClientProvider } from '@tanstack/svelte-query'

  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        enabled: browser,
      },
    },
  })
</script>

<QueryClientProvider client={queryClient}>
  <slot />
</QueryClientProvider>
```

--------------------------------

### Import and Initialize broadcastQueryClient

Source: https://tanstack.com/query/v5/docs/framework/solid/plugins/broadcastQueryClient

Import the broadcastQueryClient function from the experimental package and initialize it with a QueryClient instance. Optionally specify a broadcastChannel name to identify the communication channel between tabs/windows.

```typescript
import { broadcastQueryClient } from '@tanstack/query-broadcast-client-experimental'

const queryClient = new QueryClient()

broadcastQueryClient({
  queryClient,
  broadcastChannel: 'my-app',
})
```

--------------------------------

### Render Posts List Component with Cache Detection

Source: https://tanstack.com/query/v5/docs/framework/react/examples/basic-graphql-request

React component that displays posts from the usePosts hook with loading and error states. Uses queryClient.getQueryData to detect cached posts and highlight them with bold green styling. Shows background update status when data is being refreshed.

```typescript
function Posts({
  setPostId,
}: {
  setPostId: React.Dispatch<React.SetStateAction<number>>
}) {
  const queryClient = useQueryClient()
  const { status, data, error, isFetching } = usePosts()

  return (
    <div>
      <h1>Posts</h1>
      <div>
        {status === 'pending' ? (
          'Loading...'
        ) : status === 'error' ? (
          <span>Error: {error.message}</span>
        ) : (
          <>
            <div>
              {data.map((post) => (
                <p key={post.id}>
                  <a
                    onClick={() => setPostId(post.id)}
                    href="#"
                    style={
                      queryClient.getQueryData(['post', post.id])
                        ? {
                            fontWeight: 'bold',
                            color: 'green',
                          }
                        : {}
                    }
                  >
                    {post.title}
                  </a>
                </p>
              ))}
            </div>
            <div>{isFetching ? 'Background Updating...' : ' '}</div>
          </>
        )}
      </div>
    </div>
  )
}
```

--------------------------------

### Query Client Refetch Options

Source: https://tanstack.com/query/v5/docs/framework/solid/reference/useQuery

Configures automatic refetching behavior for queries. Includes settings for refetching on mount, window focus, reconnect, and background refetching with intervals.

```javascript
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnMount: true, // Refetch on mount if stale (default)
      refetchOnWindowFocus: 'always', // Always refetch on window focus
      refetchOnReconnect: false, // Do not refetch on reconnect
      refetchInterval: 5000, // Refetch every 5 seconds
      refetchIntervalInBackground: true // Continue refetching in background
    }
  }
});

// Example with a function for refetchOnMount
const customRefetchClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnMount: (query) => {
        // Only refetch if the query is marked as 'invalid'
        return query.state.isInvalid;
      }
    }
  }
});

// Example with a function for refetchInterval
const dynamicIntervalClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchInterval: (query) => {
        // Refetch faster if data is stale, slower otherwise
        return query.state.isStale ? 1000 : 10000;
      }
    }
  }
});
```

--------------------------------

### Parallel Suspense Queries with useSuspenseQueries in TanStack Query (TypeScript)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/request-waterfalls

To avoid serial execution with Suspense queries, this example shows how to use `useSuspenseQueries`. By grouping multiple queries into a single call, TanStack Query can fetch them in parallel, improving performance and reducing total loading time.

```tsx
const [usersQuery, teamsQuery, projectsQuery] = useSuspenseQueries({
  queries: [
    { queryKey: ['users'], queryFn: fetchUsers },
    { queryKey: ['teams'], queryFn: fetchTeams },
    { queryKey: ['projects'], queryFn: fetchProjects },
  ],
})
```

--------------------------------

### Configure Tanstack Query with React Suspense and Error Boundary

Source: https://tanstack.com/query/v5/docs/framework/react/examples/suspense

This React component sets up a Tanstack Query client, wraps the application in `QueryClientProvider`, and integrates `React.Suspense` for lazy-loaded components and `ErrorBoundary` with `QueryErrorResetBoundary` for robust error handling during data fetching. It demonstrates conditional rendering, component lazy loading, and `prefetchQuery` for optimizing data loading.

```tsx
import 'font-awesome/css/font-awesome.min.css'
import React, { lazy } from 'react'
import ReactDOM from 'react-dom/client'
import {
  QueryClient,
  QueryClientProvider,
  QueryErrorResetBoundary,
  useQueryClient,
} from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
import { ErrorBoundary } from 'react-error-boundary'

import { fetchProjects } from './queries'

import Button from './components/Button'

const Projects = lazy(() => import('./components/Projects'))
const Project = lazy(() => import('./components/Project'))

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 0,
    },
  },
})

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Example />
    </QueryClientProvider>
  )
}

function Example() {
  const queryClient = useQueryClient()
  const [showProjects, setShowProjects] = React.useState(false)
  const [activeProject, setActiveProject] = React.useState<string | null>(null)

  return (
    <>
      <Button
        onClick={() => {
          setShowProjects((old) => {
            if (!old) {
              queryClient.prefetchQuery({
                queryKey: ['projects'],
                queryFn: fetchProjects,
              })
            }
            return !old
          })
        }}
      >
        {showProjects ? 'Hide Projects' : 'Show Projects'}
      </Button>

      <hr />

      <QueryErrorResetBoundary>
        {({ reset }) => (
          <ErrorBoundary
            fallbackRender={({ error, resetErrorBoundary }) => (
              <div>
                There was an error!{' '}
                <Button onClick={() => resetErrorBoundary()}>Try again</Button>
                <pre style={{ whiteSpace: 'normal' }}>{error.message}</pre>
              </div>
            )}
            onReset={reset}
          >
            {showProjects ? (
              <React.Suspense fallback={<h1>Loading projects...</h1>}>
                {activeProject ? (
                  <Project
                    activeProject={activeProject}
                    setActiveProject={setActiveProject}
                  />
                ) : (
                  <Projects setActiveProject={setActiveProject} />
                )}
              </React.Suspense>
            ) : null}
          </ErrorBoundary>
        )}
      </QueryErrorResetBoundary>
      <ReactQueryDevtools initialIsOpen />
    </>
  )
}

const rootElement = document.getElementById('root') as HTMLElement
ReactDOM.createRoot(rootElement).render(<App />)

```

--------------------------------

### Create IndexedDB Persister for TanStack Query (TypeScript/TSX)

Source: https://tanstack.com/query/v5/docs/framework/react/plugins/persistQueryClient

This function `createIDBPersister` provides an implementation of the `Persister` interface for `@tanstack/react-query-persist-client` using IndexedDB. It utilizes the `idb-keyval` library for asynchronous key-value storage operations (get, set, delete) to persist, restore, and remove `PersistedClient` data.

```tsx
import { get, set, del } from 'idb-keyval'
import {
  PersistedClient,
  Persister,
} from '@tanstack/react-query-persist-client'

/**
 * Creates an Indexed DB persister
 * @see https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API
 */
export function createIDBPersister(idbValidKey: IDBValidKey = 'reactQuery') {
  return {
    persistClient: async (client: PersistedClient) => {
      await set(idbValidKey, client)
    },
    restoreClient: async () => {
      return await get<PersistedClient>(idbValidKey)
    },
    removeClient: async () => {
      await del(idbValidKey)
    },
  } satisfies Persister
}
```

--------------------------------

### Incorrect Infinite Query Property Order

Source: https://tanstack.com/query/v5/docs/eslint/infinite-query-property-order

Example demonstrating incorrect property ordering in useInfiniteQuery where getNextPageParam appears before queryFn, violating type inference requirements. This configuration will trigger the ESLint rule warning.

```typescript
/* eslint "@tanstack/query/infinite-query-property-order": "warn" */
import { useInfiniteQuery } from '@tanstack/react-query'

const query = useInfiniteQuery({
  queryKey: ['projects'],
  getNextPageParam: (lastPage) => lastPage.nextId ?? undefined,
  queryFn: async ({ pageParam }) => {
    const response = await fetch(`/api/projects?cursor=${pageParam}`)
    return await response.json()
  },
  initialPageParam: 0,
  getPreviousPageParam: (firstPage) => firstPage.previousId ?? undefined,
  maxPages: 3,
})
```

--------------------------------

### Keep Only First Page in Infinite Query Data (TanStack Query)

Source: https://tanstack.com/query/v5/docs/framework/solid/guides/infinite-queries

This example shows how to limit the infinite query data to only the first page. It uses `queryClient.setQueryData` to retain only the initial element of the `pages` and `pageParams` arrays, effectively discarding subsequent pages from the cache.

```tsx
queryClient.setQueryData(['projects'], (data) => ({
  pages: data.pages.slice(0, 1),
  pageParams: data.pageParams.slice(0, 1),
}))
```

--------------------------------

### Form Submission with Mutation in React

Source: https://tanstack.com/query/v5/docs/framework/react/examples/auto-refetching

Handles form submission to trigger the addMutation with form data, preventing default submission behavior. On mutation success, clears the input field value to reset the form state.

```typescript
<form
  onSubmit={(event) => {
    event.preventDefault()
    addMutation.mutate(value, {
      onSuccess: () => {
        setValue('')
      },
    })
  }}
>
  <input
    placeholder="enter something"
    value={value}
    onChange={(ev) => setValue(ev.target.value)}
  />
</form>
```

--------------------------------

### Persist Optimistic Updates with persistQueryByKey in TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/react/plugins/createPersister

This TypeScript example shows how to use `persister.persistQueryByKey` within an `onMutate` callback of a `useMutation` hook. It allows for immediate persistence of an optimistic update to a specific query, preventing data loss on page refresh before invalidation.

```tsx
const persister = experimental_createQueryPersister({
  storage: AsyncStorage,
  maxAge: 1000 * 60 * 60 * 12, // 12 hours
})

const queryClient = useQueryClient()

useMutation({
  mutationFn: updateTodo,
  onMutate: async (newTodo) => {
    ...
    // Optimistically update to the new value
    queryClient.setQueryData(['todos'], (old) => [...old, newTodo])
    // And persist it to storage
    persister.persistQueryByKey(['todos'], queryClient)
    ...
  },
})
```

--------------------------------

### Incorrect useMutation() property order in React Query

Source: https://tanstack.com/query/v5/docs/eslint/mutation-property-order

Example demonstrating incorrect property ordering in useMutation() configuration where onSettled appears before onMutate and onError, violating type inference requirements. This will trigger the @tanstack/query/mutation-property-order ESLint warning.

```tsx
/* eslint "@tanstack/query/mutation-property-order": "warn" */
import { useMutation } from '@tanstack/react-query'

const mutation = useMutation({
  mutationFn: () => Promise.resolve('success'),
  onSettled: () => {
    results.push('onSettled-promise')
    return Promise.resolve('also-ignored') // Promise<string> (should be ignored)
  },
  onMutate: async () => {
    results.push('onMutate-async')
    await sleep(1)
    return { backup: 'async-data' }
  },
  onError: async () => {
    results.push('onError-async-start')
    await sleep(1)
    results.push('onError-async-end')
  },
})
```

--------------------------------

### Placeholder Data as Static Value in TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/angular/guides/placeholder-query-data

Demonstrates providing placeholder data as a static value to a query configuration. The query will start in 'success' state with the placeholder data, and the isPlaceholderData flag will be set to true to distinguish it from actual fetched data.

```TypeScript
class TodosComponent {
  result = injectQuery(() => ({
    queryKey: ['todos'],
    queryFn: () => fetch('/todos'),
    placeholderData: placeholderTodos,
  }))
}
```

--------------------------------

### Configure ESLint Plugin Query with flat config custom setup

Source: https://tanstack.com/query/v5/docs/eslint/eslint-plugin-query

Manually configure specific rules for the TanStack Query ESLint plugin using flat config format. Allows selective rule enablement by importing the plugin and defining individual rule configurations.

```javascript
import pluginQuery from '@tanstack/eslint-plugin-query'

export default [
  {
    plugins: {
      '@tanstack/query': pluginQuery,
    },
    rules: {
      '@tanstack/query/exhaustive-deps': 'error',
    },
  },
  // Any other config...
]
```

--------------------------------

### Fetching GitHub Repository Data with useQuery in SolidJS (TSX)

Source: https://tanstack.com/query/v5/docs/framework/solid/overview

This snippet uses the useQuery hook from @tanstack/solid-query to fetch and cache GitHub repository data asynchronously. It depends on solid-js for components like Suspense and ErrorBoundary, and a QueryClient for provider setup. Inputs include queryKey and a fetch function returning JSON; outputs display data like updated_at within Suspense boundaries. Limitations: Relies on network availability; errors are handled via boundaries but not retried automatically without additional configuration.

```tsx
import { ErrorBoundary, Suspense } from 'solid-js'
import {
  useQuery,
  QueryClient,
  QueryClientProvider,
} from '@tanstack/solid-query'

function App() {
  const repositoryQuery = useQuery(() => ({
    queryKey: ['TanStack Query'],
    queryFn: async () => {
      const result = await fetch('https://api.github.com/repos/TanStack/query')
      if (!result.ok) throw new Error('Failed to fetch data')
      return result.json()
    },
    staleTime: 1000 * 60 * 5, // 5 minutes
    throwOnError: true, // Throw an error if the query fails
  }))

  return (
    <div>
      <div>Static Content</div>
      {/* An error while fetching will be caught by the ErrorBoundary */}
      <ErrorBoundary fallback={<div>Something went wrong!</div>}>
        {/* Suspense will trigger a loading state while the data is being fetched */}
        <Suspense fallback={<div>Loading...</div>}>
          {/* 
            The `data` property on a query is a SolidJS resource  
            so it will work with Suspense and transitions out of the box! 
          */}
          <div>{repositoryQuery.data?.updated_at}</div>
        </Suspense>
      </ErrorBoundary>
    </div>
  )
}

const root = document.getElementById('root')
const client = new QueryClient()

render(
  () => (
    <QueryClientProvider client={client}>
      <App />
    </QueryClientProvider>
  ),
  root!,
)
```

--------------------------------

### useInfiniteQuery Implementation in Vue with Load More UI

Source: https://tanstack.com/query/v5/docs/framework/vue/guides/infinite-queries

Vue composition demonstrating useInfiniteQuery setup with fetchProjects query function, getNextPageParam configuration for cursor management, and template rendering of paginated projects with load more button. Handles loading, error, and fetching states with conditional button states.

```vue
<script setup>
import { useInfiniteQuery } from '@tanstack/vue-query'

const fetchProjects = async ({ pageParam = 0 }) => {
  const res = await fetch('/api/projects?cursor=' + pageParam)
  return res.json()
}

const {
  data,
  error,
  fetchNextPage,
  hasNextPage,
  isFetching,
  isFetchingNextPage,
  isPending,
  isError,
} = useInfiniteQuery({
  queryKey: ['projects'],
  queryFn: fetchProjects,
  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
})
</script>

<template>
  <span v-if="isPending">Loading...</span>
  <span v-else-if="isError">Error: {{ error.message }}</span>
  <div v-else-if="data">
    <span v-if="isFetching && !isFetchingNextPage">Fetching...</span>
    <ul v-for="(group, index) in data.pages" :key="index">
      <li v-for="project in group.projects" :key="project.id">
        {{ project.name }}
      </li>
    </ul>
    <button
      @click="() => fetchNextPage()"
      :disabled="!hasNextPage || isFetchingNextPage"
    >
      <span v-if="isFetchingNextPage">Loading more...</span>
      <span v-else-if="hasNextPage">Load More</span>
      <span v-else>Nothing more to load</span>
    </button>
  </div>
</template>
```

--------------------------------

### Mutation with Query Invalidation using useMutation

Source: https://tanstack.com/query/v5/docs/framework/react/examples/auto-refetching

Creates mutations to add and clear todos with automatic query invalidation on success. When mutations complete successfully, invalidateQueries triggers a refetch of the todos query to keep data synchronized.

```typescript
const addMutation = useMutation({
  mutationFn: (add: string) => fetch(`/api/data?add=${add}`),
  onSuccess: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
})

const clearMutation = useMutation({
  mutationFn: () => fetch(`/api/data?clear=1`),
  onSuccess: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
})
```

--------------------------------

### Get Current Focus State with focusManager.isFocused

Source: https://tanstack.com/query/v5/docs/reference/focusManager

Retrieves the current focus state of the application. Returns a boolean indicating whether the application window or tab is currently focused. This method has no parameters and provides read-only access to the focus state.

```tsx
const isFocused = focusManager.isFocused()
```

--------------------------------

### Access Latest Mutation Data by MutationKey with useMutationState

Source: https://tanstack.com/query/v5/docs/framework/react/reference/useMutationState

This example retrieves the latest data from mutations matching a specific `mutationKey`. It filters by `mutationKey`, selects the data, and then accesses the last element of the returned array, representing the most recent mutation invocation.

```tsx
import { useMutation, useMutationState } from '@tanstack/react-query'

const mutationKey = ['posts']

// Some mutation that we want to get the state for
const mutation = useMutation({
  mutationKey,
  mutationFn: (newPost) => {
    return axios.post('/posts', newPost)
  },
})

const data = useMutationState({
  // this mutation key needs to match the mutation key of the given mutation (see above)
  filters: { mutationKey },
  select: (mutation) => mutation.state.data,
})

// Latest mutation data
const latest = data[data.length - 1]
```

--------------------------------

### Optimistic UI Rendering with Loading and Error States

Source: https://tanstack.com/query/v5/docs/framework/react/examples/optimistic-updates-ui

Renders todo list with optimistic updates showing pending mutations with reduced opacity, error states in red with retry button, and background fetching indicator. Displays loading state and timestamps, handling all mutation states (success, pending, error) for complete user feedback.

```typescript
{todoQuery.isSuccess && (
  <>
    <div>
      Updated At: {new Date(todoQuery.data.ts).toLocaleTimeString()}
    </div>
    <ul>
      {todoQuery.data.items.map((todo) => (
        <li key={todo.id}>{todo.text}</li>
      ))}
      {addTodoMutation.isPending && (
        <li style={{ opacity: 0.5 }}>{addTodoMutation.variables}</li>
      )}
      {addTodoMutation.isError && (
        <li style={{ color: 'red' }}>
          {addTodoMutation.variables}
          <button
            onClick={() =>
              addTodoMutation.mutate(addTodoMutation.variables)
            }
          >
            Retry
          </button>
        </li>
      )}
    </ul>
    {todoQuery.isFetching && <div>Updating in background...</div>}
  </>
)}
{todoQuery.isPending && 'Loading'}
{todoQuery.error instanceof Error && todoQuery.error.message}
```

--------------------------------

### Invalidate Queries by Prefix in Angular (TanStack Query)

Source: https://tanstack.com/query/v5/docs/framework/angular/guides/query-invalidation

Shows an Angular example using `injectQuery` where `invalidateQueries` is used to mark queries as stale based on a `queryKey` prefix. In this scenario, both a generic 'todos' query and a paginated 'todos' query will be successfully invalidated.

```ts
import { injectQuery, QueryClient } from '@tanstack/angular-query-experimental'

class QueryInvalidationExample {
  queryClient = inject(QueryClient)

  invalidateQueries() {
    this.queryClient.invalidateQueries({ queryKey: ['todos'] })
  }

  // Both queries below will be invalidated
  todoListQuery = injectQuery(() => ({
    queryKey: ['todos'],
    queryFn: fetchTodoList,
  }))
  todoListQuery = injectQuery(() => ({
    queryKey: ['todos', { page: 1 }],
    queryFn: fetchTodoList,
  }))
}
```

--------------------------------

### Mock postTodo API Function for Creating New Todos

Source: https://tanstack.com/query/v5/docs/framework/react/examples/playground

Simulates creating a new todo with name and notes fields. Generates unique ID, appends to list, and returns the created Todo object with configurable error simulation. Uses Omit utility type to exclude ID from input parameters.

```typescript
function postTodo({ name, notes }: Omit<Todo, 'id'>) {
  console.info('postTodo', { name, notes })
  return new Promise((resolve, reject) => {
    setTimeout(
      () => {
        if (Math.random() < errorRate) {
          return reject(
            new Error(JSON.stringify({ postTodo: { name, notes } }, null, 2)),
          )
        }
        const todo = { name, notes, id: id++ }
        list = [...list, todo]
        resolve(todo)
      },
      queryTimeMin + Math.random() * (queryTimeMax - queryTimeMin),
    )
  })
}
```

--------------------------------

### Implement Next.js Suspense Streaming with React Query

Source: https://tanstack.com/query/v5/docs/framework/react/examples/nextjs-suspense-streaming

This React component demonstrates a Next.js page using client-side directives and 'edge' runtime. It includes a helper function to determine the base URL for API calls, a custom hook `useWaitQuery` to fetch data asynchronously using `useSuspenseQuery`, and a `MyComponent` to display the fetched data. The main `MyPage` component orchestrates multiple instances of `MyComponent` within individual and combined `Suspense` boundaries, showcasing progressive rendering with fallbacks.

```tsx
'use client'
import { isServer, useSuspenseQuery } from '@tanstack/react-query'
import { Suspense } from 'react'

export const runtime = 'edge' // 'nodejs' (default) | 'edge'

function getBaseURL() {
  if (!isServer) {
    return ''
  }
  if (process.env.VERCEL_URL) {
    return `https://${process.env.VERCEL_URL}`
  }
  return 'http://localhost:3000'
}
const baseUrl = getBaseURL()
function useWaitQuery(props: { wait: number }) {
  const query = useSuspenseQuery({
    queryKey: ['wait', props.wait],
    queryFn: async () => {
      const path = `/api/wait?wait=${props.wait}`
      const url = baseUrl + path

      const res: string = await (
        await fetch(url, {
          cache: 'no-store',
        })
      ).json()
      return res
    },
  })

  return [query.data as string, query] as const
}

function MyComponent(props: { wait: number }) {
  const [data] = useWaitQuery(props)

  return <div>result: {data}</div>
}

export default function MyPage() {
  return (
    <>
      <Suspense fallback={<div>waiting 100....</div>}>
        <MyComponent wait={100} />
      </Suspense>
      <Suspense fallback={<div>waiting 200....</div>}>
        <MyComponent wait={200} />
      </Suspense>
      <Suspense fallback={<div>waiting 300....</div>}>
        <MyComponent wait={300} />
      </Suspense>
      <Suspense fallback={<div>waiting 400....</div>}>
        <MyComponent wait={400} />
      </Suspense>
      <Suspense fallback={<div>waiting 500....</div>}>
        <MyComponent wait={500} />
      </Suspense>
      <Suspense fallback={<div>waiting 600....</div>}>
        <MyComponent wait={600} />
      </Suspense>
      <Suspense fallback={<div>waiting 700....</div>}>
        <MyComponent wait={700} />
      </Suspense>

      <fieldset>
        <legend>
          combined <code>Suspense</code>-container
        </legend>
        <Suspense
          fallback={
            <>
              <div>waiting 800....</div>
              <div>waiting 900....</div>
              <div>waiting 1000....</div>
            </>
          }
        >
          <MyComponent wait={800} />
          <MyComponent wait={900} />
          <MyComponent wait={1000} />
        </Suspense>
      </fieldset>
    </>
  )
}
```

--------------------------------

### Enabling Lagging Data Effect with keepPreviousData (React)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-react-query-3

Demonstrates the use of the `keepPreviousData` option in `useQuery` to achieve a 'lagging' effect, similar to the removed `usePaginatedQuery`. This option preserves the previous data while new data is being fetched.

```tsx
import { useQuery } from 'react-query'

function Page({ page }) {
  const { data } = useQuery(['page', page], fetchPage, {
    keepPreviousData: true,
  })
}
```

--------------------------------

### Access `useMutation` State Across Components with `useMutationState` (Solid Query)

Source: https://tanstack.com/query/v5/docs/framework/solid/guides/optimistic-updates

This example illustrates how to share mutation variables across different components using Solid Query's `useMutationState` hook. It assigns a `mutationKey` to `useMutation` and then filters for pending mutations with that key to extract their variables.

```tsx
// somewhere in your app
const { mutate } = useMutation(() => {
  mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
  onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
  mutationKey: ['addTodo'],
})

// access variables somewhere else
const variables = useMutationState<string>({
  filters: { mutationKey: ['addTodo'], status: 'pending' },
  select: (mutation) => mutation.state.variables,
})
```

--------------------------------

### Basic TanStack Query useMutation for Adding Data

Source: https://tanstack.com/query/v5/docs/framework/react/guides/mutations

This example demonstrates how to use the `useMutation` hook to send a POST request to add a new todo item. It shows how to define the `mutationFn`, handle different mutation states (pending, error, success) in the UI, and trigger the mutation with `mutate`.

```tsx
function App() {
  const mutation = useMutation({
    mutationFn: (newTodo) => {
      return axios.post('/todos', newTodo)
    },
  })

  return (
    <div>
      {mutation.isPending ? (
        'Adding todo...'
      ) : (
        <>
          {mutation.isError ? (
            <div>An error occurred: {mutation.error.message}</div>
          ) : null}

          {mutation.isSuccess ? <div>Todo added!</div> : null}

          <button
            onClick={() => {
              mutation.mutate({ id: new Date(), title: 'Do Laundry' })
            }}
          >
            Create Todo
          </button>
        </>
      )}
    </div>
  )
}
```

--------------------------------

### Implement Load More UI with Infinite Query

Source: https://tanstack.com/query/v5/docs/framework/angular/guides/infinite-queries

Demonstrates creating a load more user interface using TanStack Query's infinite query functionality. The example shows how to set up the query with proper pagination parameters, handle the initial data fetch, and provide user feedback during loading states. Uses Angular's injectInfiniteQuery with async data fetching and computed properties for UI state management.

```angular-ts
import { Component, computed, inject } from '@angular/core'
import { injectInfiniteQuery } from '@tanstack/angular-query-experimental'
import { lastValueFrom } from 'rxjs'
import { ProjectsService } from './projects-service'

@Component({
  selector: 'example',
  templateUrl: './example.component.html',
})
export class Example {
  projectsService = inject(ProjectsService)

  query = injectInfiniteQuery(() => ({
    queryKey: ['projects'],
    queryFn: async ({ pageParam }) => {
      return lastValueFrom(this.projectsService.getProjects(pageParam))
    },
    initialPageParam: 0,
    getPreviousPageParam: (firstPage) => firstPage.previousId ?? undefined,
    getNextPageParam: (lastPage) => lastPage.nextId ?? undefined,
    maxPages: 3,
  }))

  nextButtonDisabled = computed(
    () => !this.#hasNextPage() || this.#isFetchingNextPage(),
  )
  nextButtonText = computed(() =>
    this.#isFetchingNextPage()
      ? 'Loading more...'
      : this.#hasNextPage()
        ? 'Load newer'
        : 'Nothing more to load',
  )

  #hasNextPage = this.query.hasNextPage
  #isFetchingNextPage = this.query.isFetchingNextPage
}
```

```angular-html
<div>
  @if (query.isPending()) {
  <p>Loading...</p>
  } @else if (query.isError()) {
  <span>Error: {{ query?.error().message }}</span>
  } @else { @for (page of query?.data().pages; track $index) { @for (project of
  page.data; track project.id) {
  <p>{{ project.name }} {{ project.id }}</p>
  } }
  <div>
    <button (click)="query.fetchNextPage()" [disabled]="nextButtonDisabled()">
      {{ nextButtonText() }}
    </button>
  </div>
  }
</div>
```

--------------------------------

### Configure Default Query Function with QueryClient - React TypeScript

Source: https://tanstack.com/query/v5/docs/framework/react/examples/default-query-function

Sets up a QueryClient with a default query function that receives the query key and fetches data from JSONPlaceholder API. This default function is applied to all queries unless overridden, eliminating the need to specify queryFn for each useQuery call.

```typescript
import { QueryClient } from '@tanstack/react-query'
import type { QueryKey } from '@tanstack/react-query'

type Post = {
  id: number
  title: string
  body: string
}

const defaultQueryFn = async ({ queryKey }: { queryKey: QueryKey }) => {
  const response = await fetch(
    `https://jsonplaceholder.typicode.com${queryKey[0]}`,
  )
  return await response.json()
}

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryFn: defaultQueryFn,
    },
  },
})
```

--------------------------------

### Configure defaultOptions on QueryClient (React Query / TypeScript)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-react-query-3

Shows how to provide defaultOptions for queries and mutations when instantiating QueryClient. Dependency: react-query. Input: defaultOptions object with queries and mutations settings; Output: configured QueryClient. Limitation: note the option name is defaultOptions (not defaultConfig).

```tsx
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // query options
    },
    mutations: {
      // mutation options
    },
  },
})
```

--------------------------------

### Manage `initialData` Freshness with `staleTime` and `initialDataUpdatedAt` in TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/react/guides/initial-query-data

These examples demonstrate how `staleTime` and `initialDataUpdatedAt` influence the freshness of `initialData`. They show scenarios where data is immediately refetched, considered fresh for a set duration, or validated against an update timestamp to control subsequent refetches.

```tsx
// Will show initialTodos immediately, but also immediately refetch todos after mount
const result = useQuery({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: initialTodos,
})
```

```tsx
// Show initialTodos immediately, but won't refetch until another interaction event is encountered after 1000 ms
const result = useQuery({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: initialTodos,
  staleTime: 1000,
})
```

```tsx
// Show initialTodos immediately, but won't refetch until another interaction event is encountered after 1000 ms
const result = useQuery({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: initialTodos,
  staleTime: 60 * 1000, // 1 minute
  // This could be 10 seconds ago or 10 minutes ago
  initialDataUpdatedAt: initialTodosUpdatedTimestamp, // eg. 1608412420052
})
```

--------------------------------

### Filter Todo List with useQuery and Status Handling

Source: https://tanstack.com/query/v5/docs/framework/react/examples/playground

React component that fetches and displays a filtered todo list using TanStack Query's useQuery hook. Handles loading, error, and success states with retry functionality and background refresh indication. Displays failure attempt count and allows users to filter todos by entering search text.

```TypeScript/React
const { status, data, isFetching, error, failureCount, refetch } = useQuery({
  queryKey: ['todos', { filter }],
  queryFn: ({ signal }) => fetchTodos({ signal, filter }),
})

return (
  <div>
    <label>
      Filter:{' '}
      <input value={filter} onChange={(e) => setFilter(e.target.value)} />
    </label>
    {status === 'pending' ? (
      <span>Loading... (Attempt: {failureCount + 1})</span>
    ) : status === 'error' ? (
      <span>
        Error: {error.message}
        <br />
        <button onClick={() => refetch()}>Retry</button>
      </span>
    ) : (
      <>
        <ul>
          {data
            ? data.map((todo) => (
                <li key={todo.id}>
                  {todo.name}{' '}
                  <button onClick={() => setEditingIndex(todo.id)}>
                    Edit
                  </button>
                </li>
              ))
            : null}
        </ul>
        <div>
          {isFetching ? (
            <span>
              Background Refreshing... (Attempt: {failureCount + 1})
            </span>
          ) : (
            <span>&nbsp;</span>
          )}
        </div>
      </>
    )}
  </div>
)
```

--------------------------------

### useQueries Basic Usage TypeScript

Source: https://tanstack.com/query/v5/docs/framework/vue/reference/useQueries

Demonstrates basic usage of useQueries to fetch multiple posts by ID. The hook accepts a queries array with individual query configurations (queryKey, queryFn, staleTime) and returns results in the same order as input. Each query configuration mirrors useQuery options except for the queryClient parameter, which can be passed at the top level instead.

```typescript
const ids = [1, 2, 3]
const results = useQueries({
  queries: ids.map((id) => ({
    queryKey: ['post', id],
    queryFn: () => fetchPost(id),
    staleTime: Infinity,
  })),
})
```

--------------------------------

### Display Posts List Component with TanStack Query in React

Source: https://tanstack.com/query/v5/docs/framework/react/examples/basic

The `Posts` React component displays a list of posts fetched using the `usePosts` hook. It handles loading, error, and data display states, allowing users to click on post titles to view individual posts. It also visually indicates cached posts using `queryClient.getQueryData` for better UX.

```typescript
function Posts({
  setPostId,
}: {
  setPostId: React.Dispatch<React.SetStateAction<number>>
}) {
  const queryClient = useQueryClient()
  const { status, data, error, isFetching } = usePosts()

  return (
    <div>
      <h1>Posts</h1>
      <div>
        {status === 'pending' ? (
          'Loading...'
        ) : status === 'error' ? (
          <span>Error: {error.message}</span>
        ) : (
          <>
            <div>
              {data.map((post) => (
                <p key={post.id}>
                  <a
                    onClick={() => setPostId(post.id)}
                    href="#"
                    style={
                      // We can access the query data here to show bold links for
                      // ones that are cached
                      queryClient.getQueryData(['post', post.id])
                        ? {
                            fontWeight: 'bold',
                            color: 'green',
                          }
                        : {}
                    }
                  >
                    {post.title}
                  </a>
                </p>
              ))}
            </div>
            <div>{isFetching ? 'Background Updating...' : ' '}</div>
          </>
        )}
      </div>
    </div>
  )
}
```

--------------------------------

### Mock fetchTodos API Function with Filter and Error Handling

Source: https://tanstack.com/query/v5/docs/framework/react/examples/playground

Simulates fetching a filtered list of todos with configurable error rate and delay. Returns a Promise that resolves with filtered todos or rejects with a JSON error object. Supports query cancellation logging and random response delays between queryTimeMin and queryTimeMax.

```typescript
function fetchTodos(filter: string) {
  console.info('cancelled', filter)
  return new Promise((resolve, reject) => {
    setTimeout(
      () => {
        if (Math.random() < errorRate) {
          return reject(
            new Error(JSON.stringify({ fetchTodos: { filter } }, null, 2)),
          )
        }
        resolve(list.filter((d) => d.name.includes(filter)))
      },
      queryTimeMin + Math.random() * (queryTimeMax - queryTimeMin),
    )
  })
}
```

--------------------------------

### Render Infinite Query Data with Navigation Buttons

Source: https://tanstack.com/query/v5/docs/framework/react/examples/infinite-query-with-max-pages

Displays paginated project data with loading, error, and success states. Includes Previous/Next buttons that are conditionally disabled based on pagination availability, with dynamic button text reflecting loading status and remaining pages.

```typescript
return (
  <div>
    <h1>Infinite Query with max pages</h1>
    <h3>4 projects per page</h3>
    <h3>3 pages max</h3>
    {status === 'pending' ? (
      <p>Loading...</p>
    ) : status === 'error' ? (
      <span>Error: {error.message}</span>
    ) : (
      <>
        <div>
          <button
            onClick={() => fetchPreviousPage()}
            disabled={!hasPreviousPage || isFetchingPreviousPage}
          >
            {isFetchingPreviousPage
              ? 'Loading more...'
              : hasPreviousPage
                ? 'Load Older'
                : 'Nothing more to load'}
          </button>
        </div>
        {data.pages.map((page) => (
          <React.Fragment key={page.nextId}>
            {page.data.map((project) => (
              <p
                style={{
                  border: '1px solid gray',
                  borderRadius: '5px',
                  padding: '8px',
                  fontSize: '14px',
                  background: `hsla(${project.id * 30}, 60%, 80%, 1)`,
                }}
                key={project.id}
              >
                {project.name}
              </p>
            ))}
          </React.Fragment>
        ))}
        <div>
          <button
            onClick={() => fetchNextPage()}
            disabled={!hasNextPage || isFetchingNextPage}
          >
            {isFetchingNextPage
              ? 'Loading more...'
              : hasNextPage
                ? 'Load Newer'
                : 'Nothing more to load'}
          </button>
        </div>
        <div>
          {isFetching && !isFetchingNextPage
            ? 'Background Updating...'
            : null}
        </div>
      </>
    )}
    <hr />
    <ReactQueryDevtools initialIsOpen />
  </div>
)
```

--------------------------------

### Mutation with Optimistic Updates and Rollback - TypeScript/React

Source: https://tanstack.com/query/v5/docs/framework/react/examples/optimistic-updates-cache

Implements a complete mutation pattern with optimistic updates, error handling, and rollback. Uses onMutate to preview changes, onError to restore previous state on failure, and onSettled to refetch data. Requires context.client for query management.

```typescript
const addTodoMutation = useMutation({
  mutationFn: async (newTodo: string) => {
    const response = await fetch('/api/data', {
      method: 'POST',
      body: JSON.stringify({ text: newTodo }),
      headers: { 'Content-Type': 'application/json' },
    })
    return await response.json()
  },
  onMutate: async (newTodo, context) => {
    setText('')
    await context.client.cancelQueries(todoListOptions)
    const previousTodos = context.client.getQueryData(
      todoListOptions.queryKey,
    )
    if (previousTodos) {
      context.client.setQueryData(todoListOptions.queryKey, {
        ...previousTodos,
        items: [
          ...previousTodos.items,
          { id: Math.random().toString(), text: newTodo },
        ],
      })
    }
    return { previousTodos }
  },
  onError: (err, variables, onMutateResult, context) => {
    if (onMutateResult?.previousTodos) {
      context.client.setQueryData<Todos>(
        ['todos'],
        onMutateResult.previousTodos,
      )
    }
  },
  onSettled: (data, error, variables, onMutateResult, context) =>
    context.client.invalidateQueries({ queryKey: ['todos'] }),
})
```

--------------------------------

### Fetch Multiple Queries with useQueries (TypeScript/React)

Source: https://tanstack.com/query/v5/docs/framework/react/reference/useQueries

This example demonstrates the basic usage of the `useQueries` hook to fetch data for a variable number of items. It takes an array of IDs and maps them to an array of query objects, each specifying a `queryKey`, `queryFn`, and `staleTime`, similar to `useQuery`.

The `results` variable will contain an array of query result objects, ordered according to the input `ids`.

```tsx
const ids = [1, 2, 3]
const results = useQueries({
  queries: ids.map((id) => ({
    queryKey: ['post', id],
    queryFn: () => fetchPost(id),
    staleTime: Infinity,
  })),
})
```

--------------------------------

### React Component for Displaying and Filtering Todos with TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/react/examples/playground

The `Todos` component fetches and displays a list of todo items, allowing users to apply a filter. It utilizes `useQuery` from TanStack Query to manage the data fetching lifecycle, including loading, error, and background refreshing states. The component accepts an `initialFilter` and a callback to set the `editingIndex` for individual todos.

```typescript
function Todos({
  initialFilter = '',
  setEditingIndex,
}: {
  initialFilter: string
  setEditingIndex: React.Dispatch<React.SetStateAction<number | null>>
}) {
  const [filter, setFilter] = React.useState(initialFilter)

  const { status, data, isFetching, error, failureCount, refetch } = useQuery({
    queryKey: ['todos', { filter }],
    queryFn: fetchTodos,
  })

  return (
    <div>
      <div>
        <label>
          Filter:{' '}
          <input value={filter} onChange={(e) => setFilter(e.target.value)} />
        </label>
      </div>
      {status === 'pending' ? (
        <span>Loading... (Attempt: {failureCount + 1})</span>
      ) : status === 'error' ? (
        <span>
          Error: {error.message}
          <br />
          <button onClick={() => refetch()}>Retry</button>
        </span>
      ) : (
        <>
          <ul>
            {data
              ? data.map((todo) => (
                  <li key={todo.id}>
                    {todo.name}{' '}
                    <button onClick={() => setEditingIndex(todo.id)}>
                      Edit
                    </button>
                  </li>
                ))
              : null}
          </ul>
          <div>
            {isFetching ? (
              <span>
                Background Refreshing... (Attempt: {failureCount + 1})
              </span>
            ) : (
              <span>&nbsp;</span>
            )}
          </div>
        </>
      )}
    </div>
  )
}
```

--------------------------------

### Update Existing Todo via PATCH

Source: https://tanstack.com/query/v5/docs/framework/react/examples/playground

Async function that updates an existing todo by ID, replacing the entire todo object in the in-memory list. Includes simulated network delay and random error injection. Resolves with the updated todo or rejects with error details.

```TypeScript
function patchTodo(todo?: Todo): Promise<Todo> {
  console.info('patchTodo', todo)
  return new Promise((resolve, reject) => {
    setTimeout(
      () => {
        if (Math.random() < errorRate) {
          return reject(new Error(JSON.stringify({ patchTodo: todo }, null, 2))))
        }
        list = list.map((d) => {
          if (d.id === todo.id) {
            return todo
          }
          return d
        })
        resolve(todo)
      },
      queryTimeMin + Math.random() * (queryTimeMax - queryTimeMin),
    )
  })
}
```

--------------------------------

### Include Variables in Query Keys for Vue

Source: https://tanstack.com/query/v5/docs/framework/vue/guides/query-keys

Shows best practice of including dependent variables in query keys to ensure proper caching and automatic refetching. This Vue example demonstrates using a reactive reference as a dependency and including it in both the query key and query function.

```ts
import type { Ref } from 'vue'

function useTodos(todoId: Ref<string>) {
  const queryKey = ['todos', todoId]
  return useQuery({
    queryKey,
    queryFn: () => fetchTodoById(todoId.value),
  })
}
```

--------------------------------

### Update Todo State and Handle Mutation Status in React

Source: https://tanstack.com/query/v5/docs/framework/react/examples/playground

React component code that updates todo notes via controlled input, displays save button state, and shows mutation status (pending, error, or success). Includes background refresh attempt counter and disabled state management.

```TypeScript
setTodo((old) => ({ ...old, notes: e.target.value }))

<button onClick={onSave} disabled={disableEditSave}>
  Save
</button>

<div>
  {saveMutation.status === 'pending'
    ? 'Saving...'
    : saveMutation.status === 'error'
      ? saveMutation.error.message
      : 'Saved!'}
</div>

<div>
  {isFetching ? (
    <span>
      Background Refreshing... (Attempt: {failureCount + 1})
    </span>
  ) : (
    <span>&nbsp;</span>
  )}
</div>
```

--------------------------------

### Registering Global `Meta` Type for TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/solid/typescript

This example shows how to register a global `Meta` type for both queries and mutations using module augmentation. This ensures type consistency and safety for the optional `meta` field across all `useQuery` and `useMutation` hooks, requiring the `MyMeta` interface to extend `Record<string, unknown>`.

```ts
import '@tanstack/solid-query'

interface MyMeta extends Record<string, unknown> {
  // Your meta type definition.
}

declare module '@tanstack/solid-query' {
  interface Register {
    queryMeta: MyMeta
    mutationMeta: MyMeta
  }
}
```

--------------------------------

### Test fetch data hook with nock mocking

Source: https://tanstack.com/query/v5/docs/framework/react/guides/testing

Mocks HTTP GET request to /api/data using nock, sets up QueryClientProvider wrapper, renders useFetchData hook, waits for success, verifies returned data matches mocked response.

```tsx
const queryClient = new QueryClient()
const wrapper = ({ => (
  <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
)

const expectation = nock('http://example.com').get('/api/data').reply(200, {
  answer: 42,
})

const { result } = renderHook(() => useFetchData(), { wrapper })

await waitFor(() => expect(result.current.isSuccess).toBe(true))

expect(result.current.data).toEqual({ answer: 42 })
```

--------------------------------

### Create and subscribe to an InfiniteQueryObserver (TSX)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-react-query-3

Use InfiniteQueryObserver to create or watch infinite/paginated queries, providing functions to derive next/previous page params. Requires queryFn and pagination param callbacks; subscribe returns updates for pages and metadata. Ideal for manual control of infinite queries outside standard hooks.

```tsx
const observer = new InfiniteQueryObserver(queryClient, {
  queryKey: 'posts',
  queryFn: fetchPosts,
  getNextPageParam: (lastPage, allPages) => lastPage.nextCursor,
  getPreviousPageParam: (firstPage, allPages) => firstPage.prevCursor,
})

const unsubscribe = observer.subscribe((result) => {
  console.log(result)
  unsubscribe()
})
```

--------------------------------

### Access Latest Specific Mutation Data with useMutationState (TanStack Solid-Query)

Source: https://tanstack.com/query/v5/docs/framework/solid/reference/useMutationState

Building on the previous example, this snippet shows how to retrieve the `data` for specific mutations using a `mutationKey` and then access the *latest* entry from the returned array. This is useful when multiple mutations with the same key are in the cache due to `gcTime`.

```tsx
import { useMutation, useMutationState } from '@tanstack/solid-query'

const mutationKey = ['posts']

// Some mutation that we want to get the state for
const mutation = useMutation(() => {
  mutationKey,
  mutationFn: (newPost) => {
    return axios.post('/posts', newPost)
  },
})

const data = useMutationState(() => {
  // this mutation key needs to match the mutation key of the given mutation (see above)
  filters: { mutationKey },
  select: (mutation) => mutation.state.data,
})

// Latest mutation data
const latest = data[data.length - 1]
```

--------------------------------

### Configure TanStack Query with `initialData`

Source: https://tanstack.com/query/v5/docs/framework/solid/guides/initial-query-data

Demonstrates the basic usage of the `initialData` option within `useQuery` to pre-populate a query's cache with existing data. This allows the query to immediately display data without an initial loading state, assuming `initialTodos` is available.

```tsx
const result = useQuery(() => {
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: initialTodos,
})
```

--------------------------------

### Fetch Single Post by ID Utility Function

Source: https://tanstack.com/query/v5/docs/framework/react/examples/basic

An asynchronous utility function `getPostById` responsible for fetching a single post from the JSONPlaceholder API based on its provided `id`. It returns a `Promise<Post>` after retrieving and parsing the JSON response, ready for use by TanStack Query hooks.

```typescript
const getPostById = async (id: number): Promise<Post> => {
  const response = await fetch(
    `https://jsonplaceholder.typicode.com/posts/${id}`,
  )
  return await response.json()
}
```

--------------------------------

### Run multiple parallel queries using useQueries (TSX)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-react-query-3

Execute a variable-length set of parallel queries by passing an array of query option objects to useQueries. Each item requires queryKey and queryFn; the hook returns an array of results corresponding to each query. Useful when the number of queries is dynamic and cannot be handled with a loop of individual hooks.

```tsx
import { useQueries } from 'react-query'

function Overview() {
  const results = useQueries([
    { queryKey: ['post', 1], queryFn: fetchPost },
    { queryKey: ['post', 2], queryFn: fetchPost },
  ])
  return (
    <ul>
      {results.map(({ data }) => data && <li key={data.id}>{data.title})</li>)}
    </ul>
  )
}
```

--------------------------------

### TanStack Router Integration with Query Prefetching

Source: https://tanstack.com/query/v5/docs/framework/solid/guides/prefetching

Configure a TanStack Router route with beforeLoad and loader hooks to prefetch query data before rendering. The example shows how to block rendering until critical data (article) is loaded while asynchronously prefetching secondary data (comments) without blocking. Uses QueryClient's prefetchQuery method to eagerly load data into the cache.

```tsx
const queryClient = new QueryClient()
const routerContext = new RouterContext()
const rootRoute = routerContext.createRootRoute({
  component: () => { ... }
})

const articleRoute = new Route({
  getParentRoute: () => rootRoute,
  path: 'article',
  beforeLoad: () => {
    return {
      articleQueryOptions: { queryKey: ['article'], queryFn: fetchArticle },
      commentsQueryOptions: { queryKey: ['comments'], queryFn: fetchComments },
    }
  },
  loader: async ({
    context: { queryClient },
    routeContext: { articleQueryOptions, commentsQueryOptions },
  }) => {
    // Fetch comments asap, but don't block
    queryClient.prefetchQuery(commentsQueryOptions)

    // Don't render the route at all until article has been fetched
    await queryClient.prefetchQuery(articleQueryOptions)
  },
  component: ({ useRouteContext }) => {
    const { articleQueryOptions, commentsQueryOptions } = useRouteContext()
    const articleQuery = useQuery(() => articleQueryOptions)
    const commentsQuery = useQuery(() => commentsQueryOptions)

    return (
      ...
    )
  },
  errorComponent: () => 'Oh crap!',
})
```

--------------------------------

### Fetch Single Post Detail with Conditional Query - Solid.js

Source: https://tanstack.com/query/v5/docs/framework/solid/examples/basic-graphql-request

Creates a query hook to fetch a single post by ID with full details (id, title, body). Uses the enabled option to conditionally run the query only when postId is valid. Demonstrates dependent queries where the query key includes the postId accessor value.

```TypeScript
function createPost(postId: Accessor<number>) {
  return useQuery(() => ({
    queryKey: ['post', postId()],
    queryFn: async () => {
      const { post } = await request<{ post: Post }>(
        endpoint,
        gql`
        query {
          post(id: ${postId()}) {
            id
            title
            body
          }
        }
        `,
      )

      return post
    },
    enabled: !!postId(),
  }))
}
```

--------------------------------

### Import core QueryClient from react-query/core (TSX)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-react-query-3

Import the non-React core of React Query to use its client and utilities outside of React or in other frameworks. This import isolates core functionality and does not include React-specific hooks or integrations. Useful for server-side or framework-agnostic usage.

```tsx
import { QueryClient } from 'react-query/core'
```

--------------------------------

### Initialize React App with ReactDOM and MSW

Source: https://tanstack.com/query/v5/docs/framework/react/examples/offline

Sets up a React application root with TanStack Query integration, initializes Mock Service Worker (MSW) for API mocking, and renders the main App component. This pattern is commonly used for offline-capable applications and development environments with intercepted HTTP requests.

```typescript
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import { worker } from './api'

worker.start()

const rootElement = document.getElementById('root') as HTMLElement
ReactDOM.createRoot(rootElement).render(
  <div style={{ padding: '16px' }}>
    <App />
  </div>,
)
```

--------------------------------

### Fetch Data with useSuspenseQuery in TanStack Query v5

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-v5

TanStack Query v5 introduces dedicated `useSuspenseQuery` hooks to provide stable suspense for data fetching. This example demonstrates using `useSuspenseQuery` to fetch a post by its ID, ensuring the `data` variable is always defined at the type level, eliminating the need for `undefined` checks.

```js
const { data: post } = useSuspenseQuery({
  // ^? const post: Post
  queryKey: ['post', postId],
  queryFn: () => fetchPost(postId),
})
```

--------------------------------

### Correct TanStack Query Key Usage (ESLint Rule)

Source: https://tanstack.com/query/v5/docs/eslint/exhaustive-deps

These examples illustrate the correct way to define query keys by ensuring all variables (`todoId` or `id`) utilized within the `queryFn` are explicitly included in the `queryKey` array. This adheres to the exhaustive dependencies principle, guaranteeing that each unique query is cached independently and automatically refetched when its dependencies change.

```tsx
useQuery({
  queryKey: ['todo', todoId],
  queryFn: () => api.getTodo(todoId),
})
```

```tsx
const todoQueries = {
  detail: (id) => ({ queryKey: ['todo', id],
  queryFn: () => api.getTodo(id) }),
}
```

--------------------------------

### Define and Use TanStack Query Options Helper (TypeScript)

Source: https://tanstack.com/query/v5/docs/framework/solid/guides/query-options

This code demonstrates how to define shared query options using the `queryOptions` helper, encapsulating `queryKey`, `queryFn`, and other configurations for a specific query. It then shows various ways to use these defined options with `useQuery`, `useSuspenseQuery`, `useQueries`, `queryClient.prefetchQuery`, and `queryClient.setQueryData`, promoting reusability and co-location.

```ts
import { queryOptions } from '@tanstack/solid-query'

function groupOptions(id: number) {
  return queryOptions({
    queryKey: ['groups', id],
    queryFn: () => fetchGroups(id),
    staleTime: 5 * 1000,
  })
}

// usage:

useQuery(() => groupOptions(1))
useSuspenseQuery(groupOptions(5))
useQueries(() => {
  queries: [groupOptions(1), groupOptions(2)],
})
queryClient.prefetchQuery(groupOptions(23))
queryClient.setQueryData(groupOptions(42).queryKey, newGroups)
```

--------------------------------

### React Component JSX with Event Handlers and TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/react/examples/auto-refetching

This snippet illustrates various React JSX elements, event handlers (`onChange`, `onSubmit`, `onClick`), and inline styles within a component. It demonstrates how to handle input changes, form submissions with `addMutation`, and button clicks with `clearMutation`, both presumably from TanStack Query. A visual fetching indicator and `ReactQueryDevtools` are also present.

```jsx
          onChange={(ev) => setIntervalMs(Number(ev.target.value))}
          type="number"
          step="100"
        />{' '}
        <span
          style={{
            display: 'inline-block',
            marginLeft: '.5rem',
            width: 10,
            height: 10,
            background: isFetching ? 'green' : 'transparent',
            transition: !isFetching ? 'all .3s ease' : 'none',
            borderRadius: '100%',
            transform: 'scale(2)'
          }}
        />
      </label>
      <h2>Todo List</h2>
      <form
        onSubmit={(event) => {
          event.preventDefault()
          addMutation.mutate(value, {
            onSuccess: () => {
              setValue('')
            }
          })
        }}
      >
        <input
          placeholder="enter something"
          value={value}
          onChange={(ev) => setValue(ev.target.value)}
        />
      </form>
      <ul>
        {data.map((item) => (
          <li key={item}>{item}</li>
        ))}
      </ul>
      <div>
        <button
          onClick={() => {
            clearMutation.mutate()
          }}
        >
          Clear All
        </button>
      </div>
      <ReactQueryDevtools initialIsOpen />
    </div>
```

--------------------------------

### TanStack Query v5 `useMutation` Hook Documentation

Source: https://tanstack.com/query/v5/docs/framework/vue/reference/useMutation

Comprehensive documentation for the `useMutation` hook, covering its configuration parameters and the detailed object returned for managing asynchronous data mutations, including state, methods, and callbacks.

```APIDOC
## TanStack Query v5: `useMutation` Hook

### Description
The `useMutation` hook in TanStack Query v5 provides a powerful way to manage asynchronous server-side data mutations. This documentation details the optional parameters accepted by the hook and the comprehensive object it returns for controlling and observing the mutation's lifecycle.

### Parameters (for the `useMutation` hook itself)
#### Request Body (conceptually, the options object passed to `useMutation`)
- **meta** (`Record<string, unknown>`) - Optional - Stores additional information on the mutation cache entry, accessible wherever the `mutation` is available (e.g., `onError`, `onSuccess`).
- **queryClient** (`QueryClient`) - Optional - Use a custom `QueryClient` instance. If not provided, the nearest context's `QueryClient` will be used.

### Returned Object Properties and Methods

#### `mutate: (variables: TVariables, options: { onSuccess?, onSettled?, onError? }) => void`
- **Description**: The function to trigger the mutation.
- **Parameters**:
  - `variables: TVariables` (Optional) - The data payload for the `mutationFn`.
  - `options` (Object) - Optional callback functions:
    - `onSuccess: (data: TData, variables: TVariables, onMutateResult: TOnMutateResult | undefined, context: MutationFunctionContext) => void` (Optional) - Fires on successful mutation.
    - `onError: (err: TError, variables: TVariables, onMutateResult: TOnMutateResult | undefined, context: MutationFunctionContext) => void` (Optional) - Fires if the mutation fails.
    - `onSettled: (data: TData | undefined, error: TError | null, variables: TVariables, onMutateResult: TOnMutateResult | undefined, context: MutationFunctionContext) => void` (Optional) - Fires regardless of success or failure.
- **Returns**: `void`

#### `mutateAsync: (variables: TVariables, options: { onSuccess?, onSettled?, onError? }) => Promise<TData>`
- **Description**: Similar to `mutate` but returns a promise for `await`ing.
- **Parameters**: Same as `mutate`.
- **Returns**: `Promise<TData>`

#### `status: MutationStatus`
- **Description**: The current status of the mutation.
- **Possible values**:
  - `idle`: Initial state.
  - `pending`: Mutation is actively running.
  - `error`: Last attempt failed.
  - `success`: Last attempt succeeded.

#### `isIdle: boolean`
- **Description**: `true` if `status` is `idle`.

#### `isPending: boolean`
- **Description**: `true` if `status` is `pending`.

#### `isSuccess: boolean`
- **Description**: `true` if `status` is `success`.

#### `isError: boolean`
- **Description**: `true` if `status` is `error`.

#### `isPaused: boolean`
- **Description**: `true` if the mutation is paused (e.g., due to network conditions). See [Network Mode](../../guides/network-mode.md).

#### `data: undefined | unknown`
- **Description**: The data from the most recent successful mutation.

#### `error: null | TError`
- **Description**: The error object if the mutation failed.

#### `reset: () => void`
- **Description**: Resets the mutation's internal state to its initial condition.
- **Returns**: `void`

#### `failureCount: number`
- **Description**: Counts consecutive failures. Resets on success.

#### `failureReason: null | TError`
- **Description**: The error object for the last failure. Resets on success.

#### `submittedAt: number`
- **Description**: Unix timestamp when the mutation was submitted.

#### `variables: undefined | TVariables`
- **Description**: The `variables` object passed to the `mutationFn` for the current or last mutation.
```

--------------------------------

### Implement Dependent Queries with TanStack `useQuery`

Source: https://tanstack.com/query/v5/docs/framework/react/guides/dependent-queries

This example demonstrates how to chain two `useQuery` hooks so that the second query, which fetches a user's projects, only executes after the first query successfully retrieves the user's data. The `enabled` option is used to conditionally run the `projects` query, ensuring `userId` is available. It illustrates the `status` and `fetchStatus` transitions during the query lifecycle.

```tsx
// Get the user
const { data: user } = useQuery({
  queryKey: ['user', email],
  queryFn: getUserByEmail,
})

const userId = user?.id

// Then get the user's projects
const {
  status,
  fetchStatus,
  data: projects,
} = useQuery({
  queryKey: ['projects', userId],
  queryFn: getProjectsByUser,
  // The query will not execute until the userId exists
  enabled: !!userId,
})
```

--------------------------------

### Correct useMutation() property order in React Query

Source: https://tanstack.com/query/v5/docs/eslint/mutation-property-order

Example demonstrating correct property ordering in useMutation() configuration with onMutate, onError, and onSettled in the required sequence. This ordering ensures proper TypeScript type inference and passes the @tanstack/query/mutation-property-order ESLint rule.

```tsx
/* eslint "@tanstack/query/mutation-property-order": "warn" */
import { useMutation } from '@tanstack/react-query'

const mutation = useMutation({
  mutationFn: () => Promise.resolve('success'),
  onMutate: async () => {
    results.push('onMutate-async')
    await sleep(1)
    return { backup: 'async-data' }
  },
  onError: async () => {
    results.push('onError-async-start')
    await sleep(1)
    results.push('onError-async-end')
  },
  onSettled: () => {
    results.push('onSettled-promise')
    return Promise.resolve('also-ignored') // Promise<string> (should be ignored)
  },
})
```

--------------------------------

### TanStack Query: Basic Data Fetching and Caching with injectQuery

Source: https://tanstack.com/query/v5/docs/framework/angular/guides/caching

This snippet demonstrates the basic usage of `injectQuery` in TanStack Query to fetch and cache data. It defines a `queryKey` (`['todos']`) to uniquely identify the cached data and a `queryFn` (`fetchTodos`) to perform the actual asynchronous data fetching. The framework uses this configuration to manage data lifecycle, enabling immediate cache retrieval for subsequent identical queries and orchestrating background refetching based on `staleTime` and `gcTime` defaults.

```typescript
injectQuery(() => ({
  queryKey: ['todos'],
  queryFn: fetchTodos
}))
```

--------------------------------

### Setup useMutation with onSettled for UI-based Optimistic Updates

Source: https://tanstack.com/query/v5/docs/framework/react/guides/optimistic-updates

Configures a mutation using useMutation hook with onSettled callback to invalidate queries after mutation completes. The mutation returns a Promise and exposes variables, isPending, and isError states for UI integration without direct cache manipulation.

```tsx
const addTodoMutation = useMutation({
  mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
  // make sure to _return_ the Promise from the query invalidation
  // so that the mutation stays in `pending` state until the refetch is finished
  onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
})

const { isPending, submittedAt, variables, mutate, isError } = addTodoMutation
```

--------------------------------

### Fetch and Cache Infinite Query Data (TanStack React Query)

Source: https://tanstack.com/query/v5/docs/reference/QueryClient

This example showcases `queryClient.fetchInfiniteQuery` for fetching and caching infinite or paginated data, similar to `fetchQuery`. It retrieves data for an infinite query, and the `data.pages` property can be accessed to view the fetched pages, with error handling implemented.

```tsx
try {
  const data = await queryClient.fetchInfiniteQuery({ queryKey, queryFn })
  console.log(data.pages)
} catch (error) {
  console.log(error)
}
```

--------------------------------

### Use Query with Placeholder Data as Value

Source: https://tanstack.com/query/v5/docs/framework/vue/guides/placeholder-query-data

Configure a query with static placeholder data using the placeholderData option. The query starts in success state with the provided placeholder data while the actual data is fetched in the background. This is useful for prepopulating cache with partial data that should not persist.

```tsx
const result = useQuery({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  placeholderData: placeholderTodos,
})
```

--------------------------------

### Specifying Custom Error Type in TanStack Query `useQuery`

Source: https://tanstack.com/query/v5/docs/framework/solid/typescript

This example illustrates how to explicitly define a custom error type (e.g., `string`) for the `useQuery` hook using generics. It highlights that directly specifying custom error types might affect other type inferences for `useQuery`.

```tsx
const query = useQuery<Group[], string>(() => ({
  queryKey: ['groups'],
  queryFn: fetchGroups,
}))

query.error
//    ^? (property) error: string | null
```

--------------------------------

### Configure TanStack Query Prefetching with staleTime and Rerender

Source: https://tanstack.com/query/v5/docs/framework/react/examples/prefetching

This snippet illustrates configuring `staleTime` for a TanStack Query prefetch operation. It ensures the data is only prefetched if it's older than 10 seconds. Following the prefetch attempt, a `setTimeout` triggers a component rerender to update the UI.

```javascript
staleTime: 10 * 1000, // only prefetch if older than 10 seconds
                  })

                  setTimeout(() => {
                    rerender({})
                  }, 1)
```

--------------------------------

### Exponential Backoff Retry Strategy

Source: https://tanstack.com/query/v5/docs/framework/solid/reference/useMutation

Example retry delay function implementing exponential backoff for mutation retry attempts. This strategy increases the delay exponentially between retries with a maximum cap of 30 seconds, useful for handling rate-limited or temporarily unavailable APIs.

```typescript
retryDelay: (attempt) => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000)
```

--------------------------------

### Set Custom Batching Function with notifyManager

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-v5

Configure a custom batching function for TanStack Query using notifyManager.setBatchNotifyFunction(). This example demonstrates how solid-query sets its batch function. The unstable_batchedUpdates is no longer automatically used as the default batching function in React 18.

```typescript
import { notifyManager } from '@tanstack/query-core'
import { batch } from 'solid-js'

notifyManager.setBatchNotifyFunction(batch)
```

--------------------------------

### Global State Before TanStack Query Migration

Source: https://tanstack.com/query/v5/docs/framework/angular/guides/does-this-replace-client-state

Example showing a global state object managing both server-state and client-state properties. The state contains server-state items (projects, teams, tasks, users) that could be managed by TanStack Query, mixed with client-only state (themeMode, sidebarStatus). This demonstrates typical state management before optimization.

```typescript
const globalState = {
  projects,
  teams,
  tasks,
  users,
  themeMode,
  sidebarStatus,
}
```

--------------------------------

### Leveraging `queryOptions` for `getQueryData` Type Inference

Source: https://tanstack.com/query/v5/docs/framework/solid/typescript

Building on the `queryOptions` helper, this example shows how `queryKey` produced by `queryOptions` carries type information from its associated `queryFn`. This enables `queryClient.getQueryData` to infer the correct data type (e.g., `Group[] | undefined`) without needing explicit generics, improving type safety.

```ts
function groupOptions() {
  return queryOptions({
    queryKey: ['groups'],
    queryFn: fetchGroups,
    staleTime: 5 * 1000,
  })
}

const data = queryClient.getQueryData(queryOptions().queryKey)
//    ^? const data: Group[] | undefined
```

--------------------------------

### useMutationState Hook Reference

Source: https://tanstack.com/query/v5/docs/framework/solid/reference/useMutationState

Complete reference documentation for the useMutationState hook including all available options, parameters, and return types for working with mutations in the MutationCache.

```APIDOC
## useMutationState - Hook Reference

### Description
A TanStack Query hook that provides access to all mutations in the MutationCache. Supports filtering mutations and transforming their state for various use cases.

### Hook Signature
```typescript
useMutationState<TResult = Mutation>(
  options?: {
    filters?: MutationFilters
    select?: (mutation: Mutation) => TResult
    queryClient?: QueryClient
  }
): Array<TResult>
```

### Options
- **filters** (MutationFilters) - Optional - Filter mutations by status, mutationKey, or other criteria. See Mutation Filters documentation for details.
- **select** (function) - Optional - Transformation function that receives a Mutation object and returns TResult. Use this to extract specific data from mutation state.
- **queryClient** (QueryClient) - Optional - Custom QueryClient instance. If not provided, uses the QueryClient from the nearest context.

### Returns
- **Array<TResult>** - Array of transformed values returned by the select function for each mutation matching the filter criteria. Empty array if no mutations match the filters.

### Notes
- Each invocation of mutate adds a new entry to the mutation cache
- Cache entries persist for the duration specified by gcTime (garbage collection time)
- To access the latest mutation data, use the last item in the returned array: `data[data.length - 1]`
- The mutationKey in filters must match the mutationKey of the mutation you want to track
```

--------------------------------

### Handle and Throw Errors in TanStack Query Functions (TypeScript/JavaScript)

Source: https://tanstack.com/query/v5/docs/framework/solid/guides/query-functions

This example illustrates how TanStack Query expects errors to be handled within query functions. It demonstrates throwing an `Error` directly or returning a `Promise.reject` to signal an error state, ensuring the query's `error` property is populated.

```tsx
const { error } = useQuery(() => {
  queryKey: ['todos', todoId],
  queryFn: async () => {
    if (somethingGoesWrong) {
      throw new Error('Oh no!')
    }
    if (somethingElseGoesWrong) {
      return Promise.reject(new Error('Oh no!'))
    }

    return data
  },
})
```

--------------------------------

### Get cached query data synchronously - TypeScript (TSX)

Source: https://tanstack.com/query/v5/docs/reference/QueryClient

Retrieve cached data for an existing query synchronously from the QueryClient. Depends on a QueryClient and a queryKey. Returns the cached data (TQueryFnData) or undefined if the query does not exist; does not trigger any fetches.

```tsx
const data = queryClient.getQueryData(queryKey)
```

--------------------------------

### Enable Vue Query Devtools (TypeScript)

Source: https://tanstack.com/query/v5/docs/framework/vue/devtools

Registers the VueQueryPlugin with the Vue application and enables the v6 devtools plugin. Requires a Vue app instance and the VueQueryPlugin import. Output is the plugin registered on the app; there are no return values. Limitation: this example toggles the v6 plugin flag only; both v6 and v7 devtools are supported by the library.

```ts
app.use(VueQueryPlugin, {
  enableDevtoolsV6Plugin: true,
})
```

--------------------------------

### Fetch Single Post with TanStack Query Hook in React

Source: https://tanstack.com/query/v5/docs/framework/react/examples/basic

A custom React hook `usePost` that uses TanStack Query's `useQuery` to fetch a single post by its `postId`. The `queryKey` is `['post', postId]`, and fetching is conditionally enabled only when `postId` is truthy, preventing unnecessary requests when no post is selected.

```typescript
function usePost(postId: number) {
  return useQuery({
    queryKey: ['post', postId],
    queryFn: () => getPostById(postId),
    enabled: !!postId,
  })
}
```

--------------------------------

### Replace `useQuery().remove()` with `queryClient.removeQueries()` in TanStack Query v5

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-v5

The `remove` method has been deprecated and removed from `useQuery` in TanStack Query v5. This example demonstrates how to update existing code to use `queryClient.removeQueries({ queryKey })`, which is the recommended method for imperatively removing queries from the cache.

```tsx
const queryClient = useQueryClient()
const query = useQuery({ queryKey, queryFn })

query.remove() // [!code --]
queryClient.removeQueries({ queryKey }) // [!code ++]
```

--------------------------------

### Conditional Rendering Based on Query Status

Source: https://tanstack.com/query/v5/docs/framework/react/examples/auto-refetching

Renders different UI elements based on query status (pending, error, or success). Shows loading message during pending state, error message with details if query fails, and renders data list on success.

```typescript
if (status === 'pending') return <h1>Loading...</h1>
if (status === 'error') return <span>Error: {error.message}</span>

return (
  <div>
    <h1>Auto Refetch with stale-time set to {intervalMs}ms</h1>
    <ul>
      {data.map((item) => (
        <li key={item}>{item}</li>
      ))}
    </ul>
  </div>
)
```

--------------------------------

### Reactive `useQuery` with Dynamic `enabled` Option (Vue/TS)

Source: https://tanstack.com/query/v5/docs/framework/vue/reactivity

This `useQuery` example showcases how to use a reactive getter for the `enabled` option, controlling query fetching based on derived state. The `queryKey` also dynamically includes `userId`, ensuring the query reacts to changes in `userId` and fetches only when `userId` matches `activeUserId`.

```ts
export function useUserProjects(userId: MaybeRef<string>) {
  return useQuery(
    queryKey: ['userProjects', userId],
    queryFn: () => api.fetchUserProjects(toValue(userId)),
    enabled: () => userId.value === activeUserId.value,
  );
}
```

--------------------------------

### Provide Placeholder Data as a Function in TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/react/guides/placeholder-query-data

This example illustrates using a function to supply `placeholderData`, allowing access to `previousData` and `previousQuery`. This is particularly useful for paginated queries or transitions, enabling the display of 'old' data immediately when `queryKey` changes, thus avoiding loading spinners.

```tsx
const result = useQuery({
  queryKey: ['todos', id],
  queryFn: () => fetch(`/todos/${id}`),
  placeholderData: (previousData, previousQuery) => previousData,
})
```

--------------------------------

### Allowable TanStack QueryClient Creation in Async Server Component

Source: https://tanstack.com/query/v5/docs/eslint/stable-query-client

This example showcases an exception where instantiating `QueryClient` inside an `async` Server Component is permissible. Since Server Components are executed only once per request on the server, creating a new `QueryClient` within them does not violate the principle of a single, stable instance for that specific server-side operation.

```tsx
async function App() {
  const queryClient = new QueryClient()
  await queryClient.prefetchQuery(options)
}
```

--------------------------------

### Disable TanStack Query window focus refetching globally (Vue.js)

Source: https://tanstack.com/query/v5/docs/framework/vue/guides/window-focus-refetching

This code demonstrates how to disable automatic data refetching when the window regains focus across your entire TanStack Query application. It configures `refetchOnWindowFocus: false` within the `defaultOptions` for queries in the `VueQueryPlugin` setup.

```js
const vueQueryPluginOptions: VueQueryPluginOptions = {
  queryClientConfig: {
    defaultOptions: {
      queries: {
        refetchOnWindowFocus: false,
      },
    },
  },
}
app.use(VueQueryPlugin, vueQueryPluginOptions)
```

--------------------------------

### Import devtools from react-query/devtools (TSX)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-react-query-3

Devtools are included in the main package and can be imported from react-query/devtools instead of a separate package. This is a simple import change; include the component in your React tree to enable query debugging UI. No additional dependencies beyond the react-query package are required.

```tsx
import { ReactQueryDevtools } from 'react-query/devtools'
```

--------------------------------

### Invalidate Queries by Key Prefix in TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/react/guides/query-invalidation

Illustrates how to invalidate multiple queries sharing a common key prefix using `invalidateQueries({ queryKey: ['todos'] })`. This will mark all queries starting with `['todos']` as stale, regardless of additional subkeys or variables, and refetch them if currently rendered.

```tsx
import { useQuery, useQueryClient } from '@tanstack/react-query'

// Get QueryClient from the context
const queryClient = useQueryClient()

queryClient.invalidateQueries({ queryKey: ['todos'] })

// Both queries below will be invalidated
const todoListQuery = useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodoList,
})
const todoListQuery = useQuery({
  queryKey: ['todos', { page: 1 }],
  queryFn: fetchTodoList,
})
```

--------------------------------

### Access Query Keys in Query Functions for Data Fetching (TypeScript/JavaScript)

Source: https://tanstack.com/query/v5/docs/framework/solid/guides/query-functions

This example demonstrates how to access the `queryKey` within a query function, which is useful for extracting parameters needed for data fetching. It shows a common pattern where a component defines the `queryKey` and a separate `fetchTodoList` function uses it to filter or paginate data.

```tsx
function Todos({ status, page }) {
  const result = useQuery(() => {
    queryKey: ['todos', { status, page }],
    queryFn: fetchTodoList,
  })
}

// Access the key, status and page variables in your query function!
function fetchTodoList({ queryKey }) {
  const [_key, { status, page }] = queryKey
  return new Promise()
}
```

--------------------------------

### Illustrate internal naming convention for custom QueryClient keys in TypeScript

Source: https://tanstack.com/query/v5/docs/framework/vue/guides/custom-client

This example visually explains how a custom `queryClientKey` is internally processed by Vue Query, appending it as a suffix to the default client key. While the user doesn't typically interact with this internal naming directly, it clarifies the mechanism behind key customization.

```tsx
const vueQueryPluginOptions: VueQueryPluginOptions = {
  queryClientKey: 'Foo',
}
app.use(VueQueryPlugin, vueQueryPluginOptions) // -> VUE_QUERY_CLIENT:Foo
```

--------------------------------

### Create Dependent useQuery with Enabled Option

Source: https://tanstack.com/query/v5/docs/framework/solid/guides/dependent-queries

Demonstrates how to create two dependent queries where the second query (projects) only executes after the first query (user) completes and provides a userId. Uses the enabled option to control when the second query runs. The example shows the state transitions from pending/idle to pending/fetching to success/idle as data becomes available.

```typescript
// Get the user
const { data: user } = useQuery(() => {
  queryKey: ['user', email],
  queryFn: getUserByEmail,
})

const userId = user?.id

// Then get the user's projects
const {
  status,
  fetchStatus,
  data: projects,
} = useQuery(() => {
  queryKey: ['projects', userId],
  queryFn: getProjectsByUser,
  // The query will not execute until the userId exists
  enabled: !!userId,
})
```

--------------------------------

### Handling Mutations with Async/Await using mutateAsync in TypeScript

Source: https://tanstack.com/query/v5/docs/framework/angular/guides/mutations

Demonstrates the use of `mutateAsync` instead of `mutate` to get a Promise that resolves on success or rejects on error. This allows for composing side effects using standard async/await syntax, providing a more imperative control flow for mutation outcomes.

```ts
mutation = injectMutation(() => ({ mutationFn: addTodo }))

try {
  const todo = await mutation.mutateAsync(todo)
  console.log(todo)
} catch (error) {
  console.error(error)
} finally {
  console.log('done')
}
```

--------------------------------

### Inferring Types with select Option in Solid Query (TSX)

Source: https://tanstack.com/query/v5/docs/framework/solid/typescript

This example showcases type inference when using the `select` option with `useQuery`. The `select` function transforms the query's raw data (a number) into a string, and Solid Query correctly infers `query.data` as `string | undefined` based on the transformation.

```tsx
import { useQuery } from '@tanstack/solid-query'

const query = useQuery(() => ({
  queryKey: ['test'],
  queryFn: () => Promise.resolve(5),
  select: (data) => data.toString(),
}))

query.data
//    ^? (property) data: string | undefined
```

--------------------------------

### Await Asynchronous TanStack Query Mutation Callbacks (TSX)

Source: https://tanstack.com/query/v5/docs/framework/vue/guides/mutations

This example illustrates how TanStack Query handles asynchronous operations within mutation callbacks. If a callback function (like `onSuccess` or `onSettled`) returns a Promise, the system will await its resolution before proceeding to execute the next callback in the mutation lifecycle chain.

```tsx
useMutation({
  mutationFn: addTodo,
  onSuccess: async () => {
    console.log("I'm first!")
  },
  onSettled: async () => {
    console.log("I'm second!")
  },
})
```

--------------------------------

### Vue Query Devtools Floating Mode Setup

Source: https://tanstack.com/query/v5/docs/framework/vue/devtools

Implement floating mode devtools as a fixed element in your Vue 3 app with a toggleable panel. The component should be placed near the root of your application for optimal functionality, and automatically stores toggle state in localStorage.

```vue
<script setup>
import { VueQueryDevtools } from '@tanstack/vue-query-devtools'
</script>

<template>
  <h1>The app!</h1>
  <VueQueryDevtools />
</template>
```

--------------------------------

### Consolidated Error/Success Handling with TanStack Query onSettled

Source: https://tanstack.com/query/v5/docs/framework/solid/guides/optimistic-updates

This `tsx` example illustrates an alternative approach to handling mutation results using the `onSettled` callback in TanStack Query's `useMutation`. Instead of separate `onError` and `onSuccess` handlers, `onSettled` allows for a single function to manage both success and failure scenarios based on the `error` parameter, providing a more concise way to react to the mutation's final state.

```tsx
useMutation(() => {
  mutationFn: updateTodo,
  // ...
  onSettled: async (newTodo, error, variables, onMutateResult, context) => {
    if (error) {
      // do something
    }
  },
})
```

--------------------------------

### Manual Parallel Queries with useQuery - Vue

Source: https://tanstack.com/query/v5/docs/framework/vue/guides/parallel-queries

Execute multiple independent queries in parallel by using multiple useQuery hooks side-by-side in a Vue component. This approach works when the number of queries is static and known at component setup time. Each query executes concurrently with its own query key and fetch function.

```vue
<script setup lang="ts">
// The following queries will execute in parallel
const usersQuery = useQuery({ queryKey: ['users'], queryFn: fetchUsers })
const teamsQuery = useQuery({ queryKey: ['teams'], queryFn: fetchTeams })
const projectsQuery = useQuery({
  queryKey: ['projects'],
  queryFn: fetchProjects,
})
</script>
```

--------------------------------

### Create and subscribe to a QueryObserver (TSX)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-react-query-3

Instantiate a QueryObserver to create or watch a single query outside of React hooks. Depends on a QueryClient instance and a query option object; subscribe returns an unsubscribe function and invokes the callback with query results. Useful for non-React environments or advanced subscription control.

```tsx
const observer = new QueryObserver(queryClient, { queryKey: 'posts' })

const unsubscribe = observer.subscribe((result) => {
  console.log(result)
  unsubscribe()
})
```

--------------------------------

### Access Mutation State Across Components in Angular Query

Source: https://tanstack.com/query/v5/docs/framework/angular/guides/optimistic-updates

This example illustrates how to define a mutation with a `mutationKey` and then access its state, specifically pending variables, from a different component using `injectMutationState`. This enables showing optimistic updates for mutations that don't live in the same component as the UI displaying them.

```ts
// somewhere in your app
addTodo = injectMutation(() => ({
  mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
  onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
  mutationKey: ['addTodo'],
}))
```

```ts
// access variables somewhere else

mutationState = injectMutationState<string>(() => ({
  filters: { mutationKey: ['addTodo'], status: 'pending' },
  select: (mutation) => mutation.state.variables,
}))
```

--------------------------------

### Vue Query Devtools Embedded Mode Setup

Source: https://tanstack.com/query/v5/docs/framework/vue/devtools

Implement embedded mode devtools as a fixed panel within your Vue 3 application with manual toggle control. This approach allows you to integrate the devtools panel into your own development interface with custom toggle functionality.

```vue
<script setup>
import { VueQueryDevtoolsPanel } from '@tanstack/vue-query-devtools'
const isDevtoolsOpen = ref(false)
function toggleDevtools() {
  isDevtoolsOpen.value = !isDevtoolsOpen.value
}
</script>

<template>
  <h1>The app!</h1>
  <button @click="toggleDevtools">Open Devtools</button>
  <VueQueryDevtoolsPanel v-if="isDevtoolsOpen" :onClose="toggleDevtools" />
</template>
```

--------------------------------

### Placeholder Data as Value - TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/solid/guides/placeholder-query-data

Demonstrates how to pass a static placeholder data value to a useQuery hook. The query will start in success state with placeholder data displayed while the actual fetch completes. Use this approach when you have simple, pre-computed placeholder data that doesn't need to change between renders.

```tsx
function Todos() {
  const result = useQuery(() => ({
    queryKey: ['todos'],
    queryFn: () => fetch('/todos'),
    placeholderData: placeholderTodos,
  }))
}
```

--------------------------------

### Basic useQuery with initialData

Source: https://tanstack.com/query/v5/docs/framework/vue/guides/initial-query-data

Demonstrates how to prepopulate a query cache with initial data using the initialData option. This skips the initial loading state by providing data directly to the query configuration.

```typescript
const result = useQuery({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: initialTodos,
})
```

--------------------------------

### Todo Form with Optimistic Mutation Submission

Source: https://tanstack.com/query/v5/docs/framework/react/examples/optimistic-updates-ui

Provides a form input for creating new todos with submit handler that clears input and triggers addTodoMutation.mutate(). Button is disabled during pending mutation state. Demonstrates how to trigger mutations and manage local form state alongside server state.

```typescript
const [text, setText] = React.useState('')

return (
  <form
    onSubmit={(e) => {
      e.preventDefault()
      setText('')
      addTodoMutation.mutate(text)
    }}
  >
    <input
      type="text"
      onChange={(event) => setText(event.target.value)}
      value={text}
    />
    <button disabled={addTodoMutation.isPending}>Create</button>
  </form>
)
```

--------------------------------

### Configure Global Retry Delay with Exponential Backoff

Source: https://tanstack.com/query/v5/docs/framework/solid/guides/query-retries

Sets up exponential backoff retry delay globally for all queries via QueryClient defaultOptions. The default strategy doubles the delay with each attempt starting at 1000ms, with a maximum cap of 30 seconds. This is applied during QueryClientProvider initialization.

```typescript
import {
  QueryCache,
  QueryClient,
  QueryClientProvider,
} from '@tanstack/solid-query'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
    },
  },
})

function App() {
  return <QueryClientProvider client={queryClient}>...</QueryClientProvider>
}
```

--------------------------------

### Consume Vue-Query Composable with Wrapped Non-Reactive Value

Source: https://tanstack.com/query/v5/docs/framework/vue/reactivity

This TypeScript example shows an awkward usage of the corrected `useUserProjects` composable when a static value is desired. It forces wrapping the static string '1' in a `ref()` to satisfy the composable's `Ref<string>` type requirement, which is not ideal for non-reactive scenarios.

```typescript
const { data: projects } = useUserProjects(ref('1'))
```

--------------------------------

### Prefetch and Fetch Queries with QueryClient (React Query / TypeScript)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-react-query-3

Shows usage of QueryClient.prefetchQuery and QueryClient.fetchQuery for programmatic preloading or fetching outside of hooks. Dependency: react-query and a configured QueryClient. Inputs: query key and fetch function; Outputs: prefetchQuery returns a Promise that resolves when query is fetched (but not the data), while fetchQuery returns the data or throws on error. Limitation: handle errors with try/catch when using fetchQuery.

```tsx
// Prefetch a query:
await queryClient.prefetchQuery('posts', fetchPosts)

// Fetch a query:
try {
  const data = await queryClient.fetchQuery('posts', fetchPosts)
} catch (error) {
  // Error handling
}
```

--------------------------------

### TanStack Query `useQuery` with `initialData` and default `staleTime`

Source: https://tanstack.com/query/v5/docs/framework/solid/guides/initial-query-data

Illustrates the behavior of `initialData` when no `staleTime` is specified (default `staleTime: 0`). The query will immediately display `initialTodos` but will also trigger an immediate refetch after mounting, treating the initial data as fresh but instantly stale.

```tsx
// Will show initialTodos immediately, but also immediately refetch todos after mount
const result = useQuery(() => {
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: initialTodos,
})
```

--------------------------------

### Inferring Data Type with useQuery select Option in Vue Query

Source: https://tanstack.com/query/v5/docs/framework/vue/typescript

This example demonstrates type inference when the `select` option is used to transform the data. The `queryFn` returns a number, but the `select` function converts it to a string, resulting in `data` being inferred as `Ref<string> | Ref<undefined>`.

```tsx
const { data } = useQuery({
  //      ^? const data: Ref<string> | Ref<undefined>
  queryKey: ['test'],
  queryFn: () => Promise.resolve(5),
  select: (data) => data.toString(),
})
```

--------------------------------

### Cancel a scheduled interval using `timeoutManager.clearInterval` (TanStack Query)

Source: https://tanstack.com/query/v5/docs/reference/timeoutManager

This example illustrates how to stop a previously scheduled interval using `timeoutManager.clearInterval`. It takes the `intervalId` returned by `timeoutManager.setInterval` as an argument to halt its recurring execution. This is crucial for resource management and preventing unintended callback invocations when an interval is no longer required.

```tsx
import { timeoutManager } from '@tanstack/react-query'

const intervalId = timeoutManager.setInterval(
  () => console.log('ran at:', new Date()),
  1000,
)

timeoutManager.clearInterval(intervalId)
```

--------------------------------

### Solid Query `useQuery` Hook Structure and Options

Source: https://tanstack.com/query/v5/docs/framework/solid/reference/useQuery

This snippet illustrates the destructuring of the return object from the `useQuery` hook in TanStack Solid Query, along with the comprehensive list of configuration options available. It shows the various states, flags, and functions provided by the hook for managing query lifecycle and data. The options object defines the query's behavior, including caching, refetching, and error handling strategies.

```tsx
const {
  data,
  dataUpdatedAt,
  error,
  errorUpdatedAt,
  failureCount,
  failureReason,
  fetchStatus,
  isError,
  isFetched,
  isFetchedAfterMount,
  isFetching,
  isInitialLoading,
  isLoading,
  isLoadingError,
  isPaused,
  isPending,
  isPlaceholderData,
  isRefetchError,
  isRefetching,
  isStale,
  isSuccess,
  refetch,
  status,
} = useQuery(
  () => ({
    queryKey,
    queryFn,
    enabled,
    select,
    placeholderData,
    deferStream,
    reconcile,
    gcTime,
    networkMode,
    initialData,
    initialDataUpdatedAt,
    meta,
    queryKeyHashFn,
    refetchInterval,
    refetchIntervalInBackground,
    refetchOnMount,
    refetchOnReconnect,
    refetchOnWindowFocus,
    retry,
    retryOnMount,
    retryDelay,
    staleTime,
    throwOnError,
  }),
  () => queryClient,
)
```

--------------------------------

### React App Component with TanStack Query Error Handling

Source: https://tanstack.com/query/v5/docs/framework/react/examples/suspense

A React functional component that implements error boundary wrapping with QueryErrorResetBoundary, conditional Suspense rendering, and React Query Devtools. The component manages active project state and renders either a project details view or projects list based on state, with fallback UI during loading and error states.

```JSX
function App() {
  const [activeProject, setActiveProject] = useState()
  return (
    <>
      <QueryErrorResetBoundary>
        {({ reset }) => (
          <ErrorBoundary
            onReset={reset}
            fallbackRender={({ error, resetErrorBoundary }) => (
              <div>
                <p>Something went wrong:</p>
                <pre>{error.message}</pre>
                <button onClick={resetErrorBoundary}>Try again</button>
              </div>
            )}
          >
            <React.Suspense fallback={<div>Loading...</div>}>
              {activeProject ? (
                <ProjectDetails
                  activeProject={activeProject}
                  setActiveProject={setActiveProject}
                />
              ) : (
                <Projects setActiveProject={setActiveProject} />
              )}
            </React.Suspense>
          </ErrorBoundary>
        )}
      </QueryErrorResetBoundary>
      <ReactQueryDevtools initialIsOpen />
    </>
  )
}
```

--------------------------------

### Implementing Smooth Paginated Queries with `placeholderData` in TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/solid/guides/paginated-queries

This example demonstrates how to create smoother paginated queries using TanStack Query's `placeholderData` option, specifically `keepPreviousData`. It prevents the UI from 'jumping' by displaying the previously fetched data while new data for the next page is being loaded, improving user experience. It also shows how to manage page state and conditionally enable navigation buttons.

```tsx
import { keepPreviousData, useQuery } from '@tanstack/solid-query'
import React from 'react'

function Todos() {
  const [page, setPage] = React.useState(0)

  const fetchProjects = (page = 0) =>
    fetch('/api/projects?page=' + page).then((res) => res.json())

  const { isPending, isError, error, data, isFetching, isPlaceholderData } =
    useQuery(() => {
      queryKey: ['projects', page],
      queryFn: () => fetchProjects(page),
      placeholderData: keepPreviousData,
    })

  return (
    <div>
      {isPending ? (
        <div>Loading...</div>
      ) : isError ? (
        <div>Error: {error.message}</div>
      ) : (
        <div>
          {data.projects.map((project) => (
            <p key={project.id}>{project.name}</p>
          ))}
        </div>
      )}
      <span>Current Page: {page + 1}</span>
      <button
        onClick={() => setPage((old) => Math.max(old - 1, 0))}
        disabled={page === 0}
      >
        Previous Page
      </button>
      <button
        onClick={() => {
          if (!isPlaceholderData && data.hasMore) {
            setPage((old) => old + 1)
          }
        }}
        // Disable the Next Page button until we know a next page is available
        disabled={isPlaceholderData || !data?.hasMore}
      >
        Next Page
      </button>
      {isFetching ? <span> Loading...</span> : null}
    </div>
  )
}
```

--------------------------------

### Define mutation scope for serial execution in TSX

Source: https://tanstack.com/query/v5/docs/framework/vue/guides/mutations

This snippet demonstrates how to use the `scope` option with `useMutation` to ensure mutations with the same `id` run in serial. This prevents multiple instances of the same mutation from executing in parallel, queuing them instead. Subsequent mutations for the same scope will start in a `isPaused: true` state until their turn.

```tsx
const mutation = useMutation({
  mutationFn: addTodo,
  scope: {
    id: 'todo',
  },
})
```

--------------------------------

### Handle React Query states using `status` property

Source: https://tanstack.com/query/v5/docs/framework/react/guides/queries

This example demonstrates an alternative way to handle query states using the `status` string property (`'pending'`, `'error'`, `'success'`). It provides a clear, enum-like approach to conditional rendering based on the query's current state, which can sometimes be preferred over boolean flags.

```tsx
function Todos() {
  const { status, data, error } = useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodoList,
  })

  if (status === 'pending') {
    return <span>Loading...</span>
  }

  if (status === 'error') {
    return <span>Error: {error.message}</span>
  }

  // also status === 'success', but "else" logic works, too
  return (
    <ul>
      {data.map((todo) => (
        <li key={todo.id}>{todo.title}</li>
      ))}
    </ul>
  )
}
```

--------------------------------

### Set `initialData` from another query's cache in TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/solid/guides/initial-query-data

Illustrates how to derive `initialData` for a query from the cached results of another, related query. This example shows using `queryClient.getQueryData` to find a specific todo item from a cached list of todos to serve as initial data for an individual todo query.

```tsx
const result = useQuery(() => {
  queryKey: ['todo', todoId],
  queryFn: () => fetch('/todos'),
  initialData: () => {
    // Use a todo from the 'todos' query as the initial data for this todo query
    return queryClient.getQueryData(['todos'])?.find((d) => d.id === todoId)
  },
})
```

--------------------------------

### Inferring Data Type with useQuery in Vue Query

Source: https://tanstack.com/query/v5/docs/framework/vue/typescript

This snippet illustrates how Vue Query's `useQuery` hook automatically infers the data type based on the return value of the `queryFn`. In this example, a `Promise.resolve(5)` leads to `data` being inferred as `Ref<number> | Ref<undefined>`.

```tsx
const { data } = useQuery({
  //    ^? const data: Ref<number> | Ref<undefined>
  queryKey: ['test'],
  queryFn: () => Promise.resolve(5),
})
```

--------------------------------

### Render Paginated Data with React and TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/react/examples/pagination

This React functional component renders a list of projects from paginated data, providing 'Previous Page' and 'Next Page' buttons for navigation. It displays a loading indicator (`isFetching`) to signal background data fetches and uses `isPlaceholderData` to manage button states. The component depends on `data`, `page`, `setPage`, `isPlaceholderData`, and `isFetching` props or context from a TanStack Query hook.

```jsx
<div>
  {data.projects.map((project) => (
    <p key={project.id}>{project.name}</p>
  ))}
</div>
<div>Current Page: {page + 1}</div>
<button
  onClick={() => setPage((old) => Math.max(old - 1, 0))}
  disabled={page === 0}
>
  Previous Page
</button>{' '}
<button
  onClick={() => {
    setPage((old) => (data?.hasMore ? old + 1 : old))
  }}
  disabled={isPlaceholderData || !data?.hasMore}
>
  Next Page
</button>
{
  isFetching ? <span> Loading...</span> : null
}{' '}
<ReactQueryDevtools initialIsOpen />
```

--------------------------------

### Replace setConsole with setLogger for Custom Logging in React Query

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-react-query-3

The `setConsole()` function has been replaced by `setLogger()` to enable more flexible and custom error logging. This allows integration with various logging services like Sentry or Winston, providing tailored error handling beyond standard console output.

```tsx
import { setLogger } from 'react-query'

// Log with Sentry
setLogger({
  error: (error) => {
    Sentry.captureException(error)
  },
})

// Log with Winston
setLogger(winston.createLogger())
```

--------------------------------

### Apply Conditional Styling based on TanStack Query Cache Data

Source: https://tanstack.com/query/v5/docs/framework/react/examples/prefetching

This React snippet demonstrates applying inline CSS styling conditionally. It checks if specific character data exists in the TanStack Query cache using `queryClient.getQueryData`. If the data is present, the `fontWeight` is set to 'bold'; otherwise, no specific style is applied.

```javascript
queryClient.getQueryData(['character', char.id])
                      ? {
                          fontWeight: 'bold',
                        }
                      : {}
```

--------------------------------

### Prefetch data in Vue component using onServerPrefetch

Source: https://tanstack.com/query/v5/docs/framework/vue/guides/ssr

This Vue component example illustrates how to fetch data using `useQuery` and ensure it's prefetched on the server before the initial render. By calling `onServerPrefetch(suspense)`, the server waits for the query to resolve, thereby including the data in the initial HTML payload and avoiding a loading state on the client for the first render.

```html
<!-- MyComponent.vue -->
<template>
  <div>
    <button @click="refetch">Refetch</button>
    <p>{{ data }}</p>
  </div>
</template>

<script setup>
  import { useQuery } from '@tanstack/vue-query'
  import { onServerPrefetch } from 'vue'

  // This will be prefetched and sent from the server
  const { refetch, data, suspense } = useQuery({
    queryKey: ['todos'],
    queryFn: getTodos,
  })

  onServerPrefetch(suspense)
</script>
```

--------------------------------

### Assign React Query `useQuery` result to a variable

Source: https://tanstack.com/query/v5/docs/framework/react/guides/queries

This example shows how to capture the full result object returned by the `useQuery` hook. The `result` object contains various states and data properties for managing the query's lifecycle, which can then be destructured or accessed directly to determine the query's status and data.

```tsx
const result = useQuery({ queryKey: ['todos'], queryFn: fetchTodoList })
```

--------------------------------

### Add Todo with useMutation and Query Invalidation

Source: https://tanstack.com/query/v5/docs/framework/react/examples/playground

React component for adding a new todo using TanStack Query's useMutation hook with onSuccess callback for query invalidation. Manages local form state, disables inputs during mutation, and displays save status feedback. Invalidates the todos query to trigger automatic refetch of the list.

```TypeScript/React
function AddTodo() {
  const queryClient = useQueryClient()
  const [name, setName] = React.useState('')

  const addMutation = useMutation({
    mutationFn: postTodo,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['todos'] })
    },
  })

  return (
    <div>
      <input
        value={name}
        onChange={(e) => setName(e.target.value)}
        disabled={addMutation.status === 'pending'}
      />
      <button
        onClick={() => {
          addMutation.mutate({ name, notes: 'These are some notes' })
        }}
        disabled={addMutation.status === 'pending' || !name}
      >
        Add Todo
      </button>
      <div>
        {addMutation.status === 'pending'
          ? 'Saving...'
          : addMutation.status === 'error'
            ? addMutation.error.message
            : 'Saved!'}
      </div>
    </div>
  )
}
```

--------------------------------

### Fetch Multiple Queries Dynamically with useQueries (TypeScript)

Source: https://tanstack.com/query/v5/docs/framework/solid/reference/useQueries

Demonstrates how to use the `useQueries` hook to execute a dynamic list of queries based on an array of IDs. Each query is configured with its unique `queryKey`, a `queryFn` to fetch data, and a `staleTime` for caching.

```tsx
const ids = [1, 2, 3]
const results = useQueries(() => {
  queries: ids.map((id) => ({
    queryKey: ['post', id],
    queryFn: () => fetchPost(id),
    staleTime: Infinity,
  })),
})
```

--------------------------------

### Form submission with optimistic mutation in React/TypeScript

Source: https://tanstack.com/query/v5/docs/framework/react/examples/optimistic-updates-ui

Handles form submission for adding todos with mutation state tracking. The form prevents default behavior, clears input, and triggers the addTodoMutation with the text value. Button is disabled during pending mutation state.

```typescript
form
  onSubmit={(e) => {
    e.preventDefault()
    setText('')
    addTodoMutation.mutate(text)
  }}
>
  <input
    type="text"
    onChange={(event) => setText(event.target.value)}
    value={text}
  />
  <button disabled={addTodoMutation.isPending}>Create</button>
</form>
```

--------------------------------

### Basic Mutation Setup with TanStack React Query (TSX)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/invalidations-from-mutations

This snippet demonstrates a simple mutation using useMutation hook for posting a todo item. It requires @tanstack/react-query and assumes a postTodo function. The mutationFn takes no explicit inputs shown, outputs depend on the API, but no invalidation is included here.

```tsx
const mutation = useMutation({ mutationFn: postTodo })
```

--------------------------------

### Disable TanStack Query with enabled: false in React

Source: https://tanstack.com/query/v5/docs/framework/react/guides/disabling-queries

This example demonstrates how to permanently disable a TanStack Query using `enabled: false`. The query will not fetch automatically on mount or in the background but can be manually triggered using the `refetch` function. It initializes with `status === 'pending'` if no cached data exists.

```tsx
function Todos() {
  const { isLoading, isError, data, error, refetch, isFetching } = useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodoList,
    enabled: false,
  })

  return (
    <div>
      <button onClick={() => refetch()}>Fetch Todos</button>

      {data ? (
        <ul>
          {data.map((todo) => (
            <li key={todo.id}>{todo.title}</li>
          ))}
        </ul>
      ) : isError ? (
        <span>Error: {error.message}</span>
      ) : isLoading ? (
        <span>Loading...</span>
      ) : (
        <span>Not ready ...</span>
      )}

      <div>{isFetching ? 'Fetching...' : null}</div>
    </div>
  )
}
```

--------------------------------

### Set Custom Event Listener with focusManager.setEventListener

Source: https://tanstack.com/query/v5/docs/reference/focusManager

Sets a custom event listener for managing focus state changes. This example demonstrates listening to the visibilitychange event and properly cleaning up the event listener when a new handler is set. The function receives a handleFocus callback and should return an unsubscribe function.

```tsx
import { focusManager } from '@tanstack/react-query'

focusManager.setEventListener((handleFocus) => {
  // Listen to visibilitychange
  if (typeof window !== 'undefined' && window.addEventListener) {
    window.addEventListener('visibilitychange', handleFocus, false)
  }

  return () => {
    // Be sure to unsubscribe if a new handler is set
    window.removeEventListener('visibilitychange', handleFocus)
  }
})
```

--------------------------------

### Fetch Single Post by ID with TanStack Query in SolidJS

Source: https://tanstack.com/query/v5/docs/framework/solid/examples/basic

This snippet defines `getPostById` for fetching a single post from the API and `createPost`, a SolidJS hook using `useQuery`. The hook dynamically constructs a `queryKey` based on `postId` and includes an `enabled` option to prevent fetching when `postId` is invalid. This ensures efficient, conditional data fetching for individual post details.

```tsx
const getPostById = async (id: number): Promise<Post> => {
  const response = await fetch(
    `https://jsonplaceholder.typicode.com/posts/${id}`,
  )
  return await response.json()
}

function createPost(postId: number) {
  return useQuery(() => ({
    queryKey: ['post', postId],
    queryFn: () => getPostById(postId),
    enabled: !!postId,
  }))
}
```

--------------------------------

### Fetch Individual Post with Conditional Query - React TypeScript

Source: https://tanstack.com/query/v5/docs/framework/react/examples/default-query-function

Implements a Post component that fetches a single post using useQuery with the enabled option set conditionally. Demonstrates how to skip query execution based on state and display post details with background update status.

```typescript
function Post({
  postId,
  setPostId,
}: {
  postId: number
  setPostId: React.Dispatch<React.SetStateAction<number>>
}) {
  const { status, data, error, isFetching } = useQuery<Post>({
    queryKey: [`/posts/${postId}`],
    enabled: !!postId,
  })

  return (
    <div>
      <div>
        <a onClick={() => setPostId(-1)} href="#">
          Back
        </a>
      </div>
      {!postId || status === 'pending' ? (
        'Loading...'
      ) : status === 'error' ? (
        <span>Error: {error.message}</span>
      ) : (
        <>
          <h1>{data.title}</h1>
          <div>
            <p>{data.body}</p>
          </div>
          <div>{isFetching ? 'Background Updating...' : ' '}</div>
        </>
      )}
    </div>
  )
}
```

--------------------------------

### Integrating Axios (v0.22.0+) with AbortSignal for Query Cancellation in TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/solid/guides/query-cancellation

This example shows how to use the `signal` property from the TanStack Query function directly with Axios versions 0.22.0 and above. By passing the `signal` option to `axios.get`, network requests are automatically cancelled when the associated TanStack Query becomes inactive or is aborted.

```tsx
import axios from 'axios'

const query = useQuery(() => {
  queryKey: ['todos'],
  queryFn: ({ signal }) =>
    axios.get('/todos', {
      // Pass the signal to `axios`
      signal,
    }),
})
```

--------------------------------

### Define a custom React Query hook

Source: https://tanstack.com/query/v5/docs/framework/react/guides/testing

Creates a simple custom hook useCustomHook that uses useQuery to return a static string 'Hello'. Demonstrates basic hook definition.

```tsx
export function useCustomHook() {
  return useQuery({ queryKey: ['customHook'], queryFn: () => 'Hello' })
}
```

--------------------------------

### Reset TanStack Vue Query mutation state

Source: https://tanstack.com/query/v5/docs/framework/vue/guides/mutations

This example illustrates how to clear the `error` or `data` state of a `useMutation` hook using the `reset` function. It is particularly useful for scenarios where a user needs to dismiss an error message or retry an operation after a previous failure, effectively returning the mutation to an idle state.

```vue
<script>
import { useMutation } from '@tanstack/vue-query'

const { error, mutate, reset } = useMutation({
  mutationFn: (newTodo) => axios.post('/todos', newTodo),
})

function addTodo() {
  mutate({ id: new Date(), title: 'Do Laundry' })
}
</script>

<template>
  <span v-else-if="error">
    <span>An error occurred: {{ error.message }}</span>
    <button @click="reset">Reset error</button>
  </span>
  <button @click="addTodo">Create Todo</button>
</template>
```

--------------------------------

### Vue App Component with Composition API and State Management

Source: https://tanstack.com/query/v5/docs/framework/vue/examples/2

This Vue.js component (`App.vue`) uses the Composition API to manage application-wide state, specifically tracking visited post IDs and controlling the display of individual posts or a list of posts. It imports `Posts.vue` and `Post.vue` components and uses `ref` for reactive state, `Set` to store visited post IDs, and conditional rendering (`v-if`/`v-else`) to switch between views based on `postId`.

```vue
<script lang="ts">
import { defineComponent, ref } from '@vue/composition-api'

import Posts from './Posts.vue'
import Post from './Post.vue'

export default defineComponent({
  name: 'App',
  components: { Posts, Post },
  setup() {
    const visitedPosts = ref(new Set())
    const isVisited = (id: number) => visitedPosts.value.has(id)

    const postId = ref(-1)
    const setPostId = (id: number) => {
      visitedPosts.value.add(id)
      postId.value = id
    }

    return {
      isVisited,
      postId,
      setPostId,
    }
  },
})
</script>

<template>
  <div>
    <h1>Vue Query - Basic</h1>
    <p>
      As you visit the posts below, you will notice them in a loading state the
      first time you load them. However, after you return to this list and click
      on any posts you have already visited again, you will see them load
      instantly and background refresh right before your eyes!
      <strong>
        (You may need to throttle your network speed to simulate longer loading
        sequences)
      </strong>
    </p>
    <Post v-if="postId > -1" :postId="postId" @setPostId="setPostId" />
    <Posts v-else :isVisited="isVisited" @setPostId="setPostId" />
  </div>
</template>
```

--------------------------------

### Reverse Page Order in Infinite Query

Source: https://tanstack.com/query/v5/docs/framework/angular/guides/infinite-queries

Shows how to display infinite query pages in reversed order using the select option. The example demonstrates transforming the data structure to reverse both pages and pageParams arrays. Useful for chronological feeds where newest content should appear first, or any scenario requiring inverted page ordering.

```ts
query = injectInfiniteQuery(() => ({
  queryKey: ['projects'],
  queryFn: fetchProjects,
  select: (data) => ({
    pages: [...data.pages].reverse(),
    pageParams: [...data.pageParams].reverse(),
  }),
}))
```

--------------------------------

### useMutation Hook - Return Values

Source: https://tanstack.com/query/v5/docs/framework/solid/reference/useMutation

Detailed documentation of all return values from the useMutation hook, including mutation functions, status indicators, and state properties for complete mutation lifecycle management.

```APIDOC
## useMutation Hook - Return Values

### Description
The useMutation hook returns an object containing mutation functions, status indicators, and state properties for managing asynchronous mutations.

### Returns

#### mutate
- **Type**: `(variables: TVariables, { onSuccess, onSettled, onError }) => void`
- **Description**: The mutation function you can call with variables to trigger the mutation and optionally hook on additional callback options.

##### mutate Parameters
- **variables** (TVariables) - Optional - The variables object to pass to the `mutationFn`.
- **onSuccess** - Optional - This function will fire when the mutation is successful and will be passed the mutation's result. Void function, the returned value will be ignored.
  - Signature: `(data: TData, variables: TVariables, onMutateResult: TOnMutateResult | undefined, context: MutationFunctionContext) => void`
- **onError** - Optional - This function will fire if the mutation encounters an error and will be passed the error. Void function, the returned value will be ignored.
  - Signature: `(err: TError, variables: TVariables, onMutateResult: TOnMutateResult | undefined, context: MutationFunctionContext) => void`
- **onSettled** - Optional - This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error. Void function, the returned value will be ignored.
  - Signature: `(data: TData | undefined, error: TError | null, variables: TVariables, onMutateResult: TOnMutateResult | undefined, context: MutationFunctionContext) => void`

**Note**: If you make multiple requests, `onSuccess` will fire only after the latest call you've made.

#### mutateAsync
- **Type**: `(variables: TVariables, { onSuccess, onSettled, onError }) => Promise<TData>`
- **Description**: Similar to `mutate` but returns a promise which can be awaited.

#### status
- **Type**: `MutationStatus`
- **Description**: The current status of the mutation. Possible values:
  - `idle` - Initial status prior to the mutation function executing
  - `pending` - The mutation is currently executing
  - `error` - The last mutation attempt resulted in an error
  - `success` - The last mutation attempt was successful

#### Status Boolean Flags
- **isIdle** (boolean) - Derived from status, true when status is 'idle'
- **isPending** (boolean) - Derived from status, true when status is 'pending'
- **isSuccess** (boolean) - Derived from status, true when status is 'success'
- **isError** (boolean) - Derived from status, true when status is 'error'

#### isPaused
- **Type**: `boolean`
- **Description**: Will be `true` if the mutation has been paused. See Network Mode for more information.

#### data
- **Type**: `undefined | unknown`
- **Default**: `undefined`
- **Description**: The last successfully resolved data for the mutation.

#### error
- **Type**: `null | TError`
- **Description**: The error object for the query, if an error was encountered.

#### reset
- **Type**: `() => void`
- **Description**: A function to clean the mutation internal state (i.e., it resets the mutation to its initial state).

#### failureCount
- **Type**: `number`
- **Description**: The failure count for the mutation. Incremented every time the mutation fails. Reset to `0` when the mutation succeeds.

#### failureReason
- **Type**: `null | TError`
- **Description**: The failure reason for the mutation retry. Reset to `null` when the mutation succeeds.

#### submittedAt
- **Type**: `number`
- **Default**: `0`
- **Description**: The timestamp for when the mutation was submitted.

#### variables
- **Type**: `undefined | TVariables`
- **Default**: `undefined`
- **Description**: The `variables` object passed to the `mutationFn`.
```

--------------------------------

### TanStack Query: Conditionally Prefetch Dependent Data for Parallel Loading

Source: https://tanstack.com/query/v5/docs/framework/solid/guides/prefetching

This example shows how to use `queryClient.prefetchQuery` within the `queryFn` of a parent query to conditionally prefetch data for dependent items. This technique allows the code for the dependent component and its data to load in parallel, mitigating the request waterfall observed in the lazy-loading approach. A tradeoff is that the dependent query's code is bundled with the parent.

```tsx
function Feed() {
  const queryClient = useQueryClient()
  const { data, isPending } = useQuery(() => {
    queryKey: ['feed'],
    queryFn: async (...args) => {
      const feed = await getFeed(...args)

      for (const feedItem of feed) {
        if (feedItem.type === 'GRAPH') {
          queryClient.prefetchQuery({
            queryKey: ['graph', feedItem.id],
            queryFn: getGraphDataById,
          })
        }
      }

      return feed
    }
  })

  ...
}
```

--------------------------------

### Incorrectly Creating TanStack QueryClient in a React Component

Source: https://tanstack.com/query/v5/docs/eslint/stable-query-client

This example demonstrates an incorrect pattern where a new `QueryClient` instance is created inside a React functional component. This leads to instantiating a new client on every render, which is inefficient and violates the recommendation to maintain a single, stable `QueryClient` instance for the application's lifecycle, resulting in unstable behavior.

```tsx
/* eslint "@tanstack/query/stable-query-client": "error" */

function App() {
  const queryClient = new QueryClient()
  return (
    <QueryClientProvider client={queryClient}>
      <Home />
    </QueryClientProvider>
  )
}
```

--------------------------------

### Fetch Single Post with Conditional Query Execution

Source: https://tanstack.com/query/v5/docs/framework/react/examples/basic-graphql-request

Custom hook that fetches a single post by ID using TanStack Query's useQuery. Includes enabled option to conditionally execute the query only when postId is valid. Executes GraphQL query to retrieve full post details including body content.

```typescript
function usePost(postId: number) {
  return useQuery({
    queryKey: ['post', postId],
    queryFn: async () => {
      const { post } = await request<{ post: Post }>(endpoint, gql`
        query {
          post(id: ${postId}) {
            id
            title
            body
          }
        }
      `)
      return post
    },
    enabled: !!postId,
  })
}
```

--------------------------------

### Handle Mutation Outcome with TanStack Query onSettled Callback

Source: https://tanstack.com/query/v5/docs/framework/react/guides/optimistic-updates

This example demonstrates using the `onSettled` callback as a unified handler for a mutation's outcome, consolidating logic that would otherwise be split between `onError` and `onSuccess`. It allows for conditional processing based on whether an `error` occurred during the mutation.

```tsx
useMutation({
  mutationFn: updateTodo,
  // ...
  onSettled: async (newTodo, error, variables, onMutateResult, context) => {
    if (error) {
      // do something
    }
  },
})
```

--------------------------------

### Override Query Options with Select Function (TypeScript)

Source: https://tanstack.com/query/v5/docs/framework/solid/guides/query-options

This example illustrates how to override specific options at the component level, such as adding a `select` function to transform the query data. It shows that type inference remains intact, ensuring `query.data` reflects the return type of the `select` function rather than the original `queryFn`'s return type.

```ts
// Type inference still works, so query.data will be the return type of select instead of queryFn

const query = useQuery(() => {
  ...groupOptions(1),
  select: (data) => data.groupName,
})
```

--------------------------------

### Select query data using useQuery (TSX)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-react-query-3

Select or transform parts of a query result using the select option on useQuery. Depends on react-query; inputs are queryKey and queryFn, and output is the transformed data available as data. Note: use notifyOnChangeProps to limit re-renders when using select.

```tsx
import { useQuery } from 'react-query'

function User() {
  const { data } = useQuery(['user'], fetchUser, {
    select: (user) => user.username,
  })
  return <div>Username: {data}</div>
}
```

--------------------------------

### Create and configure query persister with QueryClient

Source: https://tanstack.com/query/v5/docs/framework/solid/plugins/createPersister

Initialize experimental_createQueryPersister with async storage backend and configure QueryClient with default persister options. Each query is lazily restored and persisted separately using query hash as key, respecting staleTime and enabling memory-efficient garbage collection.

```typescript
import AsyncStorage from '@react-native-async-storage/async-storage'
import { QueryClient } from '@tanstack/solid-query'
import { experimental_createQueryPersister } from '@tanstack/query-persist-client-core'

const persister = experimental_createQueryPersister({
  storage: AsyncStorage,
  maxAge: 1000 * 60 * 60 * 12, // 12 hours
})

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: 1000 * 30, // 30 seconds
      persister: persister.persisterFn,
    },
  },
})
```

--------------------------------

### Configure Default Query Function with TanStack Query (TypeScript/React)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/default-query-function

This example demonstrates how to set up a global default query function using `axios` within a TanStack Query application. It centralizes data fetching logic, allowing `useQuery` hooks to infer the `queryFn` from the `queryKey`, thereby reducing boilerplate. The default can be overridden by individual `useQuery` calls.

```tsx
// Define a default query function that will receive the query key
const defaultQueryFn = async ({ queryKey }) => {
  const { data } = await axios.get(
    `https://jsonplaceholder.typicode.com${queryKey[0]}`,
  )
  return data
}

// provide the default query function to your app with defaultOptions
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryFn: defaultQueryFn,
    },
  },
})

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <YourApp />
    </QueryClientProvider>
  )
}

// All you have to do now is pass a key!
function Posts() {
  const { status, data, error, isFetching } = useQuery({ queryKey: ['/posts'] })

  // ...
}

// You can even leave out the queryFn and just go straight into options
function Post({ postId }) {
  const { status, data, error, isFetching } = useQuery({
    queryKey: [`/posts/${postId}`],
    enabled: !!postId,
  })

  // ...
}
```

--------------------------------

### Correct TanStack Query: Returning data from query function

Source: https://tanstack.com/query/v5/docs/eslint/no-void-query-fn

This TypeScript example illustrates the correct implementation for `useQuery` where the `queryFn` fetches data asynchronously and explicitly returns it. By returning the `todos` variable, the data becomes available for caching and subsequent use, adhering to the `@tanstack/query/no-void-query-fn` ESLint rule.

```tsx
/* eslint "@tanstack/query/no-void-query-fn": "error" */
useQuery({
  queryKey: ['todos'],
  queryFn: async () => {
    const todos = await api.todos.fetch()
    return todos
  },
})
```

--------------------------------

### Subscribe to Online State Changes in TanStack Query

Source: https://tanstack.com/query/v5/docs/reference/onlineManager

This example shows how to subscribe to real-time changes in the application's online state using `onlineManager.subscribe`. The provided callback function will be invoked whenever the online status changes, receiving the new `isOnline` boolean value. The method returns an unsubscribe function to clean up the listener when no longer needed.

```tsx
import { onlineManager } from '@tanstack/react-query'

const unsubscribe = onlineManager.subscribe((isOnline) => {
  console.log('isOnline', isOnline)
})
```

--------------------------------

### Default Configuration Options

Source: https://tanstack.com/query/v5/docs/framework/react/plugins/createAsyncStoragePersister

Default configuration values for createAsyncStoragePersister including key, throttle time, and serialization methods

```tsx
{
  key = `REACT_QUERY_OFFLINE_CACHE`,
  throttleTime = 1000,
  serialize = JSON.stringify,
  deserialize = JSON.parse,
}
```

--------------------------------

### Set default options for specific queries via QueryClient (TSX)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-react-query-3

Configure default options for queries matching a queryKey using QueryClient.setQueryDefaults. After setting defaults, subsequent useQuery calls with the matching key will use the provided defaults unless overridden. Inputs are the query key matcher and defaults object; output is side-effect on the QueryClient configuration.

```tsx
queryClient.setQueryDefaults(['posts'], { queryFn: fetchPosts })

function Component() {
  const { data } = useQuery(['posts'])
}
```

--------------------------------

### React Component for Editing a Single Todo with TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/react/examples/playground

The `EditTodo` component enables users to modify details of a specific todo item. It uses `useQuery` to fetch the todo by its ID and `useMutation` to save changes to the backend. Upon successful mutation, it invalidates the 'todos' query and updates the specific 'todo' query data using `queryClient.invalidateQueries` and `queryClient.setQueryData`, respectively.

```typescript
function EditTodo({
  editingIndex,
  setEditingIndex,
}: {
  editingIndex: number
  setEditingIndex: React.Dispatch<React.SetStateAction<number | null>>
}) {
  const queryClient = useQueryClient()

  // Don't attempt to query until editingIndex is truthy
  const { status, data, isFetching, error, failureCount, refetch } = useQuery({
    queryKey: ['todo', { id: editingIndex }],
    queryFn: () => fetchTodoById({ id: editingIndex }),
  })

  const [todo, setTodo] = React.useState(data || {})

  React.useEffect(() => {
    if (editingIndex !== null && data) {
      setTodo(data)
    } else {
      setTodo({})
    }
  }, [data, editingIndex])

  const saveMutation = useMutation({
    mutationFn: patchTodo,
    onSuccess: (data) => {
      // Update `todos` and the individual todo queries when this mutation succeeds
      queryClient.invalidateQueries({ queryKey: ['todos'] })
      queryClient.setQueryData(['todo', { id: editingIndex }], data)
    },
  })

  const onSave = () => {
    saveMutation.mutate(todo)
  }

  const disableEditSave =
    status === 'pending' || saveMutation.status === 'pending'

  return (
    <div>
      <div>
        {data ? (
          <>
            <button onClick={() => setEditingIndex(null)}>Back</button> Editing
            Todo "{data.name}" (#
            {editingIndex})
          </>
        ) : null}
      </div>
      {status === 'pending' ? (
        <span>Loading... (Attempt: {failureCount + 1})</span>
      ) : error ? (
        <span>
          Error! <button onClick={() => refetch()}>Retry</button>
        </span>
      ) : (
        <>
          <label>
            Name:{' '}
            <input
              value={todo.name}
              onChange={(e) =>
                e.persist() ||
                setTodo((old) => ({ ...old, name: e.target.value }))
              }
              disabled={disableEditSave}
            />
          </label>
          <label>
            Notes:{' '}
            <input
              value={todo.notes}
              onChange={(e) =>
                e.persist() ||

```

--------------------------------

### Use initialData with useQuery in Remix loader

Source: https://tanstack.com/query/v5/docs/framework/react/guides/ssr

Loads posts via a Remix loader, returns them as JSON, and provides the data to useQuery using initialData. Demonstrates the same pattern as Next.js but adapted to Remix's data loading APIs.

```tsx
export async function loader() {
  const posts = await getPosts()
  return json({ posts })
}

function Posts() {
  const { posts } = useLoaderData<typeof loader>()

  const { data } = useQuery({
    queryKey: ['posts'],
    queryFn: getPosts,
    initialData: posts,
  })

  // ...
}
```

--------------------------------

### useIsFetching Hook Basic Usage - React Query

Source: https://tanstack.com/query/v5/docs/framework/react/reference/useIsFetching

Demonstrates how to use the useIsFetching hook to track query fetching status. The hook can be called without arguments to get the total count of fetching queries, or with a queryKey filter to track specific queries. It returns a number representing the count of queries currently in a fetching state.

```typescript
import { useIsFetching } from '@tanstack/react-query'

// How many queries are fetching?
const isFetching = useIsFetching()

// How many queries matching the posts prefix are fetching?
const isFetchingPosts = useIsFetching({ queryKey: ['posts'] })
```

--------------------------------

### Create query options for useQuery (TSX)

Source: https://tanstack.com/query/v5/docs/framework/react/reference/queryOptions

Demonstrates constructing a TanStack Query v5 options object using queryOptions. Passes queryKey and spreads remaining options; experimental_prefetchInRender is optional. The returned options can be used with useQuery or prefetchQuery.

```tsx
queryOptions({\n  queryKey,\n  ...options,\n})
```

--------------------------------

### Global State After TanStack Query Migration

Source: https://tanstack.com/query/v5/docs/framework/angular/guides/does-this-replace-client-state

Example showing the optimized global state object after migrating server-state to TanStack Query. The state now contains only client-only properties (themeMode, sidebarStatus), with server-state managed separately using TanStack Query's injectQuery and injectMutation functions. This results in cleaner, smaller client state.

```typescript
const globalState = {
  themeMode,
  sidebarStatus,
}
```

--------------------------------

### Cancel specific TanStack Query queries silently

Source: https://tanstack.com/query/v5/docs/framework/vue/guides/query-cancellation

This example shows how to use `queryClient.cancelQueries` to cancel queries matching a specific `queryKey`. By setting `silent: true`, `CancelledError` propagation to observers (like `onError` callbacks) and related notifications is suppressed, and the retry promise is returned instead of rejection.

```tsx
// Cancel specific queries silently
await queryClient.cancelQueries({ queryKey: ['posts'] }, { silent: true })
```

--------------------------------

### Calculate Page Param as Cursor for Infinite Query (TanStack Query)

Source: https://tanstack.com/query/v5/docs/framework/vue/guides/infinite-queries

This example illustrates how to implement infinite scrolling when the API does not provide explicit cursors. It uses `lastPageParam` and `firstPageParam` within `getNextPageParam` and `getPreviousPageParam` respectively, to calculate the next/previous page index based on the current page's parameter.

```tsx
return useInfiniteQuery({
  queryKey: ['projects'],
  queryFn: fetchProjects,
  initialPageParam: 0,
  getNextPageParam: (lastPage, allPages, lastPageParam) => {
    if (lastPage.length === 0) {
      return undefined
    }
    return lastPageParam + 1
  },
  getPreviousPageParam: (firstPage, allPages, firstPageParam) => {
    if (firstPageParam <= 1) {
      return undefined
    }
    return firstPageParam - 1
  },
})
```

--------------------------------

### Edit Todo with Conditional Query and Mutation

Source: https://tanstack.com/query/v5/docs/framework/react/examples/playground

React component for editing a single todo using TanStack Query's useQuery and useMutation hooks. Fetches todo data conditionally based on editingIndex, manages local state with useEffect synchronization, and handles save mutations with query invalidation. Disables inputs during loading/saving states and displays background refresh status.

```TypeScript/React
function EditTodo({
  editingIndex,
  setEditingIndex,
}: {
  editingIndex: number
  setEditingIndex: React.Dispatch<React.SetStateAction<number | null>>
}) {
  const queryClient = useQueryClient()

  const { status, data, isFetching, error, failureCount, refetch } = useQuery({
    queryKey: ['todo', { id: editingIndex }],
    queryFn: () => fetchTodoById({ id: editingIndex }),
  })

  const [todo, setTodo] = React.useState(data || {})

  React.useEffect(() => {
    if (editingIndex !== null && data) {
      setTodo(data)
    } else {
      setTodo({})
    }
  }, [data, editingIndex])

  const saveMutation = useMutation({
    mutationFn: patchTodo,
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ['todos'] })
      queryClient.setQueryData(['todo', { id: editingIndex }], data)
    },
  })

  const onSave = () => {
    saveMutation.mutate(todo)
  }

  const disableEditSave =
    status === 'pending' || saveMutation.status === 'pending'

  return (
    <div>
      <div>
        {data ? (
          <>
            <button onClick={() => setEditingIndex(null)}>Back</button> Editing
            Todo "{data.name}" (#
            {editingIndex})
          </>
        ) : null}
      </div>
      {status === 'pending' ? (
        <span>Loading... (Attempt: {failureCount + 1})</span>
      ) : error ? (
        <span>
          Error! <button onClick={() => refetch()}>Retry</button>
        </span>
      ) : (
        <>
          <label>
            Name:{' '}
            <input
              value={todo.name}
              onChange={(e) =>
                e.persist() ||
                setTodo((old) => ({ ...old, name: e.target.value }))
              }
              disabled={disableEditSave}
            />
          </label>
          <label>
            Notes:{' '}
            <input
              value={todo.notes}
              onChange={(e) =>
                e.persist() ||
                setTodo((old) => ({ ...old, notes: e.target.value }))
              }
              disabled={disableEditSave}
            />
          </label>
          <div>
            <button onClick={onSave} disabled={disableEditSave}>
              Save
            </button>
          </div>
          <div>
            {saveMutation.status === 'pending'
              ? 'Saving...'
              : saveMutation.status === 'error'
                ? saveMutation.error.message
                : 'Saved!'}
          </div>
          <div>
            {isFetching ? (
              <span>
                Background Refreshing... (Attempt: {failureCount + 1})
              </span>
            ) : (
              <span>&nbsp;</span>
            )}
          </div>
        </>
      )}
    </div>
  )
}
```

--------------------------------

### Cancel a TanStack Query with `silent` Option

Source: https://tanstack.com/query/v5/docs/framework/react/guides/query-cancellation

This example illustrates how to use cancellation options with `queryClient.cancelQueries` to control its behavior. Specifically, it demonstrates how to cancel queries for a given `queryKey` silently by setting `silent: true`. This prevents the propagation of `CancelledError` to observers and related notifications.

```tsx
// Cancel specific queries silently
await queryClient.cancelQueries({ queryKey: ['posts'] }, { silent: true })
```

--------------------------------

### Access Specific Mutation Data by Key using useMutationState (Vue Query)

Source: https://tanstack.com/query/v5/docs/framework/vue/reference/useMutationState

This example shows how to fetch the `data` property for mutations identified by a specific `mutationKey` using `useMutationState`. It first defines a `useMutation` with a `mutationKey` and then uses `useMutationState` to filter by that same `mutationKey` and select the `data` from the mutation's state.

```tsx
import { useMutation, useMutationState } from '@tanstack/vue-query'

const mutationKey = ['posts']

// Some mutation that we want to get the state for
const mutation = useMutation({
  mutationKey,
  mutationFn: (newPost) => {
    return axios.post('/posts', newPost)
  },
})

const data = useMutationState({
  // this mutation key needs to match the mutation key of the given mutation (see above)
  filters: { mutationKey },
  select: (mutation) => mutation.state.data,
})
```

--------------------------------

### Integrate Multiple TanStack Query Data Providers in React Application (TypeScript/React)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-react-query-4

This example demonstrates how to compose multiple `QueryClientProvider` instances, each configured with its own custom context, within a React application. It showcases nesting these providers to manage distinct data scopes and how custom hooks (`useUser`, `useItems`) automatically leverage the correct context to fetch data from their respective providers.

```tsx
// Our application

import { ContainerDataProvider, useUser } from "@my-scope/container-data";
import { AppDataProvider } from "@my-scope/app-data";
import { MyComponentDataProvider, useItems } from "@my-scope/my-component-data";

<ContainerDataProvider> // <-- Provides container data (like "user") using its own React Query provider
  ...
  <AppDataProvider> // <-- Provides app data using its own React Query provider (unused in this example)
    ...
      <MyComponentDataProvider> // <-- Provides component data (like "items") using its own React Query provider
        <MyComponent />
      </MyComponentDataProvider>
    ...
  </AppDataProvider>
  ...
</ContainerDataProvider>

// Example of hooks provided by the "DataProvider" components above:
const MyComponent = () => {
  const user = useUser() // <-- Uses the context specified in ContainerDataProvider.
  const items = useItems() // <-- Uses the context specified in MyComponentDataProvider
  ...
}
```

--------------------------------

### Update React Query imports from react-query to @tanstack/react-query

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-react-query-4

Migration of import statements when upgrading from React Query v3 to v4. The package has been renamed to @tanstack/react-query and devtools moved to a separate @tanstack/react-query-devtools package. Run npm commands to uninstall old package and install new dependencies.

```bash
npm uninstall react-query
npm install @tanstack/react-query
npm install @tanstack/react-query-devtools
```

```tsx
- import { useQuery } from 'react-query'
- import { ReactQueryDevtools } from 'react-query/devtools'

+ import { useQuery } from '@tanstack/react-query'
+ import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
```

--------------------------------

### Conditional Rendering with Query States - TypeScript/React

Source: https://tanstack.com/query/v5/docs/framework/react/examples/optimistic-updates-cache

Renders different UI based on query states (isSuccess, isLoading, error). Displays formatted timestamp, todo list items, loading indicator, and error messages. Uses type narrowing with isSuccess check for safe data access.

```typescript
{queryInfo.isSuccess && (
  <>
    <div>
      Updated At: {new Date(queryInfo.data.ts).toLocaleTimeString()}
    </div>
    <ul>
      {queryInfo.data.items.map((todo) => (
        <li key={todo.id}>{todo.text}</li>
      ))}
    </ul>
    {isFetching && <div>Updating in background...</div>}
  </>
)}
{queryInfo.isLoading && 'Loading'}
{queryInfo.error instanceof Error && queryInfo.error.message}
```

--------------------------------

### Create QueriesObserver and Subscribe to Multiple Queries

Source: https://tanstack.com/query/v5/docs/reference/QueriesObserver

Initialize a QueriesObserver with a queryClient and array of query configurations, then subscribe to receive updates when any observed query changes. The subscribe method returns an unsubscribe function to stop listening for updates.

```typescript
const observer = new QueriesObserver(queryClient, [
  { queryKey: ['post', 1], queryFn: fetchPost },
  { queryKey: ['post', 2], queryFn: fetchPost },
])

const unsubscribe = observer.subscribe((result) => {
  console.log(result)
  unsubscribe()
})
```

--------------------------------

### Override query options with a select function in TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/react/guides/query-options

This TypeScript example illustrates how to extend or override predefined query options at the component level, specifically demonstrating the use of a `select` function. By spreading `groupOptions(1)`, the base query configuration is applied, and then a `select` function is added to transform the query data, showcasing how type inference is maintained for the transformed output.

```ts
// Type inference still works, so query.data will be the return type of select instead of queryFn

const query = useQuery({
  ...groupOptions(1),
  select: (data) => data.groupName,
})
```

--------------------------------

### React Chat Message Input Component with Tailwind CSS

Source: https://tanstack.com/query/v5/docs/framework/react/examples/chat

A reusable chat input UI component that captures user messages and submits them via button click or Enter key. Features a controlled input field with Tailwind styling, a disabled state for empty messages, and an inline SVG send icon. The component integrates with parent state management through currentQuestion state and submitMessage callback.

```jsx
<div className="flex items-center space-x-2">
  <input
    className="flex-1 p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-100"
    value={currentQuestion}
    onChange={(e) => setCurrentQuestion(e.target.value)}
    onKeyDown={(e) => {
      if (e.key === 'Enter') {
        submitMessage()
      }
    }}
    placeholder="Type your message..."
  />
  <button
    onClick={submitMessage}
    disabled={!currentQuestion.trim()}
    className="flex items-center gap-2 bg-blue-600 hover:bg-blue-700 text-white font-semibold px-4 py-2 rounded-2xl shadow-md transition"
  >
    <span>Send</span>
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"
    >
      <path d="M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z" />
      <path d="m21.854 2.147-10.94 10.939" />
    </svg>
  </button>
</div>
```

--------------------------------

### Placeholder Data Memoization - TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/solid/guides/placeholder-query-data

Shows how to memoize placeholder data generation using createMemo to avoid expensive computations on every render. This is useful when generating placeholder data requires significant processing or you want to optimize performance by ensuring the placeholder data is only generated once.

```tsx
function Todos() {
  const placeholderData = createMemo(() => generateFakeTodos(), [])
  const result = useQuery(() => ({
    queryKey: ['todos'],
    queryFn: () => fetch('/todos'),
    placeholderData,
  }))
}
```

--------------------------------

### Fetch data with useQuery().promise and React.use() in Suspense

Source: https://tanstack.com/query/v5/docs/framework/react/guides/suspense

This TypeScript/React example illustrates how to use the experimental `useQuery().promise` with React's `use()` hook to fetch data directly within a functional component. The parent `App` component defines the query, which is then passed to a child `TodoList` component. Data consumption is wrapped in `React.Suspense` to handle loading states, enabling efficient data fetching and rendering.

```tsx
import React from 'react'
import { useQuery } from '@tanstack/react-query'
import { fetchTodos, type Todo } from './api'

function TodoList({ query }: { query: UseQueryResult<Todo[]> }) {
  const data = React.use(query.promise)

  return (
    <ul>
      {data.map((todo) => (
        <li key={todo.id}>{todo.title}</li>
      ))}
    </ul>
  )
}

export function App() {
  const query = useQuery({ queryKey: ['todos'], queryFn: fetchTodos })

  return (
    <>
      <h1>Todos</h1>
      <React.Suspense fallback={<div>Loading...</div>}>
        <TodoList query={query} />
      </React.Suspense>
    </>
  )
}
```

--------------------------------

### Migrate `isDataEqual` to `structuralSharing` in TanStack Query v5

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-v5

The `isDataEqual` option has been removed in TanStack Query v5. This example shows how to achieve equivalent functionality by migrating to the `structuralSharing` option. It uses a custom comparison function and `replaceEqualDeep` to determine whether to retain old data or update with new data.

```tsx
import { replaceEqualDeep } from '@tanstack/react-query'

- isDataEqual: (oldData, newData) => customCheck(oldData, newData) // [!code --]
+ structuralSharing: (oldData, newData) => customCheck(oldData, newData) ? oldData : replaceEqualDeep(oldData, newData) // [!code ++]
```

--------------------------------

### Required `initialPageParam` for TanStack Query v5 Infinite Queries

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-v5

TanStack Query v5 infinite queries now explicitly require an `initialPageParam` in the options object. This change prevents non-serializable `undefined` values from being stored in the `queryCache` and ensures a clear starting point for pagination. The `queryFn` no longer needs a default value for `pageParam`.

```tsx
useInfiniteQuery({
   queryKey,
   queryFn: ({ pageParam }) => fetchSomething(pageParam),
   initialPageParam: 0,
   getNextPageParam: (lastPage) => lastPage.next,
})
```

--------------------------------

### Use mutateAsync for Promise-Based Mutation Handling in TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/react/guides/mutations

Demonstrates how to use `mutateAsync` instead of `mutate` to get a promise that resolves on success or rejects on error. This enables the use of `async/await` syntax for mutation handling, allowing for cleaner composition of side effects and structured error handling using `try...catch...finally` blocks.

```tsx
const mutation = useMutation({ mutationFn: addTodo })

try {
  const todo = await mutation.mutateAsync(todo)
  console.log(todo)
} catch (error) {
  console.error(error)
} finally {
  console.log('done')
}
```

--------------------------------

### Implement Smooth Paginated Queries with placeholderData in Angular (TanStack Query)

Source: https://tanstack.com/query/v5/docs/framework/angular/guides/paginated-queries

This Angular component demonstrates how to leverage `placeholderData` with `injectQuery` to create a smooth paginated experience. It ensures that the data from the last successful fetch remains visible while new data is being requested, preventing UI jumps. The example also includes prefetching logic to proactively load the next page, further enhancing responsiveness and user satisfaction.

```angular-ts
@Component({
  selector: 'pagination-example',
  template: `
    <div>
      <p>
        In this example, each page of data remains visible as the next page is
        fetched. The buttons and capability to proceed to the next page are also
        suppressed until the next page cursor is known. Each page is cached as a
        normal query too, so when going to previous pages, you'll see them
        instantaneously while they are also re-fetched invisibly in the
        background.
      </p>
      @if (query.status() === 'pending') {
        <div>Loading...</div>
      } @else if (query.status() === 'error') {
        <div>Error: {{ query.error().message }}</div>
      } @else {
        <!-- 'data' will either resolve to the latest page's data -->
        <!-- or if fetching a new page, the last successful page's data -->
        <div>
          @for (project of query.data().projects; track project.id) {
            <p>{{ project.name }}</p>
          }
        </div>
      }

      <div>Current Page: {{ page() + 1 }}</div>
      <button (click)="previousPage()" [disabled]="page() === 0">
        Previous Page
      </button>
      <button
        (click)="nextPage()"
        [disabled]="query.isPlaceholderData() || !query.data()?.hasMore"
      >
        Next Page
      </button>
      <!-- Since the last page's data potentially sticks around between page requests, -->
      <!-- we can use 'isFetching' to show a background loading -->
      <!-- indicator since our status === 'pending' state won't be triggered -->
      @if (query.isFetching()) {
        <span> Loading...</span>
      }
    </div>
  `,
})
export class PaginationExampleComponent {
  page = signal(0)
  queryClient = inject(QueryClient)

  query = injectQuery(() => ({
    queryKey: ['projects', this.page()],
    queryFn: () => lastValueFrom(fetchProjects(this.page())),
    placeholderData: keepPreviousData,
    staleTime: 5000,
  }))

  constructor() {
    effect(() => {
      // Prefetch the next page!
      if (!this.query.isPlaceholderData() && this.query.data()?.hasMore) {
        this.#queryClient.prefetchQuery({
          queryKey: ['projects', this.page() + 1],
          queryFn: () => lastValueFrom(fetchProjects(this.page() + 1)),
        })
      }
    })
  }

  previousPage() {
    this.page.update((old) => Math.max(old - 1, 0))
  }

  nextPage() {
    this.page.update((old) => (this.query.data()?.hasMore ? old + 1 : old))
  }
}
```

--------------------------------

### Dependent Nested Component Waterfall Example

Source: https://tanstack.com/query/v5/docs/framework/solid/guides/request-waterfalls

Illustrates a dependent waterfall where child components conditionally render based on parent data and require specific IDs from parent props to make their queries. The GraphFeedItem's query depends on both the parent's completion and the feedItem data, creating a sequential dependency chain that cannot be trivially flattened.

```typescript
function Feed() {
  const { data, isPending } = useQuery(() => {
    queryKey: ['feed'],
    queryFn: getFeed,
  })

  if (isPending) {
    return 'Loading feed...'
  }

  return (
    <>
      {data.map((feedItem) => {
        if (feedItem.type === 'GRAPH') {
          return <GraphFeedItem key={feedItem.id} feedItem={feedItem} />
        }

        return <StandardFeedItem key={feedItem.id} feedItem={feedItem} />
      })}
    </>
  )
}

function GraphFeedItem({ feedItem }) {
  const { data, isPending } = useQuery(() => {
    queryKey: ['graph', feedItem.id],
    queryFn: getGraphDataById,
  })

  ...
}
```

--------------------------------

### infiniteQueryOptions Function

Source: https://tanstack.com/query/v5/docs/framework/vue/reference/infiniteQueryOptions

Creates and returns configured options for infinite queries. This function accepts a queryKey and spreads additional options compatible with useInfiniteQuery. It enables type-safe query configuration for prefetching and other query client operations.

```APIDOC
## infiniteQueryOptions

### Description
Generates infinite query options for use with TanStack Query. Accepts a query key and configuration options compatible with useInfiniteQuery.

### Signature
```tsx
infiniteQueryOptions({
  queryKey,
  ...options,
})
```

### Parameters

#### Configuration Object
- **queryKey** (QueryKey) - Required - The unique key identifier for the infinite query. Used to manage query state and caching.
- **...options** (UseInfiniteQueryOptions) - Optional - Additional configuration options that can be passed to useInfiniteQuery. Excess properties are allowed for type safety even if not used in certain contexts.

### Options Details

All options compatible with `useInfiniteQuery` can be passed to `infiniteQueryOptions`. Common options include:
- Query function and initial page parameters
- Stale time and cache time configurations
- Retry and error handling settings
- Enabled/disabled state management
- Select and data transformation functions

**Note**: Some options may have no effect when forwarded to functions like `queryClient.prefetchInfiniteQuery`, but TypeScript will permit these properties without error.

### Usage Example
```tsx
const infinitePostsOptions = infiniteQueryOptions({
  queryKey: ['posts'],
  queryFn: ({ pageParam = 0 }) => fetchPosts(pageParam),
  getNextPageParam: (lastPage) => lastPage.nextCursor,
})

// Use with useInfiniteQuery
const { data, fetchNextPage } = useInfiniteQuery(infinitePostsOptions)

// Use with prefetching
queryClient.prefetchInfiniteQuery(infinitePostsOptions)
```

### Return Value
Returns a configured infinite query options object that can be passed to `useInfiniteQuery`, `queryClient.prefetchInfiniteQuery`, and other query client methods.

### Related Functions
- See [useInfiniteQuery](../useInfiniteQuery.md) for detailed information about available options and their behavior.
```

--------------------------------

### Get Current Online State with TanStack Query

Source: https://tanstack.com/query/v5/docs/reference/onlineManager

This code demonstrates how to retrieve the current online status managed by TanStack Query's `onlineManager` using the `isOnline()` method. It returns a boolean value indicating whether the application is currently considered online or offline. This is a straightforward way to query the network status at any point.

```tsx
const isOnline = onlineManager.isOnline()
```

--------------------------------

### Set Initial Data with `initialDataUpdatedAt` from Cache (TypeScript/TSX)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/initial-query-data

This example extends the `initialData` concept by also providing `initialDataUpdatedAt`. By passing the `dataUpdatedAt` timestamp of the source query (`todos` list) to the new query, TanStack Query can accurately determine the freshness of the initial data, preventing unnecessary immediate refetches without resorting to artificial `staleTime` settings.

```tsx
const result = useQuery({
  queryKey: ['todos', todoId],
  queryFn: () => fetch(`/todos/${todoId}`),
  initialData: () =>
    queryClient.getQueryData(['todos'])?.find((d) => d.id === todoId),
  initialDataUpdatedAt: () =>
    queryClient.getQueryState(['todos'])?.dataUpdatedAt,
})
```

--------------------------------

### Configure Devtools with Environment-Based Loading

Source: https://tanstack.com/query/v5/docs/framework/angular/devtools

Illustrates how to use Angular environment configurations to control devtools loading in development and production staging environments.

```typescript
import { environment } from './environments/environment'
// Make sure to use the production sub-path to load devtools in production builds
import { withDevtools } from '@tanstack/angular-query-experimental/devtools/production'

provideTanStackQuery(
  new QueryClient(),
  withDevtools(() => ({ loadDevtools: environment.loadDevtools })),
)
```

--------------------------------

### Prefetch Comments in Parent using useQuery (TSX)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/prefetching

This TSX code demonstrates prefetching article comments in the parent component by calling useQuery with notifyOnChangeProps to ignore results and avoid rerenders. It depends on TanStack Query v5's useQuery hook and custom query functions for articles and comments. Input is an ID prop; output is flattened request lifecycle, improving performance by starting fetches in parallel.

```tsx
function Article({ id }) {
  const { data: articleData, isPending } = useQuery({
    queryKey: ['article', id],
    queryFn: getArticleById,
  })

  // Prefetch
  useQuery({
    queryKey: ['article-comments', id],
    queryFn: getArticleCommentsById,
    // Optional optimization to avoid rerenders when this query changes:
    notifyOnChangeProps: [],
  })

  if (isPending) {
    return 'Loading article...'
  }

  return (
    <>
      <ArticleHeader articleData={articleData} />
      <ArticleBody articleData={articleData} />
      <Comments id={id} />
    </>
  )
}

function Comments({ id }) {
  const { data, isPending } = useQuery({
    queryKey: ['article-comments', id],
    queryFn: getArticleCommentsById,
  })

  ...
}
```

--------------------------------

### Set default options for mutations via QueryClient (TSX)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-react-query-3

Define default options for specific mutation keys using QueryClient.setMutationDefaults. This sets a baseline mutationFn or options for matching mutation keys; individual useMutation calls can still override these defaults. Inputs are mutation key matcher and defaults object; effect is on QueryClient behavior.

```tsx
queryClient.setMutationDefaults(['addPost'], { mutationFn: addPost })

function Component() {
  const { mutate } = useMutation({ mutationKey: ['addPost'] })
}
```

--------------------------------

### Filter fetching indicators with useIsFetching (TSX)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-react-query-3

Use useIsFetching with filter options to count or detect active fetches for specific query keys or criteria. Takes a filter object (e.g., queryKey) and returns a numeric count of matching in-flight fetches; useful for conditional spinners or loading states. No side effects; read-only indicator.

```tsx
const fetches = useIsFetching({ queryKey: ['posts'] })
```

--------------------------------

### Register Global Meta Type in TanStack Query (Angular)

Source: https://tanstack.com/query/v5/docs/framework/angular/typescript

This example illustrates how to register a global `Meta` type for queries and mutations in TanStack Query (Angular). This ensures that the optional `meta` field remains consistent and type-safe across your application. The registered type must extend `Record<string, unknown>` to maintain object compatibility.

```typescript
import '@tanstack/angular-query-experimental'

interface MyMeta extends Record<string, unknown> {
  // Your meta type definition.
}

declare module '@tanstack/angular-query-experimental' {
  interface Register {
    queryMeta: MyMeta
    mutationMeta: MyMeta
  }
}
```

--------------------------------

### Disable Window Focus Refetching Per-Query in TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/react/guides/window-focus-refetching

This example shows how to disable automatic window focus refetching for a specific query. By setting `refetchOnWindowFocus: false` within the `useQuery` options, only this particular query will bypass the default revalidation behavior when the window regains focus, providing fine-grained control over refetching.

```tsx
useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodos,
  refetchOnWindowFocus: false,
})
```

--------------------------------

### Keeping Only First Page in TanStack Query (TypeScript)

Source: https://tanstack.com/query/v5/docs/framework/angular/guides/infinite-queries

This example limits the infinite query data to retain only the first page by slicing the pages and pageParams arrays. It uses setQueryData to update the query client with the modified structure. Ideal for reducing data size; note that this discards subsequent pages and requires matching query keys.

```typescript
queryClient.setQueryData(['projects'], (data) => ({
  pages: data.pages.slice(0, 1),
  pageParams: data.pageParams.slice(0, 1),
}))

```

--------------------------------

### Track Vue Query Mutations with useIsMutating Hook

Source: https://tanstack.com/query/v5/docs/framework/vue/reference/useIsMutating

This snippet demonstrates how to use the `useIsMutating` hook from `@tanstack/vue-query` to monitor the number of active mutations. It shows how to get a global count of all ongoing mutations and how to filter mutations by a specific `mutationKey` (e.g., 'posts') for more targeted loading indicators. The hook also supports an optional `queryClient` for custom instances and `MutationFilters` for advanced filtering.

```tsx
import { useIsMutating } from '@tanstack/vue-query'
// How many mutations are fetching?
const isMutating = useIsMutating()
// How many mutations matching the posts prefix are fetching?
const isMutatingPosts = useIsMutating({ mutationKey: ['posts'] })
```

--------------------------------

### Configure, Persist, and Resume TanStack Query Mutations (TypeScript)

Source: https://tanstack.com/query/v5/docs/framework/angular/guides/mutations

This comprehensive example demonstrates how to configure a mutation with default behaviors like optimistic updates (`onMutate`), success handling (`onSuccess`), and error handling (`onError`). It also shows how to dehydrate the `QueryClient` state to persist paused mutations and then rehydrate and resume them, which is crucial for offline support or persisting state across application restarts.

```ts
const queryClient = new QueryClient()

// Define the "addTodo" mutation
queryClient.setMutationDefaults(['addTodo'], {
  mutationFn: addTodo,
  onMutate: async (variables, context) => {
    // Cancel current queries for the todos list
    await context.client.cancelQueries({ queryKey: ['todos'] })

    // Create optimistic todo
    const optimisticTodo = { id: uuid(), title: variables.title }

    // Add optimistic todo to todos list
    context.client.setQueryData(['todos'], (old) => [...old, optimisticTodo])

    // Return result with the optimistic todo
    return { optimisticTodo }
  },
  onSuccess: (result, variables, onMutateResult, context) => {
    // Replace optimistic todo in the todos list with the result
    context.client.setQueryData(['todos'], (old) =>
      old.map((todo) =>
        todo.id === onMutateResult.optimisticTodo.id ? result : todo,
      ),
    )
  },
  onError: (error, variables, onMutateResult, context) => {
    // Remove optimistic todo from the todos list
    context.client.setQueryData(['todos'], (old) =>
      old.filter((todo) => todo.id !== onMutateResult.optimisticTodo.id),
    )
  },
  retry: 3,
})

class someComponent {
  // Start mutation in some component:
  mutation = injectMutation(() => ({ mutationKey: ['addTodo'] }))

  someMethod() {
    mutation.mutate({ title: 'title' })
  }
}

// If the mutation has been paused because the device is for example offline,
// Then the paused mutation can be dehydrated when the application quits:
const state = dehydrate(queryClient)

// The mutation can then be hydrated again when the application is started:
hydrate(queryClient, state)

// Resume the paused mutations:
queryClient.resumePausedMutations()
```

--------------------------------

### Angular HttpClient with TanStack Query using lastValueFrom

Source: https://tanstack.com/query/v5/docs/framework/angular/angular-httpclient-and-other-data-fetching-clients

Demonstrates how to integrate Angular's HttpClient with TanStack Query by converting observables to promises using the lastValueFrom function from RxJS. This example shows a component injecting HttpClient and creating a query that fetches repository data from the GitHub API. The queryFn converts the HTTP observable response into a promise, making it compatible with TanStack Query's promise-based architecture.

```typescript
@Component({
  // ...
})
class ExampleComponent {
  private readonly http = inject(HttpClient)

  readonly query = injectQuery(() => ({
    queryKey: ['repoData'],
    queryFn: () =>
      lastValueFrom(
        this.http.get('https://api.github.com/repos/tanstack/query'),
      ),
  }))
}
```

--------------------------------

### Configure Component Re-renders with notifyOnChangeProps in TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-react-query-3

The `notifyOnStatusChange` option has been superseded by `notifyOnChangeProps` and `notifyOnChangePropsExclusions`. These new options provide granular control, allowing components to re-render only when specified properties (`data`, `error`) change or to prevent re-renders when certain properties (`isStale`) change.

```tsx
import { useQuery } from 'react-query'

function User() {
  const { data } = useQuery(['user'], fetchUser, {
    notifyOnChangeProps: ['data', 'error'],
  })
  return <div>Username: {data.username}</div>
}
```

```tsx
import { useQuery } from 'react-query'

function User() {
  const { data } = useQuery(['user'], fetchUser, {
    notifyOnChangePropsExclusions: ['isStale'],
  })
  return <div>Username: {data.username}</div>
}
```

--------------------------------

### Basic TanStack Query `useQuery` hook usage

Source: https://tanstack.com/query/v5/docs/framework/vue/guides/queries

This snippet illustrates the fundamental way to use the `useQuery` hook from TanStack Query. It requires a unique `queryKey` for identification and a `queryFn` that returns a Promise, which resolves with data or throws an error, to initiate data fetching. The returned `result` object contains all query-related information for further processing.

```ts
import { useQuery } from '@tanstack/vue-query'

const result = useQuery({ queryKey: ['todos'], queryFn: fetchTodoList })
```

```tsx
const result = useQuery({ queryKey: ['todos'], queryFn: fetchTodoList })
```

--------------------------------

### Handling Request Waterfall in Article Components (TSX)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/prefetching

This TSX example shows a basic parent-child component structure where article and comments are fetched sequentially, causing a request waterfall. It uses useQuery from TanStack Query v5, requiring getArticleById and getArticleCommentsById query functions. The output is rendered JSX with loading states, but it may result in slower performance due to the waterfall effect.

```tsx
function Article({ id }) {
  const { data: articleData, isPending } = useQuery({
    queryKey: ['article', id],
    queryFn: getArticleById,
  })

  if (isPending) {
    return 'Loading article...'
  }

  return (
    <>
      <ArticleHeader articleData={articleData} />
      <ArticleBody articleData={articleData} />
      <Comments id={id} />
    </>
  )
}

function Comments({ id }) {
  const { data, isPending } = useQuery({
    queryKey: ['article-comments', id],
    queryFn: getArticleCommentsById,
  })

  ...
}
```

--------------------------------

### Configure offline mutation persistence with Vue Query and plugin in JS

Source: https://tanstack.com/query/v5/docs/framework/vue/guides/mutations

This example illustrates how to persist offline mutations using the `persistQueryClient` plugin, specifically for a Vue.js application. It highlights the necessity of providing a `default mutationFn` to allow paused mutations to resume after a page reload, and integrates with `localStorage` for storage. The `clientPersisterOnSuccess` callback ensures paused mutations are resumed upon successful hydration.

```js
const client = new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: 1000 * 60 * 60 * 24, // 24 hours
    },
  },
})

// we need a default mutation function so that paused mutations can resume after a page reload
queryClient.setMutationDefaults({
  mutationKey: ['todos'],
  mutationFn: ({ id, data }) => {
    return api.updateTodo(id, data)
  },
})

const vueQueryOptions: VueQueryPluginOptions = {
  queryClient: client,
  clientPersister: (queryClient) => {
    return persistQueryClient({
      queryClient,
      persister: createAsyncStoragePersister({ storage: localStorage }),
    })
  },
  clientPersisterOnSuccess: (queryClient) => {
    queryClient.resumePausedMutations()
  },
}

createApp(App).use(VueQueryPlugin, vueQueryOptions).mount('#app')
```

--------------------------------

### Data Selection and Initial Data

Source: https://tanstack.com/query/v5/docs/framework/react/reference/useQuery

Options for transforming query data, providing initial data for the cache, setting its update timestamp, and defining placeholder data for pending states.

```APIDOC
## Configuration Option: `select`

### Description
Transforms or selects a part of the data returned by the query function before it is returned by the hook.

### Type
`(data: TData) => unknown`

### Details
- It affects the returned `data` value, but does not affect what gets stored in the query cache.
- The `select` function will only run if `data` changed, or if the reference to the `select` function itself changes. To optimize, wrap the function in `useCallback`.
```

```APIDOC
## Configuration Option: `initialData`

### Description
Provides initial data for the query cache to be used before the first fetch.

### Type
`TData | (() => TData)`

### Details
- If set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet).
- If set to a function, the function will be called **once** during the shared/root query initialization, and be expected to synchronously return the `initialData`.
- Initial data is considered stale by default unless a `staleTime` has been set.
- `initialData` **is persisted** to the cache.
```

```APIDOC
## Configuration Option: `initialDataUpdatedAt`

### Description
Specifies the timestamp (in milliseconds) of when the `initialData` was last updated.

### Type
`number | (() => number | undefined)`

### Details
- If set, this value will be used as the time (in milliseconds) of when the `initialData` itself was last updated.
```

```APIDOC
## Configuration Option: `placeholderData`

### Description
Provides temporary data to be displayed while the query is still in the `pending` state.

### Type
`TData | ((previousValue: TData | undefined, previousQuery: Query | undefined) => TData)`

### Details
- If set, this value will be used as the placeholder data for this particular query observer while the query is still in the `pending` state.
- `placeholderData` is **not persisted** to the cache.
- If you provide a function for `placeholderData`, as a first argument you will receive previously watched query data if available, and the second argument will be the complete `previousQuery` instance.
```

--------------------------------

### Specifying custom error type using useQuery generics in TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/react/typescript

This example shows how to explicitly define a custom type for the `error` field using `useQuery`'s generics. However, this approach can interfere with other type inferences for the hook and is generally not recommended for non-Error types.

```tsx
const { error } = useQuery<Group[], string>(['groups'], fetchGroups)
//      ^? const error: string | null
```

--------------------------------

### Optimistic Updates with TanStack React Query

Source: https://tanstack.com/query/v5/docs/framework/react/examples/optimistic-updates-cache

Implements optimistic updates for todo items using TanStack React Query. The mutation optimistically updates the cache before server confirmation, cancels outgoing requests to prevent overwrites, snapshots previous state for rollback, and refetches on error or success. Handles loading, success, and error states with proper type narrowing and background update indicators.

```typescript
import * as React from 'react'

import {
  QueryClient,
  QueryClientProvider,
  queryOptions,
  useMutation,
  useQuery,
  useQueryClient,
} from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'

const client = new QueryClient()

type Todos = {
  items: ReadonlyArray<{
    id: string
    text: string
  }>
  ts: number
}

async function fetchTodos({ signal }: { signal: AbortSignal }): Promise<Todos> {
  const response = await fetch('/api/data', { signal })
  return await response.json()
}

const todoListOptions = queryOptions({
  queryKey: ['todos'],
  queryFn: fetchTodos,
})

function Example() {
  const queryClient = useQueryClient()
  const [text, setText] = React.useState('')
  const { isFetching, ...queryInfo } = useQuery(todoListOptions)

  const addTodoMutation = useMutation({
    mutationFn: async (newTodo: string) => {
      const response = await fetch('/api/data', {
        method: 'POST',
        body: JSON.stringify({ text: newTodo }),
        headers: { 'Content-Type': 'application/json' },
      })
      return await response.json()
    },
    onMutate: async (newTodo, context) => {
      setText('')
      await context.client.cancelQueries(todoListOptions)

      const previousTodos = context.client.getQueryData(
        todoListOptions.queryKey,
      )

      if (previousTodos) {
        context.client.setQueryData(todoListOptions.queryKey, {
          ...previousTodos,
          items: [
            ...previousTodos.items,
            { id: Math.random().toString(), text: newTodo },
          ],
        })
      }

      return { previousTodos }
    },
    onError: (err, variables, onMutateResult, context) => {
      if (onMutateResult?.previousTodos) {
        context.client.setQueryData<Todos>(
          ['todos'],
          onMutateResult.previousTodos,
        )
      }
    },
    onSettled: (data, error, variables, onMutateResult, context) =>
      context.client.invalidateQueries({ queryKey: ['todos'] }),
  })

  return (
    <div>
      <p>
        In this example, new items can be created using a mutation. The new item
        will be optimistically added to the list in hopes that the server
        accepts the item. If it does, the list is refetched with the true items
        from the list. Every now and then, the mutation may fail though. When
        that happens, the previous list of items is restored and the list is
        again refetched from the server.
      </p>
      <form
        onSubmit={(e) => {
          e.preventDefault()
          addTodoMutation.mutate(text)
        }}
      >
        <input
          type="text"
          onChange={(event) => setText(event.target.value)}
          value={text}
        />
        <button disabled={addTodoMutation.isPending}>Create</button>
      </form>
      <br />
      {queryInfo.isSuccess && (
        <>
          <div>
            Updated At: {new Date(queryInfo.data.ts).toLocaleTimeString()}
          </div>
          <ul>
            {queryInfo.data.items.map((todo) => (
              <li key={todo.id}>{todo.text}</li>
            ))}
          </ul>
          {isFetching && <div>Updating in background...</div>}
        </>
      )}
      {queryInfo.isLoading && 'Loading'}
      {queryInfo.error instanceof Error && queryInfo.error.message}
    </div>
  )
}

export default function App() {
  return (
    <QueryClientProvider client={client}>
      <Example />
      <ReactQueryDevtools initialIsOpen />
    </QueryClientProvider>
  )
}
```

--------------------------------

### Generate Query Options with TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/solid/reference/queryOptions

This snippet demonstrates the basic structure for using `queryOptions` in TanStack Query. It accepts a `queryKey` and other standard query `options`, which are largely compatible with `useQuery`. While some options might not be effective with functions like `queryClient.prefetchQuery`, TypeScript handles these excess properties gracefully.

```tsx
queryOptions({
  queryKey,
  ...options,
})
```

--------------------------------

### Match queries and mutations with matchQuery/matchMutation (TypeScript)

Source: https://tanstack.com/query/v5/docs/framework/angular/guides/filters

Examples using matchQuery and matchMutation utility functions to determine if a given query or mutation matches a filter object. Inputs are filter objects and a query or mutation instance; output is a boolean. Limitation: utilities rely on internal Query/Mutation shapes and should be used with the corresponding TanStack Query version.

```tsx
const isMatching = matchQuery(filters, query)
```

```tsx
const isMatching = matchMutation(filters, mutation)
```

--------------------------------

### Implement Optimistic Update with Cache Rollback in Angular Query

Source: https://tanstack.com/query/v5/docs/framework/angular/guides/optimistic-updates

This `injectMutation` example demonstrates a robust optimistic update strategy using direct cache manipulation. The `onMutate` handler updates the cache immediately and returns a snapshot for rollback, which the `onError` handler uses if the mutation fails. `onSettled` ensures refetching regardless of success or failure.

```ts
queryClient = inject(QueryClient)

updateTodo = injectMutation(() => ({
  mutationFn: updateTodo,
  // When mutate is called:
  onMutate: async (newTodo, context) => {
    // Cancel any outgoing refetches
    // (so they don't overwrite our optimistic update)
    await context.client.cancelQueries({ queryKey: ['todos'] })

    // Snapshot the previous value
    const previousTodos = context.client.getQueryData(['todos'])

    // Optimistically update to the new value
    context.client.setQueryData(['todos'], (old) => [...old, newTodo])

    // Return a result object with the snapshotted value
    return { previousTodos }
  },
  // If the mutation fails,
  // use the result returned from onMutate to roll back
  onError: (err, newTodo, onMutateResult, context) => {
    context.client.setQueryData(['todos'], onMutateResult.previousTodos)
  },
  // Always refetch after error or success:
  onSettled: (data, error, variables, onMutateResult, context) => {
    context.client.invalidateQueries({ queryKey: ['todos'] })
  },
}))
```

--------------------------------

### Update Disabled Query Loading Check (TanStack Query)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-react-query-4

In TanStack Query v5, temporarily disabled queries now start in a `loading` state. To accurately display a loading spinner specifically for the initial data fetch, migrate from checking `isLoading` to `isInitialLoading`. This ensures differentiation between initial loads and subsequent background re-fetches.

```tsx
isInitialLoading
```

--------------------------------

### SvelteKit Load Function for initialData Prefetching

Source: https://tanstack.com/query/v5/docs/framework/svelte/ssr

This SvelteKit `load` function, defined in `+page.ts`, is executed on the server to fetch data before the page renders. It asynchronously calls `getPosts()` and returns the result as `posts`. This data can then be accessed by the corresponding Svelte component via its `data` prop, serving as `initialData` for a TanStack Query.

```ts
export async function load() {
  const posts = await getPosts()
  return { posts }
}
```

--------------------------------

### Disable Window Focus Refetching Globally in TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/react/guides/window-focus-refetching

This example demonstrates how to disable automatic window focus refetching for all queries by setting `refetchOnWindowFocus: false` in the `defaultOptions.queries` of the `QueryClient` configuration. This prevents queries from revalidating when the browser window regains focus, and is useful for applications where data freshness is not critical on every focus event.

```tsx
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: false, // default: true
    },
  },
})

function App() {
  return <QueryClientProvider client={queryClient}>...</QueryClientProvider>
}
```

--------------------------------

### Integrate Solid Query Devtools in Floating Mode

Source: https://tanstack.com/query/v5/docs/framework/solid/devtools

This code snippet demonstrates how to integrate `SolidQueryDevtools` into your Solid.js application using Floating Mode. Wrap your application content with `QueryClientProvider` and place `SolidQueryDevtools` as high as possible in the component tree for optimal functionality, optionally setting `initialIsOpen` to control its default visibility.

```tsx
import { SolidQueryDevtools } from '@tanstack/solid-query-devtools'

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      {/* The rest of your application */}
      <SolidQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  )
}
```

--------------------------------

### Illustrating Global State After TanStack Query Migration (TypeScript/React)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/does-this-replace-client-state

This TypeScript/React example demonstrates the simplified global state object after migrating server-derived data (projects, teams, tasks, users) to TanStack Query. The remaining global state primarily consists of client-only UI concerns, illustrating how TanStack Query reduces the burden on traditional client-state managers by handling asynchronous data caching more efficiently and removing related boilerplate.

```tsx
const globalState = {
  themeMode,
  sidebarStatus,
}
```

--------------------------------

### useQuery with conditional cache validation

Source: https://tanstack.com/query/v5/docs/framework/vue/guides/initial-query-data

Implements conditional initial data loading by checking the age of cached data before using it. Uses queryClient.getQueryState to inspect the source query's dataUpdatedAt timestamp and only returns cached data if it's fresher than a specified threshold (10 seconds in this example). If cache is stale, returns undefined to trigger a fresh server fetch.

```tsx
const result = useQuery({
  queryKey: ['todo', todoId],
  queryFn: () => fetch(`/todos/${todoId}`),
  initialData: () => {
    // Get the query state
    const state = queryClient.getQueryState(['todos'])

    // If the query exists and has data that is no older than 10 seconds...
    if (state && Date.now() - state.dataUpdatedAt <= 10 * 1000) {
      // return the individual todo
      return state.data.find((d) => d.id === todoId)
    }

    // Otherwise, return undefined and let it fetch from a hard loading state!
  },
})
```

--------------------------------

### Create Todo Mutation with useMutation (TypeScript/TSX)

Source: https://tanstack.com/query/v5/docs/framework/solid/guides/mutations

Creates a todo via useMutation and demonstrates checking mutation states to render loading, error, and success UI. Depends on TanStack Query's useMutation and axios for the POST request; inputs are the todo object passed to mutation.mutate and outputs are mutation data or error available on the mutation object. Note: example shows state checks like isPending/isError/isSuccess and assumes useMutation is available in the component scope.

```tsx
function App() {
  const mutation = useMutation(() => {
    mutationFn: (newTodo) => {
      return axios.post('/todos', newTodo)
    },
  })

  return (
    <div>
      {mutation.isPending ? (
        'Adding todo...'
      ) : (
        <>
          {mutation.isError ? (
            <div>An error occurred: {mutation.error.message}</div>
          ) : null}

          {mutation.isSuccess ? <div>Todo added!</div> : null}

          <button
            onClick={() => {
              mutation.mutate({ id: new Date(), title: 'Do Laundry' })
            }}
          >
            Create Todo
          </button>
        </>
      )}
    </div>
  )
}
```

--------------------------------

### Implement Lazy Query in Vue with Conditional `enabled`

Source: https://tanstack.com/query/v5/docs/framework/vue/guides/disabling-queries

This example shows how to create a lazy query that only runs when a specific condition is met, such as a filter value being present. By binding the `enabled` option to a computed property, the query will defer its initial fetch until `filter.value` is truthy, making it ideal for scenarios like form submissions or search inputs.

```vue
<script setup>
import { useQuery } from '@tanstack/vue-query'

const filter = ref('')
const isEnabled = computed(() => !!filter.value)
const { data } = useQuery({
  queryKey: ['todos', filter],
  queryFn: () => fetchTodos(filter),
  // ‚¨áÔ∏è disabled as long as the filter is empty
  enabled: isEnabled,
})
</script>

<template>
  <span v-if="data">Filter was set and data is here!</span>
</template>
```

--------------------------------

### Svelte Layout Component for QueryClientProvider

Source: https://tanstack.com/query/v5/docs/framework/svelte/ssr

This Svelte layout component, found in `+layout.svelte`, receives the `queryClient` instance from its associated SvelteKit `load` function via the `data` prop. It then wraps the application's content (`<slot />`) with `QueryClientProvider`, making the preconfigured TanStack Query client accessible to all nested components and pages.

```svelte
<script lang="ts">
  import { QueryClientProvider } from '@tanstack/svelte-query'
  import type { LayoutData } from './$types'

  export let data: LayoutData
</script>

<QueryClientProvider client={data.queryClient}>
  <slot />
</QueryClientProvider>
```

--------------------------------

### Implement Dependent Queries with Vue TanStack Query useQuery

Source: https://tanstack.com/query/v5/docs/framework/vue/guides/dependent-queries

This example demonstrates how to create a dependent query using TanStack Query's `useQuery` hook within a Vue.js composition API context. It first fetches user data by email, and then uses a `computed` property to enable a second query to fetch the user's projects, ensuring the second query only runs once the `userId` is available.

```js
// Get the user
const { data: user } = useQuery({
  queryKey: ['user', email],
  queryFn: () => getUserByEmail(email.value),
})

const userId = computed(() => user.value?.id)
const enabled = computed(() => !!user.value?.id)

// Then get the user's projects
const { isIdle, data: projects } = useQuery({
  queryKey: ['projects', userId],
  queryFn: () => getProjectsByUser(userId.value),
  enabled, // The query will not execute until `enabled == true`
})
```

--------------------------------

### TypeScript: Basic usePrefetchQuery usage

Source: https://tanstack.com/query/v5/docs/framework/react/reference/usePrefetchQuery

This snippet illustrates the fundamental way to invoke the `usePrefetchQuery` hook, passing an `options` object. This hook is used to trigger a data prefetch during the component's render phase, preparing data for subsequent `useSuspenseQuery` calls.

```tsx
usePrefetchQuery(options)
```

--------------------------------

### Configure Query Functions with useQuery

Source: https://tanstack.com/query/v5/docs/framework/react/guides/query-functions

Demonstrates various valid query function configurations using the useQuery hook. Query functions can be simple function references, arrow functions with parameters, async functions, or functions that extract data from the queryKey. All configurations must return a promise.

```typescript
useQuery({ queryKey: ['todos'], queryFn: fetchAllTodos })
useQuery({ queryKey: ['todos', todoId], queryFn: () => fetchTodoById(todoId) })
useQuery({
  queryKey: ['todos', todoId],
  queryFn: async () => {
    const data = await fetchTodoById(todoId)
    return data
  },
})
useQuery({
  queryKey: ['todos', todoId],
  queryFn: ({ queryKey }) => fetchTodoById(queryKey[1]),
})
```

--------------------------------

### Type-Safe Query Options with `queryOptions` in TanStack Query (Angular)

Source: https://tanstack.com/query/v5/docs/framework/angular/typescript

This example demonstrates using the `queryOptions` helper to maintain type inference when extracting query options into a separate service or function in an Angular application. This pattern is crucial for sharing type-safe query configurations between `injectQuery` and other functions like `prefetchQuery` without losing type information. It also shows how `getQueryData` benefits from this type awareness.

```typescript
@Injectable({
  providedIn: 'root',
})
export class QueriesService {
  private http = inject(HttpClient)

  post(postId: number) {
    return queryOptions({
      queryKey: ['post', postId],
      queryFn: () => {
        return lastValueFrom(
          this.http.get<Post>(
            `https://jsonplaceholder.typicode.com/posts/${postId}`,
          ),
        )
      },
    })
  }
}

@Component({
  // ...
})
export class Component {
  queryClient = inject(QueryClient)

  postId = signal(1)

  queries = inject(QueriesService)
  optionsSignal = computed(() => this.queries.post(this.postId()))

  postQuery = injectQuery(() => this.queries.post(1))
  postQuery = injectQuery(() => this.queries.post(this.postId()))

  // You can also pass a signal which returns query options
  postQuery = injectQuery(this.optionsSignal)

  someMethod() {
    this.queryClient.prefetchQuery(this.queries.post(23))
  }
}

data = this.queryClient.getQueryData(groupOptions().queryKey)
// ^? data: Post | undefined
```

--------------------------------

### useIsFetching Hook - TanStack Solid Query

Source: https://tanstack.com/query/v5/docs/framework/solid/reference/useIsFetching

Hook that returns the number of queries currently fetching. Accepts optional QueryFilters to track specific queries (e.g., by queryKey prefix) and an optional custom QueryClient. Returns a number representing active fetching queries, useful for displaying global loading states.

```tsx
import { useIsFetching } from '@tanstack/solid-query'
// How many queries are fetching?
const isFetching = useIsFetching()
// How many queries matching the posts prefix are fetching?
const isFetchingPosts = useIsFetching({ queryKey: ['posts'] })
```

--------------------------------

### Incorrect TanStack Query: Void return from query function

Source: https://tanstack.com/query/v5/docs/eslint/no-void-query-fn

This TypeScript example demonstrates an incorrect usage of `useQuery` where the `queryFn` performs an asynchronous operation but does not explicitly return the fetched data. This results in a void return type, which is disallowed by the `@tanstack/query/no-void-query-fn` ESLint rule, indicating a potential mistake where data might not be cached.

```tsx
/* eslint "@tanstack/query/no-void-query-fn": "error" */

useQuery({
  queryKey: ['todos'],
  queryFn: async () => {
    await api.todos.fetch() // Function doesn't return the fetched data
  },
})
```

--------------------------------

### Dehydrate TanStack Query Client with Error Inclusion (TypeScript)

Source: https://tanstack.com/query/v5/docs/framework/solid/reference/hydration

This example demonstrates how to dehydrate a `QueryClient` to include errors by overriding the `shouldDehydrateQuery` option. It also highlights the necessity for custom serialization and deserialization functions when handling non-JSON serializable data types like `Error` objects, which is common when persisting state across different environments.

```tsx
// server
const state = dehydrate(client, { shouldDehydrateQuery: () => true }) // to also include Errors
const serializedState = mySerialize(state) // transform Error instances to objects

// client
const state = myDeserialize(serializedState) // transform objects back to Error instances
hydrate(client, state)
```

--------------------------------

### Prevent Data Overwrites in Infinite Query

Source: https://tanstack.com/query/v5/docs/framework/angular/guides/infinite-queries

Shows how to prevent data conflicts when calling fetchNextPage during ongoing requests. The example demonstrates checking the isFetching state before triggering new requests to avoid overwriting background data refreshes. Includes optional cancelRefetch configuration for simultaneous fetching scenarios. Essential for list rendering with concurrent fetchNextPage calls.

```angular-ts
@Component({
  template: ` <list-component (endReached)="fetchNextPage()" /> `,
})
export class Example {
  query = injectInfiniteQuery(() => ({
    queryKey: ['projects'],
    queryFn: async ({ pageParam }) => {
      return lastValueFrom(this.projectsService.getProjects(pageParam))
    },
  }))

  fetchNextPage() {
    // Do nothing if already fetching
    if (this.query.isFetching()) return
    this.query.fetchNextPage()
  }
}
```

--------------------------------

### SvelteKit Page Load Function with prefetchQuery

Source: https://tanstack.com/query/v5/docs/framework/svelte/ssr

This SvelteKit `load` function, located in `+page.ts`, retrieves the `queryClient` from its parent layout's `load` function using `await parent()`. It then uses `queryClient.prefetchQuery` to fetch 'posts' data on the server, populating the TanStack Query cache. It is critical to use SvelteKit's `fetch` function within the `queryFn` for proper server-side data fetching.

```ts
export async function load({ parent, fetch }) {
  const { queryClient } = await parent()

  // You need to use the SvelteKit fetch function here
  await queryClient.prefetchQuery({
    queryKey: ['posts'],
    queryFn: async () => (await fetch('/api/posts')).json(),
  })
}
```

--------------------------------

### Type Narrowing Query Results with Status Flags in Solid Query (TSX)

Source: https://tanstack.com/query/v5/docs/framework/solid/typescript

This example demonstrates how Solid Query utilizes discriminated unions for its query results, enabling type narrowing based on the `status` field. By checking `query.isSuccess`, the `data` property's type is refined from `number | undefined` to a definite `number`, allowing safer access to the data.

```tsx
const query = useQuery(() => ({
  queryKey: ['number'],
  queryFn: () => Promise.resolve(5),
}))

if (query.isSuccess) {
  const data = query.data
  //     ^? const data: number
}
```

--------------------------------

### StoragePersisterOptions Interface - Query Persistence Configuration

Source: https://tanstack.com/query/v5/docs/framework/solid/plugins/createPersister

Defines all configuration options for the query persister including storage client, serialization methods, cache age limits, key prefixing, and refetch behavior. Supports both synchronous Storage and asynchronous AsyncStorage implementations.

```typescript
export interface StoragePersisterOptions {
  /** The storage client used for setting and retrieving items from cache.
   * For SSR pass in `undefined`.
   */
  storage: AsyncStorage | Storage | undefined | null
  /**
   * How to serialize the data to storage.
   * @default `JSON.stringify`
   */
  serialize?: (persistedQuery: PersistedQuery) => string
  /**
   * How to deserialize the data from storage.
   * @default `JSON.parse`
   */
  deserialize?: (cachedString: string) => PersistedQuery
  /**
   * A unique string that can be used to forcefully invalidate existing caches,
   * if they do not share the same buster string
   */
  buster?: string
  /**
   * The max-allowed age of the cache in milliseconds.
   * If a persisted cache is found that is older than this
   * time, it will be discarded
   * @default 24 hours
   */
  maxAge?: number
  /**
   * Prefix to be used for storage key.
   * Storage key is a combination of prefix and query hash in a form of `prefix-queryHash`.
   */
  prefix?: string
  /**
   * If set to `true`, the query will refetch on successful query restoration if the data is stale.
   * If set to `false`, the query will not refetch on successful query restoration.
   * If set to `'always'`, the query will always refetch on successful query restoration.
   * Defaults to `true`.
   */
  refetchOnRestore?: boolean | 'always'
  /**
   * Filters to narrow down which Queries should be persisted.
   */
  filters?: QueryFilters
}
```

--------------------------------

### Manually Cancel a TanStack Query with `useQueryClient` and `cancelQueries`

Source: https://tanstack.com/query/v5/docs/framework/react/guides/query-cancellation

This example demonstrates how to set up a query using `useQuery` that accepts a `signal` for cancellation. It shows how to use `queryClient.cancelQueries` within an event handler, such as a button click, to stop an ongoing query and revert its state. The `signal` ensures the underlying fetch request is also terminated.

```tsx
const query = useQuery({
  queryKey: ['todos'],
  queryFn: async ({ signal }) => {
    const resp = await fetch('/todos', { signal })
    return resp.json()
  },
})

const queryClient = useQueryClient()

return (
  <button
    onClick={(e) => {
      e.preventDefault()
      queryClient.cancelQueries({ queryKey: ['todos'] })
    }}
  >
    Cancel
  </button>
)
```

--------------------------------

### Registering global Meta type for queries and mutations in TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/react/typescript

This example illustrates how to define and register a global `MyMeta` type for the `queryMeta` and `mutationMeta` fields by extending the `Register` interface. This ensures that the optional `meta` field for queries and mutations remains type-safe and consistent throughout the application, requiring the registered type to extend `Record<string, unknown>`.

```ts
import '@tanstack/react-query'

interface MyMeta extends Record<string, unknown> {
  // Your meta type definition.
}

declare module '@tanstack/react-query' {
  interface Register {
    queryMeta: MyMeta
    mutationMeta: MyMeta
  }
}
```

--------------------------------

### React Infinite Scroll Component Render Logic with TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/react/examples/infinite-query-with-max-pages

This JSX snippet is part of a React functional component that renders an infinitely scrollable list of 'projects'. It includes dynamic styling for each project, a 'Load Newer' button that triggers `fetchNextPage()`, and conditional rendering for various loading and data availability states (`isFetchingNextPage`, `hasNextPage`, `isFetching`). The `ReactQueryDevtools` are also integrated for debugging TanStack Query operations.

```jsx
                    border: '1px solid gray',
                    borderRadius: '5px',
                    padding: '8px',
                    fontSize: '14px',
                    background: `hsla(${project.id * 30}, 60%, 80%, 1)`,
                  }}
                  key={project.id}
                >
                  {project.name}
                </p>
              ))}
            </React.Fragment>
          ))}
          <div>
            <button
              onClick={() => fetchNextPage()}
              disabled={!hasNextPage || isFetchingNextPage}
            >
              {isFetchingNextPage
                ? 'Loading more...'
                : hasNextPage
                  ? 'Load Newer'
                  : 'Nothing more to load'}
            </button>
          </div>
          <div>
            {isFetching && !isFetchingNextPage
              ? 'Background Updating...'
              : null}
          </div>
        </>
      )}
      <hr />
      <ReactQueryDevtools initialIsOpen />
    </div>
  )
```

--------------------------------

### Conditionally Provide Initial Data from Cache with TanStack Query (TypeScript)

Source: https://tanstack.com/query/v5/docs/framework/angular/guides/initial-query-data

This example illustrates how to conditionally provide initial data from the cache based on its freshness using `queryClient.getQueryState`. It retrieves the query state and checks if `dataUpdatedAt` is within a defined freshness window (e.g., 10 seconds). If the cached data is too old, it returns `undefined` to trigger a fetch from the server instead.

```ts
result = injectQuery(() => ({
  queryKey: ['todo', this.todoId()],
  queryFn: () => fetch(`/todos/${this.todoId()}`),
  initialData: () => {
    // Get the query state
    const state = queryClient.getQueryState(['todos'])

    // If the query exists and has data that is no older than 10 seconds...
    if (state && Date.now() - state.dataUpdatedAt <= 10 * 1000) {
      // return the individual todo
      return state.data.find((d) => d.id === this.todoId())
    }

    // Otherwise, return undefined and let it fetch from a hard loading state!
  },
}))
```

--------------------------------

### Define Query Options Function Signatures in TypeScript (Svelte Query)

Source: https://tanstack.com/query/v5/docs/framework/svelte/reference/functions/queryoptions

This TypeScript function, `queryOptions`, is used to define and configure query options for data fetching within TanStack Svelte Query. It supports two primary call signatures, accommodating scenarios where initial data is either explicitly defined or left undefined, allowing for flexible query setup. The function accepts an `options` object and returns an extended options object suitable for query configuration.

```typescript
function queryOptions<TQueryFnData, TError, TData, TQueryKey>(
  options,
): DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> & object
```

```typescript
function queryOptions<TQueryFnData, TError, TData, TQueryKey>(
  options,
): UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> & object
```

--------------------------------

### Flatten Request Waterfall by Prefetching with `useQuery` in Parent Component (TanStack Query)

Source: https://tanstack.com/query/v5/docs/framework/solid/guides/prefetching

This snippet shows how to prefetch secondary data (e.g., comments) within a parent component (`Article`) using `useQuery`, but ignoring its return value. This allows the secondary query to start fetching concurrently with the primary query, effectively flattening the request waterfall. An optional `notifyOnChangeProps: []` can be used to prevent unnecessary re-renders.

```tsx
function Article({ id }) {
  const { data: articleData, isPending } = useQuery(() => {
    queryKey: ['article', id],
    queryFn: getArticleById,
  })

  // Prefetch
  useQuery(() => {
    queryKey: ['article-comments', id],
    queryFn: getArticleCommentsById,
    // Optional optimization to avoid rerenders when this query changes:
    notifyOnChangeProps: [],
  })

  if (isPending) {
    return 'Loading article...'
  }

  return (
    <>
      <ArticleHeader articleData={articleData} />
      <ArticleBody articleData={articleData} />
      <Comments id={id} />
    </>
  )
}

function Comments({ id }) {
  const { data, isPending } = useQuery(() => {
    queryKey: ['article-comments', id],
    queryFn: getArticleCommentsById,
  })

  ...
}
```

--------------------------------

### Creating a Lazy TanStack Query with Conditional Enablement (React/TSX)

Source: https://tanstack.com/query/v5/docs/framework/solid/guides/disabling-queries

This example illustrates implementing a lazy query that only fetches data when a specific condition is met, such as a filter value being present. The `enabled` option is dynamically set based on the `filter` state, ensuring the query runs only when a valid filter is provided. This is useful for scenarios where initial data fetching should be deferred until user input.

```tsx
function Todos() {
  const [filter, setFilter] = React.useState('')

  const { data } = useQuery({
    queryKey: ['todos', filter],
    queryFn: () => fetchTodos(filter),
    // ‚¨áÔ∏è disabled as long as the filter is empty
    enabled: !!filter,
  })

  return (
    <div>
      // üöÄ applying the filter will enable and execute the query
      <FiltersForm onApply={setFilter} />
      {data && <TodosTable data={data} />}
    </div>
  )
}
```

--------------------------------

### Understand Consecutive TanStack Query `mutate` Callback Behavior (TSX)

Source: https://tanstack.com/query/v5/docs/framework/vue/guides/mutations

This example highlights the difference in callback execution when performing consecutive mutations. Callbacks defined on `useMutation` will be called for each mutation. However, callbacks passed directly to the `mutate` function will only execute once for the last mutation, and only if the component is still mounted, due to the mutation observer being resubscribed with each `mutate` call. It also notes that mutation fulfillment order might differ from `mutate` call order for asynchronous `mutationFn`.

```tsx
useMutation({
  mutationFn: addTodo,
  onSuccess: (data, variables, onMutateResult, context) => {
    // Will be called 3 times
  },
})

const todos = ['Todo 1', 'Todo 2', 'Todo 3']
todos.forEach((todo) => {
  mutate(todo, {
    onSuccess: (data, variables, onMutateResult, context) => {
      // Will execute only once, for the last mutation (Todo 3),
      // regardless which mutation resolves first
    },
  })
})
```

--------------------------------

### Identifying Independent Nested Query Waterfalls (React/TypeScript)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/request-waterfalls

This example demonstrates an independent nested component waterfall where a parent component fetches article data and a child component fetches comments data. Although the child receives an ID from the parent, its query is not inherently dependent on the parent's data, leading to a sequential fetch if not optimized. Both `Article` and `Comments` components use `useQuery`.

```tsx
function Article({ id }) {
  const { data: articleData, isPending } = useQuery({
    queryKey: ['article', id],
    queryFn: getArticleById,
  })

  if (isPending) {
    return 'Loading article...'
  }

  return (
    <>
      <ArticleHeader articleData={articleData} />
      <ArticleBody articleData={articleData} />
      <Comments id={id} />
    </>
  )

}

function Comments({ id }) {
  const { data, isPending } = useQuery({
    queryKey: ['article-comments', id],
    queryFn: getArticleCommentsById,
  })

  ...
}
```

--------------------------------

### Type-Safe Disabling with TanStack Query skipToken in React

Source: https://tanstack.com/query/v5/docs/framework/react/guides/disabling-queries

This example shows how to use `skipToken` for type-safe conditional query disabling, particularly useful in TypeScript projects. The `queryFn` is conditionally set to `skipToken` when no filter is present, preventing the query from running while maintaining type safety. Note that `refetch` will not work when `skipToken` is used, as it results in a `Missing queryFn` error.

```tsx
import { skipToken, useQuery } from '@tanstack/react-query'

function Todos() {
  const [filter, setFilter] = React.useState<string | undefined>()

  const { data } = useQuery({
    queryKey: ['todos', filter],
    // ‚¨áÔ∏è disabled as long as the filter is undefined or empty
    queryFn: filter ? () => fetchTodos(filter) : skipToken,
  })

  return (
    <div>
      // üöÄ applying the filter will enable and execute the query
      <FiltersForm onApply={setFilter} />
      {data && <TodosTable data={data} />}
    </div>
  )
}
```

--------------------------------

### useQuery Return Object - Status and Data Properties

Source: https://tanstack.com/query/v5/docs/framework/react/reference/useQuery

Documents the core return properties from useQuery including status indicators, data, errors, and timestamp information that help manage query state in your application.

```APIDOC
## useQuery Return Object

### Description
The useQuery hook returns an object containing comprehensive query state management properties including status, data, errors, and helper functions.

### Status Properties

#### status: QueryStatus
- **Type**: `'pending' | 'error' | 'success'`
- **Description**: The current status of the query
  - `pending`: No cached data and no query attempt finished yet
  - `error`: Query attempt resulted in an error
  - `success`: Query received a response with no errors and data is ready

#### isPending: boolean
- **Type**: `boolean`
- **Description**: Derived boolean from status variable. True when status is 'pending'

#### isSuccess: boolean
- **Type**: `boolean`
- **Description**: Derived boolean from status variable. True when status is 'success'

#### isError: boolean
- **Type**: `boolean`
- **Description**: Derived boolean from status variable. True when status is 'error'

#### isLoadingError: boolean
- **Type**: `boolean`
- **Description**: True if the query failed while fetching for the first time

#### isRefetchError: boolean
- **Type**: `boolean`
- **Description**: True if the query failed while refetching

### Data Properties

#### data: TData
- **Type**: `TData | undefined`
- **Default**: `undefined`
- **Description**: The last successfully resolved data for the query

#### dataUpdatedAt: number
- **Type**: `number`
- **Description**: Timestamp in milliseconds for when the query most recently returned status as 'success'

#### isStale: boolean
- **Type**: `boolean`
- **Description**: True if the data in cache is invalidated or if data is older than the given staleTime

#### isPlaceholderData: boolean
- **Type**: `boolean`
- **Description**: True if the data shown is placeholder data

### Error Properties

#### error: null | TError
- **Type**: `TError | null`
- **Default**: `null`
- **Description**: The error object for the query if an error was thrown

#### errorUpdatedAt: number
- **Type**: `number`
- **Description**: Timestamp in milliseconds for when the query most recently returned status as 'error'

#### failureReason: null | TError
- **Type**: `TError | null`
- **Description**: The failure reason for the query retry. Reset to null when query succeeds

#### errorUpdateCount: number
- **Type**: `number`
- **Description**: The sum of all errors
```

--------------------------------

### Configure Retry for TanStack Query Mutations (TSX)

Source: https://tanstack.com/query/v5/docs/framework/vue/guides/mutations

This example shows how to enable and configure retry attempts for failed mutations in TanStack Query. By default, mutations do not retry, but setting the `retry` option (e.g., `retry: 3`) will instruct the query client to retry the mutation a specified number of times upon failure. Offline mutations will also be retried in order when the device regains connection.

```tsx
const mutation = useMutation({
  mutationFn: addTodo,
  retry: 3,
})
```

--------------------------------

### Use Default Query Function in Angular Components

Source: https://tanstack.com/query/v5/docs/framework/angular/guides/default-query-function

Demonstrates how to use the default query function in Angular components with injectQuery. Components can now omit the queryFn and pass only the queryKey, as the default function handles all requests. Shows two examples: PostsComponent fetching a list and PostComponent fetching a single post with conditional execution based on a signal.

```typescript
export class PostsComponent {
  // All you have to do now is pass a key!
  postsQuery = injectQuery<Array<Post>>(() => ({
    queryKey: ['/posts'],
  }))
  // ...
}

export class PostComponent {
  // You can even leave out the queryFn and just go straight into options
  postQuery = injectQuery<Post>(() => ({
    enabled: this.postIdSignal() > 0,
    queryKey: [`/posts/${this.postIdSignal()}`],
  }))
  // ...
}
```

--------------------------------

### useQuery with initialData and default staleTime

Source: https://tanstack.com/query/v5/docs/framework/vue/guides/initial-query-data

Shows how initialData behaves with default staleTime of 0ms. The query will display initial data immediately but refetch automatically on mount since the data is considered stale.

```typescript
// Will show initialTodos immediately, but also immediately refetch todos after mount
const result = useQuery({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: initialTodos,
})
```

--------------------------------

### Prefetch Data Directly within a `queryFn` using `queryClient.prefetchQuery` (TanStack Query)

Source: https://tanstack.com/query/v5/docs/framework/solid/guides/prefetching

This method demonstrates prefetching related data (e.g., comments) directly within the `queryFn` of a primary query (e.g., fetching an article). It uses `queryClient.prefetchQuery` to trigger the secondary fetch, ensuring that whenever the main article is requested, its comments are also proactively fetched.

```tsx
const queryClient = useQueryClient()
const { data: articleData, isPending } = useQuery(() => {
  queryKey: ['article', id],
  queryFn: (...args) => {
    queryClient.prefetchQuery({
      queryKey: ['article-comments', id],
      queryFn: getArticleCommentsById,
    })

    return getArticleById(...args)
  },
})
```

--------------------------------

### useInfiniteQuery Hook Overview

Source: https://tanstack.com/query/v5/docs/framework/solid/reference/useInfiniteQuery

The useInfiniteQuery hook enables infinite scrolling and pagination patterns by managing page state and providing methods to load additional pages. It returns pagination state properties and functions to control data fetching direction.

```APIDOC
## useInfiniteQuery

### Description
A React hook for managing infinite or paginated queries with support for bidirectional pagination (next and previous pages). Extends useQuery functionality with pagination-specific state management and data fetching methods.

### Hook Signature
```tsx
const result = useInfiniteQuery({
  queryKey,
  queryFn: ({ pageParam }) => fetchPage(pageParam),
  initialPageParam: 1,
  getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => lastPage.nextCursor,
  getPreviousPageParam: (firstPage, allPages, firstPageParam, allPageParams) => firstPage.prevCursor,
  ...options
})
```

### Parameters

#### Configuration Options
- **queryKey** (string[] | QueryKey) - Required - Unique identifier for the query cache
- **queryFn** (function) - Required - Function that receives `{ pageParam }` and returns a Promise with page data
- **initialPageParam** (TPageParam) - Required - The default page parameter for the first page fetch
- **getNextPageParam** (function) - Required - Receives `(lastPage, allPages, lastPageParam, allPageParams)` and returns the next page parameter or `undefined`/`null` if no next page
- **getPreviousPageParam** (function) - Optional - Receives `(firstPage, allPages, firstPageParam, allPageParams)` and returns the previous page parameter or `undefined`/`null` if no previous page
- **maxPages** (number | undefined) - Optional - Maximum number of pages to store. When exceeded, oldest/newest page is removed. Default is `undefined` (unlimited)
- **...options** - All standard useQuery options are supported

### Return Values

#### Data Properties
- **data.pages** (TData[]) - Array containing all fetched pages
- **data.pageParams** (unknown[]) - Array containing all page parameters used for fetches

#### Pagination State
- **hasNextPage** (boolean) - True if there is a next page available to fetch
- **hasPreviousPage** (boolean) - True if there is a previous page available to fetch
- **isFetchingNextPage** (boolean) - True while fetching the next page
- **isFetchingPreviousPage** (boolean) - True while fetching the previous page
- **isFetchNextPageError** (boolean) - True if fetching next page resulted in an error
- **isFetchPreviousPageError** (boolean) - True if fetching previous page resulted in an error
- **isRefetching** (boolean) - True during background refetch (excludes pending and pagination fetches)
- **isRefetchError** (boolean) - True if background refetch resulted in an error

#### Pagination Methods
- **fetchNextPage** (function) - Fetches the next page. Accepts `options.cancelRefetch` (boolean) to control repeated invocation behavior
- **fetchPreviousPage** (function) - Fetches the previous page. Accepts `options.cancelRefetch` (boolean) to control repeated invocation behavior

#### Additional Properties
- **promise** (Promise<TData>) - Promise that resolves when query completes
- **...result** - All standard useQuery return properties (data, error, status, isFetching, isPending, etc.)

### Usage Example
```tsx
const {
  data,
  fetchNextPage,
  hasNextPage,
  isFetchingNextPage,
  status
} = useInfiniteQuery({
  queryKey: ['posts'],
  queryFn: async ({ pageParam = 1 }) => {
    const response = await fetch(`/api/posts?page=${pageParam}`);
    return response.json();
  },
  initialPageParam: 1,
  getNextPageParam: (lastPage) => lastPage.nextCursor
});

return (
  <>
    {data?.pages.map((page) => (
      <div key={page.id}>{page.content}</div>
    ))}
    <button
      onClick={() => fetchNextPage()}
      disabled={!hasNextPage || isFetchingNextPage}
    >
      {isFetchingNextPage ? 'Loading...' : 'Load More'}
    </button>
  </>
);
```
```

--------------------------------

### Manage TanStack Query Focus State with React Native AppState

Source: https://tanstack.com/query/v5/docs/framework/react/guides/window-focus-refetching

This example demonstrates how to integrate React Native's `AppState` module with TanStack Query's `focusManager` to ensure queries revalidate correctly when the app becomes active. It uses `AppState.addEventListener` to detect state changes and calls `focusManager.setFocused` accordingly, providing a robust solution for managing focus-based refetching in mobile applications.

```tsx
import { AppState } from 'react-native'
import { focusManager } from '@tanstack/react-query'

function onAppStateChange(status: AppStateStatus) {
  if (Platform.OS !== 'web') {
    focusManager.setFocused(status === 'active')
  }
}

useEffect(() => {
  const subscription = AppState.addEventListener('change', onAppStateChange)

  return () => subscription.remove()
}, [])
```

--------------------------------

### Manage queries using Query Filters (TypeScript)

Source: https://tanstack.com/query/v5/docs/framework/angular/guides/filters

Demonstrates using QueryFilters with a QueryClient to cancel, remove, or refetch queries. Requires a configured QueryClient instance from TanStack Query; inputs are QueryFilters objects (e.g., queryKey, type) and outputs are Promises or void. Limitations: examples use TypeScript/TSX and assume TanStack Query v5 types are available.

```tsx
// Cancel all queries
await queryClient.cancelQueries()

// Remove all inactive queries that begin with `posts` in the key
queryClient.removeQueries({ queryKey: ['posts'], type: 'inactive' })

// Refetch all active queries
await queryClient.refetchQueries({ type: 'active' })

// Refetch all active queries that begin with `posts` in the key
await queryClient.refetchQueries({ queryKey: ['posts'], type: 'active' })
```

--------------------------------

### Define Default Query Function with TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/angular/guides/default-query-function

Creates a default query function that receives the query key and uses it to construct API endpoints. This function is then provided to QueryClient via defaultOptions, allowing all queries in the application to use this single function without specifying queryFn individually. The example uses axios to fetch data from JSONPlaceholder API.

```typescript
// Define a default query function that will receive the query key
const defaultQueryFn: QueryFunction = async ({ queryKey }) => {
  const { data } = await axios.get(
    `https://jsonplaceholder.typicode.com${queryKey[0]}`,
  )
  return data
}

// provide the default query function to your app with defaultOptions
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryFn: defaultQueryFn,
    },
  },
})

bootstrapApplication(MyAppComponent, {
  providers: [provideTanStackQuery(queryClient)],
})
```

--------------------------------

### Configure onlineManager for React Native (TypeScript)

Source: https://tanstack.com/query/v5/docs/framework/react/react-native

Bridge native network status into React Query's onlineManager so queries auto-refetch on reconnect. Depends on @tanstack/react-query and either @react-native-community/netinfo or expo-network; registers an event listener and returns an unsubscribe function. Limitations: call once at app startup and ensure the chosen network library is installed and linked correctly.

```tsx
import NetInfo from '@react-native-community/netinfo'
import { onlineManager } from '@tanstack/react-query'

onlineManager.setEventListener((setOnline) => {
  return NetInfo.addEventListener((state) => {
    setOnline(!!state.isConnected)
  })
})
```

```tsx
import { onlineManager } from '@tanstack/react-query'
import * as Network from 'expo-network'

onlineManager.setEventListener((setOnline) => {
  const eventSubscription = Network.addNetworkStateListener((state) => {
    setOnline(!!state.isConnected)
  })
  return eventSubscription.remove
})
```

--------------------------------

### TypeScript Generic Error Type in useQuery Hook

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-v5

Demonstrates how to specify a custom error type in useQuery when throwing non-Error values. By default, TanStack Query v5 expects Error types, but you can override this by providing explicit generic type parameters. The example shows throwing a string error instead of an Error object.

```typescript
useQuery<number, string>({
  queryKey: ['some-query'],
  queryFn: async () => {
    if (Math.random() > 0.5) {
      throw 'some error'
    }
    return 42
  },
})
```

--------------------------------

### Function: createInfiniteQuery

Source: https://tanstack.com/query/v5/docs/framework/svelte/reference/functions/createinfinitequery

This function creates an infinite query instance for managing paginated or incrementally loaded data using TanStack Query. It accepts configuration options and an optional `QueryClient` instance to initialize and manage query behavior for infinite scrolling or 'load more' patterns.

```APIDOC
## Function: createInfiniteQuery

### Description
This function creates an infinite query instance for managing paginated or incrementally loaded data using TanStack Query. It accepts configuration options and an optional `QueryClient` instance to initialize and manage query behavior for infinite scrolling or "load more" patterns.

### Method
N/A (Client-side Function Call)

### Endpoint
N/A (Client-side Function Call)

### Parameters
#### Function Arguments
- **options** (`StoreOrVal<CreateInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey, TPageParam>>`) - Required - Configuration options for the infinite query.
- **queryClient?** (`QueryClient`) - Optional - An instance of `QueryClient` to use for the query.

#### Type Parameters
- **TQueryFnData** - Type of the data returned by the query function.
- **TError** - Type of the error returned by the query function. Defaults to `Error`.
- **TData** - Type of the data returned by `useInfiniteQuery`. Defaults to `InfiniteData<TQueryFnData, unknown>`.
- **TQueryKey** - Type of the query key. Extends `readonly unknown[]`. Defaults to `readonly unknown[]`.
- **TPageParam** - Type of the page parameter. Defaults to `unknown`.

### Request Example
```ts
// Example of how createInfiniteQuery might be called
const result = createInfiniteQuery({
  queryKey: ['projects'],
  queryFn: async ({ pageParam }) => {
    const res = await fetch(`/api/projects?cursor=${pageParam}`);
    return res.json();
  },
  initialPageParam: 0,
  getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => lastPage.nextCursor,
});
```

### Response
#### Success Response (Return Value)
- **CreateInfiniteQueryResult<TData, TError>** - An object containing the infinite query's state, data, and methods for interaction.

#### Response Example
```json
{
  "data": {
    "pages": [
      {
        "items": [
          {"id": 1, "name": "Project A"},
          {"id": 2, "name": "Project B"}
        ],
        "nextCursor": 2
      }
    ],
    "pageParams": [0]
  },
  "error": null,
  "isFetching": false,
  "isLoading": false,
  "fetchNextPage": "[Function]",
  "hasNextPage": true,
  "status": "success"
}
```
```

--------------------------------

### Narrowing Data Type with isSuccess Status in Vue Query

Source: https://tanstack.com/query/v5/docs/framework/vue/typescript

Vue Query utilizes a discriminated union type for query results, enabling type narrowing based on the `status` field. This example shows that inside an `if (isSuccess)` block, the `data` property is correctly narrowed from `Ref<number> | Ref<undefined>` to `number`, making it safely accessible.

```tsx
const { data, isSuccess } = reactive(
  useQuery({
    queryKey: ['test'],
    queryFn: () => Promise.resolve(5),
  }),
)

if (isSuccess) {
  data
  // ^? const data: number
}
```

--------------------------------

### Filter mutations using Mutation Filters (TypeScript)

Source: https://tanstack.com/query/v5/docs/framework/angular/guides/filters

Shows how to filter and count mutations via QueryClient.isMutating using MutationFilters. Depends on a QueryClient instance and accepts mutationKey, exact, status, or a predicate function; returns a number representing matching/active mutations. Limitations: TypeScript examples assume TanStack Query v5 mutation types and state shape.

```tsx
// Get the number of all fetching mutations
await queryClient.isMutating()

// Filter mutations by mutationKey
await queryClient.isMutating({ mutationKey: ['post'] })

// Filter mutations using a predicate function
await queryClient.isMutating({
  predicate: (mutation) => mutation.state.variables?.id === 1,
})
```

--------------------------------

### Remove Manual Console Overrides for React Native in React Query

Source: https://tanstack.com/query/v5/docs/framework/react/guides/migrating-to-react-query-3

Previous versions of React Query required manual `setConsole` configuration to prevent error screens in React Native. In version 3, this behavior is now handled automatically when React Query detects a React Native environment, making manual overrides for the console unnecessary.

```tsx
import { setConsole } from 'react-query'

setConsole({
  log: console.log,
  warn: console.warn,
  error: console.warn,
})
```

--------------------------------

### Configure TanStack Query QueryClientProvider for Next.js App Router

Source: https://tanstack.com/query/v5/docs/framework/react/guides/advanced-ssr

This `app/providers.tsx` file sets up the `QueryClientProvider` for a Next.js application, marking it as a client component due to `useContext`. It defines a strategy to create a new `QueryClient` for every server request while reusing a single client in the browser, ensuring proper state management across SSR and client-side hydration.

```tsx
// In Next.js, this file would be called: app/providers.tsx
'use client'

// Since QueryClientProvider relies on useContext under the hood, we have to put 'use client' on top
import {
  isServer,
  QueryClient,
  QueryClientProvider,
} from '@tanstack/react-query'

function makeQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: {
        // With SSR, we usually want to set some default staleTime
        // above 0 to avoid refetching immediately on the client
        staleTime: 60 * 1000,
      },
    },
  })
}

let browserQueryClient: QueryClient | undefined = undefined

function getQueryClient() {
  if (isServer) {
    // Server: always make a new query client
    return makeQueryClient()
  } else {
    // Browser: make a new query client if we don't already have one
    // This is very important, so we don't re-make a new client if React
    // suspends during the initial render. This may not be needed if we
    // have a suspense boundary BELOW the creation of the query client
    if (!browserQueryClient) browserQueryClient = makeQueryClient()
    return browserQueryClient
  }
}

export default function Providers({ children }: { children: React.ReactNode }) {
  // NOTE: Avoid useState when initializing the query client if you don't
  //       have a suspense boundary between this and the code that may
  //       suspend because React will throw away the client on the initial
  //       render if it suspends and there is no boundary
  const queryClient = getQueryClient()

  return (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  )
}
```

--------------------------------

### Set focusManager using AppState - React Native (TypeScript)

Source: https://tanstack.com/query/v5/docs/framework/react/react-native

Map React Native AppState changes to React Query's focusManager to enable refetch-on-focus behavior. Requires react-native and @tanstack/react-query; registers an AppState change listener and cleans it up on unmount. Limitation: the example skips web (Platform.OS !== 'web') to avoid interfering with browser behavior.

```tsx
import { useEffect } from 'react'
import { AppState, Platform } from 'react-native'
import type { AppStateStatus } from 'react-native'
import { focusManager } from '@tanstack/react-query'

function onAppStateChange(status: AppStateStatus) {
  if (Platform.OS !== 'web') {
    focusManager.setFocused(status === 'active')
  }
}

useEffect(() => {
  const subscription = AppState.addEventListener('change', onAppStateChange)

  return () => subscription.remove()
}, [])
```

--------------------------------

### Get multiple queries' cached data - TypeScript (TSX)

Source: https://tanstack.com/query/v5/docs/reference/QueryClient

Synchronously retrieve cached data for multiple queries matching a queryKey or a QueryFilters object. Depends on a QueryClient and optional QueryFilters. Returns an array of tuples [queryKey, data] or an empty array if no matches; data types may vary so TData defaults to unknown.

```tsx
const data = queryClient.getQueriesData(filters)
```

--------------------------------

### AsyncStorage Interface - Async Storage Implementation

Source: https://tanstack.com/query/v5/docs/framework/solid/plugins/createPersister

Defines the interface for asynchronous storage implementations supporting promise-based getItem, setItem, removeItem operations and optional entries method for retrieving all stored key-value pairs.

```typescript
interface AsyncStorage<TStorageValue = string> {
  getItem: (key: string) => MaybePromise<TStorageValue | undefined | null>
  setItem: (key: string, value: TStorageValue) => MaybePromise<unknown>
  removeItem: (key: string) => MaybePromise<void>
  entries?: () => MaybePromise<Array<[key: string, value: TStorageValue]>>
}
```

--------------------------------

### queryOptions function

Source: https://tanstack.com/query/v5/docs/framework/solid/reference/queryOptions

This function allows you to generate query options that can be used with various TanStack Query functions like `useQuery` or `queryClient.prefetchQuery`. It provides a structured way to define query behavior and keys.

```APIDOC
## queryOptions function

### Description
This function allows you to generate query options that can be used with various TanStack Query functions like `useQuery` or `queryClient.prefetchQuery`. It provides a structured way to define query behavior and keys.

### Function Signature
`queryOptions(options: object)`

### Parameters
#### Options Object Fields
- **queryKey** (QueryKey) - Required - The query key to generate options for.
- **experimental_prefetchInRender** (boolean) - Optional - Defaults to `false`. When set to `true`, queries will be prefetched during render, which can be useful for certain optimization scenarios. Needs to be turned on for the experimental `useQuery().promise` functionality.
- **...options** (object) - Optional - Other options generally accepted by `useQuery` can be passed here. Note that some options may have no effect when forwarded to functions like `queryClient.prefetchQuery`.

### Example Usage
```tsx
queryOptions({
  queryKey,
  ...options,
})
```

### Return Value
Returns an object containing the specified query options, suitable for use with TanStack Query.
```

--------------------------------

### Illustrating Global State Before TanStack Query (TypeScript/React)

Source: https://tanstack.com/query/v5/docs/framework/react/guides/does-this-replace-client-state

This TypeScript/React example shows a typical global state object managed by a client-state library, containing both client-specific UI state (themeMode, sidebarStatus) and server-derived data (projects, teams, tasks, users) before migrating to a server-state manager like TanStack Query. It highlights the common practice of storing asynchronous data within client-state, which can lead to inefficiencies and boilerplate.

```tsx
const globalState = {
  projects,
  teams,
  tasks,
  users,
  themeMode,
  sidebarStatus,
}
```

--------------------------------

### Implement reactivity with Svelte runes for @tanstack/svelte-query (TypeScript)

Source: https://tanstack.com/query/v5/docs/framework/svelte/migrate-from-v5-to-v6

Shows how reactivity is simplified in `@tanstack/svelte-query` v6 with Svelte runes. The `$state` declaration replaces `writable` and inputs no longer require `derived` or `$derived` wrappers, streamlining reactive query definitions.

```typescript
let intervalMs = $state(1000)

const query = createQuery(() => ({
    queryKey: ['refetch'],
    queryFn: async () => await fetch('/api/data').then((r) => r.json()),
    refetchInterval: intervalMs,
}))
```

--------------------------------

### Placeholder Data as Function - TanStack Query

Source: https://tanstack.com/query/v5/docs/framework/solid/guides/placeholder-query-data

Demonstrates using a function for placeholderData to access previous successful query data. This enables seamless transitions between queries with changing keys (e.g., pagination) by displaying old data instead of loading spinners, improving user experience during data transitions.

```tsx
const result = useQuery(() => ({
  queryKey: ['todos', id],
  queryFn: () => fetch(`/todos/${id}`),
  placeholderData: (previousData, previousQuery) => previousData,
}))
```

--------------------------------

### Implementing a Lazy Query with Conditional 'enabled' in Angular TypeScript

Source: https://tanstack.com/query/v5/docs/framework/angular/guides/disabling-queries

This example illustrates creating a 'lazy query' that only fetches data when a specific condition is met, such as when a filter value is present. By binding the `enabled` option to a reactive signal (`!!this.filter()`), the query will automatically enable and execute when the condition becomes true, demonstrating a declarative approach to fetching.

```angular-ts
@Component({
  selector: 'todos',
  template: `
    <div>
      // üöÄ applying the filter will enable and execute the query
      <filters-form onApply="filter.set" />
      <todos-table data="query.data()" />
    </div>
  `,
})
export class TodosComponent {
  filter = signal('')

  todosQuery = injectQuery(() => ({
    queryKey: ['todos', this.filter()],
    queryFn: () => fetchTodos(this.filter()),
    enabled: !!this.filter(),
  }))
}
```