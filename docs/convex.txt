### Create TanStack Start App with Convex

Source: https://context7_llms

Quick setup command to scaffold a new TanStack Start application with Convex integration preconfigured. This is the fastest way to get started with both frameworks together.

```bash
npm create convex@latest -- -t tanstack-start
```

--------------------------------

### Running the Convex Agent Example Project (Bash)

Source: https://context7_llms

This sequence of shell commands outlines the steps to clone, set up, and run the Convex Agent example repository. It involves using Git to fetch the project, navigating into the directory, and then executing npm scripts for initial setup and starting the example application.

```bash
git clone https://github.com/get-convex/agent.git
cd agent
npm run setup
npm run example
```

--------------------------------

### Install Convex and React Query Dependencies

Source: https://docs.convex.dev/quickstart/tanstack-start

Installs the Convex client library, along with several React Query and TanStack Router packages required for integrating Convex with TanStack Start. These packages enable efficient data fetching, caching, and state management within the application.

```bash
npm install convex @convex-dev/react-query @tanstack/react-router-with-query @tanstack/react-query
```

--------------------------------

### Initialize TanStack Start Project with Convex

Source: https://docs.convex.dev/quickstart/tanstack-start

Initializes a new TanStack Start project pre-configured with Convex using the Convex CLI. This command streamlines the setup process for new applications, creating a scaffolded project ready for Convex integration.

```bash
npm create convex@latest -- -t tanstack-start
```

--------------------------------

### Install Convex and Dotenv Packages

Source: https://docs.convex.dev/quickstart/nodejs

Installs the Convex client library for interacting with Convex and the dotenv library for managing environment variables.

```bash
npm install convex dotenv
```

--------------------------------

### Create a New TanStack Start Application

Source: https://docs.convex.dev/quickstart/tanstack-start

Generates a new TanStack Start application from scratch using the official `create-start-app` CLI tool. This is an alternative to the Convex-specific quickstart command, providing a clean slate for development.

```bash
npx create-start-app@latest
```

--------------------------------

### Set Up and Run RAG Example Project via Shell

Source: https://docs.convex.dev/agents/rag

This set of commands provides instructions to clone, set up dependencies, and execute a RAG (Retrieval-Augmented Generation) example project from a GitHub repository. It covers cloning the repository, navigating into its directory, installing necessary packages, and running the example application.

```shell
git clone https://github.com/get-convex/rag.git
cd rag
npm run setup
npm run example
```

--------------------------------

### Check Git Installation

Source: https://docs.convex.dev/tutorial

Verifies if Git is installed on the system. Git is required to clone the example project repository from GitHub.

```shell
git -v
```

--------------------------------

### Initialize New Convex Project with Auth Support

Source: https://labs.convex.dev/auth/setup

This command initiates a new Convex project, allowing you to select a frontend framework like React (Vite) and opt for Convex Auth integration during the setup process.

```bash
npm create convex@latest
```

--------------------------------

### Install Convex Library CLI

Source: https://docs.convex.dev/quickstart/remix

Commands to navigate into the created Remix app directory and install the Convex client library. This step is crucial for enabling Convex functionality within the Remix project.

```bash
cd my-remix-app && npm install convex
```

--------------------------------

### Install Rust Convex client and dependencies

Source: https://docs.convex.dev/quickstart/rust

Installs the necessary Rust libraries for interacting with Convex, the Tokio asynchronous runtime, and dotenvy for managing environment variables. Also includes the npm installation for the Convex backend.

```bash
npm init -y && npm install convex && cargo add convex tokio dotenvy
```

--------------------------------

### Run Convex Auth Project Initialization Command

Source: https://labs.convex.dev/auth/setup

Execute this command to perform initial setup tasks required for Convex Auth within your project. This configures the project to work seamlessly with the authentication library.

```bash
npx @convex-dev/auth
```

--------------------------------

### Install Convex Client and Server Library

Source: https://docs.convex.dev/quickstart/nextjs

Install the Convex package in the Next.js project directory. This provides the necessary client and server libraries to integrate Convex backend functionality with your Next.js application.

```bash
cd my-app && npm install convex
```

--------------------------------

### Initialize Convex Client and Query Data (HTML/JavaScript)

Source: https://docs.convex.dev/quickstart/script-tag

Initializes a `ConvexClient` with a provided Convex deployment URL and sets up a real-time update listener for the `tasks:get` query. When data changes, it logs the text of each task to the console.

```html
<!doctype html>
<script src="https://unpkg.com/convex@1.3.1/dist/browser.bundle.js"></script>
<script>
  const CONVEX_URL = "CONVEX_URL_GOES_HERE";
  const client = new convex.ConvexClient(CONVEX_URL);
  client.onUpdate("tasks:get", {}, (tasks) =>
    console.log(tasks.map((task) => task.text)),
  );
</script>
```

--------------------------------

### Install Convex Client Library

Source: https://docs.convex.dev/client/nextjs/pages-router/quickstart

Installs the Convex client library into an existing Next.js project. This library provides the necessary tools to interact with your Convex backend from the frontend.

```bash
cd my-app && npm install convex
```

--------------------------------

### Install Convex Packages

Source: https://docs.convex.dev/quickstart/svelte

Installs the core `convex` library and the `convex-svelte` integration package into your SvelteKit project. These are essential for connecting your Svelte frontend with your Convex backend.

```bash
cd my-app && npm install convex convex-svelte
```

--------------------------------

### GET /tasks

Source: https://docs.convex.dev/quickstart/tanstack-start

Retrieves all tasks stored in the Convex database. This endpoint is used to fetch a list of task items for display.

```APIDOC
## GET /tasks

### Description
Retrieves all tasks currently stored in the Convex database. This endpoint is used to fetch a list of task items for display in the application.

### Method
GET

### Endpoint
/tasks

### Parameters
#### Path Parameters
*(None)*

#### Query Parameters
*(None)*

#### Request Body
*(None)*

### Request Example
*(No request body for GET requests)*

### Response
#### Success Response (200)
- **Array of Objects**: Each object represents a task.
  - **_id** (string) - The unique identifier of the task.
  - **text** (string) - The content or description of the task.

#### Response Example
```json
[
  {
    "_id": "123a4b5c6d7e",
    "text": "Buy groceries"
  },
  {
    "_id": "890f1g2h3i4j",
    "text": "Walk the dog"
  }
]
```
```

--------------------------------

### Install Convex Client and Server Libraries via npm

Source: https://docs.convex.dev/quickstart/android

Installs the Convex client and server libraries in the Android project's root directory using npm. This command prepares the environment for running Convex commands and managing the backend.

```bash
npm init -y
npm install convex
```

--------------------------------

### Example of Missing Imports for Jetpack Compose and Android

Source: https://docs.convex.dev/quickstart/android

Provides an example of common import declarations needed for the Android UI components and Jetpack Compose functionality used in the quickstart. These imports ensure that all necessary classes and functions are available.

```kotlin
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.enableEdgeToEdge
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.tooling.preview.Preview
import dev.convex.android.ConvexClient
import kotlinx.coroutines.flow.collect
import kotlinx.serialization.Serializable
```

--------------------------------

### Install and Initialize Convex Development Environment with npm

Source: https://context7_llms

These commands show how to install the Convex npm package into your project and then start the local Convex development server. The `npx convex dev` command initializes your backend development loop, allowing you to create and manage your Convex project.

```bash
npm i convex
```

```bash
npx convex dev
```

--------------------------------

### Create Python Script to Query Convex Data

Source: https://docs.convex.dev/quickstart/python

Develop a `main.py` script that initializes a `ConvexClient` using a URL loaded from `.env.local` or a hardcoded value. The script then demonstrates querying the `tasks:get` API and subscribing to real-time updates for the 'tasks' data.

```python
import os

from convex import ConvexClient
from dotenv import load_dotenv

load_dotenv(".env.local")
CONVEX_URL = os.getenv("CONVEX_URL")
# or you can hardcode your deployment URL instead
# CONVEX_URL = "https://happy-otter-123.convex.cloud"

client = ConvexClient(CONVEX_URL)

print(client.query("tasks:get"))

for tasks in client.subscribe("tasks:get"):
    print(tasks)
    # this loop lasts forever, ctrl-c to exit it
```

--------------------------------

### Create Nuxt Application

Source: https://docs.convex.dev/quickstart/nuxt

Command to create a new Nuxt application using the official creation tool. This command bootstraps a new Nuxt project, serving as the starting point for integrating Convex.

```bash
npm create nuxt@latest my-nuxt-app
```

--------------------------------

### Install Convex Vue Library

Source: https://docs.convex.dev/quickstart/vue

Command to install the convex-vue npm package, which provides the necessary tools to integrate Convex with a Vue application.

```bash
cd my-vue-app && npm install convex-vue
```

--------------------------------

### Install Convex Auth NPM Packages

Source: https://labs.convex.dev/auth/setup

Install the core Convex Auth library and its dependency, `@auth/core`, into your project. These packages are essential for implementing Convex-based authentication functionalities.

```bash
npm install @convex-dev/auth @auth/core@0.37.0
```

--------------------------------

### Install Convex and Nuxt Module

Source: https://docs.convex.dev/quickstart/nuxt

Installs the Convex library and the convex-nuxt module required for integrating Convex with a Nuxt application. This involves using npm to add the packages to your project's dependencies.

```bash
cd my-nuxt-app && npm install convex && npx nuxi module add convex-nuxt
```

--------------------------------

### Start React Native Development Server

Source: https://docs.convex.dev/quickstart/react-native

Starts the Expo development server, allowing you to run and debug the React Native application on a physical device or simulator. Typically accessed via a QR code.

```bash
npm start
```

--------------------------------

### Configure TanStack Start Root Route with QueryClient

Source: https://docs.convex.dev/quickstart/tanstack-start

Modifies the `__root.tsx` file to integrate `QueryClient` into the router context, making React Query available throughout the TanStack Start application. It also defines the basic HTML structure for the root component, including head content and scripts.

```typescript
import { QueryClient } from "@tanstack/react-query";
import { createRootRouteWithContext } from "@tanstack/react-router";
import { Outlet, Scripts, HeadContent } from "@tanstack/react-router";
import * as React from "react";

export const Route = createRootRouteWithContext<{
  queryClient: QueryClient;
}>()({
  head: () => ({
    meta: [
      {
        charSet: "utf-8",
      },
      {
        name: "viewport",
        content: "width=device-width, initial-scale=1",
      },
      {
        title: "TanStack Start Starter",
      },
    ],
  }),
  component: RootComponent,
});

function RootComponent() {
  return (
    <RootDocument>
      <Outlet />
    </RootDocument>
  );
}

function RootDocument({ children }: { children: React.ReactNode }) {
  return (
    <html>
      <head>
        <HeadContent />
      </head>
      <body>
        {children}
        <Scripts />
      </body>
    </html>
  );
}
```

--------------------------------

### Rust client to query Convex data

Source: https://docs.convex.dev/quickstart/rust

Connects to a Convex deployment using a URL from environment variables, creates a `ConvexClient`, and executes the 'tasks:get' query. The result is then printed to the console.

```rust
use std::{
    collections::BTreeMap,
    env,
};

use convex::ConvexClient;

#[tokio::main]
async fn main() {
    dotenvy::from_filename(".env.local").ok();
    dotenvy::dotenv().ok();

    let deployment_url = env::var("CONVEX_URL").unwrap();

    let mut client = ConvexClient::new(&deployment_url).await.unwrap();
    let result = client.query("tasks:get", BTreeMap::new()).await.unwrap();
    println!("{result:#?}");
}
```

--------------------------------

### Initialize and Use Convex Client in Android Kotlin

Source: https://docs.convex.dev/quickstart/android

This snippet demonstrates the basic setup for initializing the ConvexClient in an Android Kotlin application. It includes necessary imports and shows how to potentially interact with Convex services for real-time data management. Dependencies include androidx.compose and dev.convex.android.

```kotlin
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import dev.convex.android.ConvexClient
import kotlinx.serialization.Serializable
```

--------------------------------

### Run Example App Development Server with Component Type-Checking

Source: https://docs.convex.dev/components/authoring

This command starts the Convex development server for an example application that integrates with the component. It generates code for the example app and deploys it, with the `--typecheck-components` flag optionally enabling type-checking for the components. This allows developers to test the bundled component within a live application environment, ensuring proper integration and type safety.

```shell
npx convex dev --typecheck-components # optionally type-check the components
```

--------------------------------

### Configure TanStack Router with Convex Provider

Source: https://docs.convex.dev/quickstart/tanstack-start

Replaces the `app/router.tsx` file to set up the TanStack Router with a `QueryClient` and wrap the entire application with `ConvexProvider`. It initializes `ConvexQueryClient` using an environment variable and configures `react-query` to work seamlessly with Convex data fetching.

```typescript
import { createRouter } from "@tanstack/react-router";
import { QueryClient } from "@tanstack/react-query";
import { routerWithQueryClient } from "@tanstack/react-router-with-query";
import { ConvexQueryClient } from "@convex-dev/react-query";
import { ConvexProvider } from "convex/react";
import { routeTree } from "./routeTree.gen";

export function getRouter() {
  const CONVEX_URL = (import.meta as any).env.VITE_CONVEX_URL!;
  if (!CONVEX_URL) {
    console.error("missing envar VITE_CONVEX_URL");
  }
  const convexQueryClient = new ConvexQueryClient(CONVEX_URL);

  const queryClient: QueryClient = new QueryClient({
    defaultOptions: {
      queries: {
        queryKeyHashFn: convexQueryClient.hashFn(),
        queryFn: convexQueryClient.queryFn(),
      },
    },
  });
  convexQueryClient.connect(queryClient);

  const router = routerWithQueryClient(
    createRouter({
      routeTree,
      defaultPreload: "intent",
      context: { queryClient },
      scrollRestoration: true,
      Wrap: ({ children }) => (
        <ConvexProvider client={convexQueryClient.convexClient}>
          {children}
        </ConvexProvider>
      ),
    }),
    queryClient,
  );

  return router;
}
```

--------------------------------

### Initialize Node.js Project and Install Convex Client

Source: https://context7_llms

This command-line snippet initializes a new Node.js project with default settings and then installs the Convex client and server library. This sets up the local environment required for interacting with and deploying a Convex backend. It's a prerequisite for running Convex commands.

```bash
npm init -y
npm install convex
```

--------------------------------

### Setup Convex Client in SvelteKit Layout (TypeScript)

Source: https://docs.convex.dev/quickstart/svelte

Initializes the Convex client within the main SvelteKit layout file (`src/routes/+layout.svelte`). It uses `setupConvex` from `convex-svelte` and makes the client available throughout the application.

```typescript
<script lang="ts">
	import { PUBLIC_CONVEX_URL } from '$env/static/public';
	import { setupConvex } from 'convex-svelte';

	const { children } = $props();
	setupConvex(PUBLIC_CONVEX_URL);
</script>

{@render children()}
```

--------------------------------

### Deploy Example App with Component Type Checking

Source: https://context7_llms

Generates code for the example app and deploys it after the component package is built. The --typecheck-components flag optionally validates component types. This final step ensures the example app imports the bundled component version.

```bash
npx convex dev --typecheck-components
```

--------------------------------

### Initialize Node.js Project and Set Type

Source: https://docs.convex.dev/quickstart/nodejs

Creates a new npm project and configures it to use ES Modules.

```bash
mkdir my-project && cd my-project && npm init -y && npm pkg set type="module"
```

--------------------------------

### Clone and Install Convex Tutorial Project

Source: https://docs.convex.dev/tutorial

Instructions to set up the Convex chat application tutorial project locally. This involves cloning the official GitHub repository and installing all necessary Node.js dependencies using npm.

```bash
git clone https://github.com/get-convex/convex-tutorial.git
cd convex-tutorial
npm install
```

--------------------------------

### Initialize React Application with npm

Source: https://context7_llms

Creates a new React project using Vite with the recommended configuration. This command sets up the project structure and installs dependencies needed to begin development.

```bash
npm create vite@latest my-react-app -- --template react
```

--------------------------------

### Install Convex Client and Svelte Libraries

Source: https://context7_llms

Navigates into the newly created SvelteKit project directory and installs the necessary `convex` and `convex-svelte` packages. These dependencies enable the Svelte application to interact with the Convex backend.

```bash
cd my-app && npm install convex convex-svelte
```

--------------------------------

### Create TanStack Start App

Source: https://context7_llms

Initialize a new TanStack Start application using the official create-start-app command. This creates the base project structure for a TanStack Start framework.

```bash
npx create-start-app@latest
```

--------------------------------

### Install Convex Agent Component

Source: https://context7_llms

Install the @convex-dev/agent package via npm and configure it in the convex.config.ts file using the defineApp and use pattern. This setup must be completed before defining agents and requires running npx convex dev to generate component code.

```bash
npm install @convex-dev/agent
```

```typescript
// convex/convex.config.ts
import { defineApp } from "convex/server";
import agent from "@convex-dev/agent/convex.config";

const app = defineApp();
app.use(agent);

export default app;
```

--------------------------------

### Install Convex Libraries for Python and JavaScript

Source: https://context7_llms

This command navigates into 'my-app', initializes a new npm project, installs the Convex npm package for backend development, and then installs the Convex Python client library along with `python-dotenv` for environment variable management within the virtual environment.

```bash
cd my-app && npm init -y && npm install convex && venv/bin/pip install convex python-dotenv
```

--------------------------------

### Install Convex Workflow Package

Source: https://convex.dev/components/workflow

Install the @convex-dev/workflow package to add durable workflow capabilities to your Convex project. This is the initial setup step required before configuring the workflow component.

```bash
npm install @convex-dev/workflow
```

--------------------------------

### Install Convex ESLint Plugin

Source: https://docs.convex.dev/eslint

Install the @convex-dev/eslint-plugin package for ESLint 9 with flat config support. This is the recommended setup for modern ESLint versions.

```bash
npm i @convex-dev/eslint-plugin --save-dev
```

--------------------------------

### Structure SwiftUI View with ViewModel for Convex Subscription

Source: https://context7_llms

This Swift example demonstrates a structured approach to integrate Convex data fetching into a SwiftUI application using the ObservableObject pattern. A ViewModel subscribes to a Convex query ('colors:get') and publishes its results, allowing a ContentView to observe and display the data without direct data fetching logic. This setup enhances modularity and testability by decoupling the UI from data management.

```swift
import SwiftUI

class ViewModel: ObservableObject {
  @Published var colors: [String] = []

  init() {
    convex.subscribe(to: "colors:get")
      .replaceError(with: [])
      .receive(on: DispatchQueue.main)
      .assign(to: &$colors)
  }
}

struct ContentView: View {
  @StateObject var viewModel = ViewModel()

  var body: some View {
    List {
      ForEach(viewModel.colors, id: \.self) { color in
        Text(color)
      }
    }
  }
}
```

--------------------------------

### Configure Authentication with Auth0 (Kotlin)

Source: https://docs.convex.dev/client/android

Provides an example of how to use `ConvexClientWithAuth` for authentication, specifically with Auth0. This requires the `convex-android-auth0` library and proper Auth0 account configuration. The example implies setup for using authenticated clients.

```kotlin
val auth0Config = Auth0Config("YOUR_DOMAIN", "YOUR_CLIENT_ID")
val authenticatedClient = ConvexClientWithAuth.create(context, auth0Config)
```

--------------------------------

### Install Clerk React SDK (Shell)

Source: https://docs.convex.dev/auth/clerk

This command installs the `@clerk/clerk-react` package, which provides the necessary React components and hooks for integrating Clerk authentication into a React application. It's a prerequisite for using Clerk's client-side authentication features.

```shell
npm install @clerk/clerk-react
```

--------------------------------

### Create Remix App CLI

Source: https://docs.convex.dev/quickstart/remix

Command to create a new Remix application. This command initializes a basic Remix project structure, setting the foundation for the web application.

```bash
npx create-remix@latest my-remix-app
```

--------------------------------

### Install Convex Client and Dotenv Library

Source: https://context7_llms

Install the necessary npm packages: 'convex' provides the client for interacting with Convex, and 'dotenv' is used for loading environment variables from .env files.

```bash
npm install convex dotenv
```

--------------------------------

### Configure Convex Development with Options

Source: https://docs.convex.dev/cli/local-deployments

Run the Convex configuration flow which provides the option to select a local deployment. This command guides through setup for cloud or local deployments depending on your project state and preferences.

```bash
npx convex dev --configure
```

--------------------------------

### Connect Node.js Script to Convex Backend

Source: https://docs.convex.dev/quickstart/nodejs

Initializes a `ConvexHttpClient` using the development environment URL stored in `.env.local` and imports the Convex API definitions. It then calls the `api.tasks.get` query.

```javascript
import { ConvexHttpClient } from "convex/browser";
import { api } from "./convex/_generated/api.js";
import * as dotenv from "dotenv";
dotenv.config({ path: ".env.local" });

const client = new ConvexHttpClient(process.env["CONVEX_URL"]);

client.query(api.tasks.get).then(console.log);
```

--------------------------------

### HTTP Router Setup and Configuration

Source: https://context7_llms

Configure HTTP routes for handling GET, POST, PUT, DELETE, PATCH, and OPTIONS requests in Convex applications. The HttpRouter class manages path-based routing with support for exact paths and prefix-based paths.

```APIDOC
## HttpRouter Class

### Description
HTTP router for specifying the paths and methods of httpActionGeneric handlers. Manages routing configuration for Convex HTTP actions with support for exact path matching and prefix-based routing.

### Constructor
```
const http = new HttpRouter();
```

### Properties
- **exactRoutes** (Map) - Maps exact paths to HTTP method handlers
- **prefixRoutes** (Map) - Maps HTTP methods to prefix-based path handlers
- **isRouter** (boolean) - Always true, identifies object as router

### Methods

#### route(spec)
Specify an HttpAction to be used to respond to requests for an HTTP method and a path or pathPrefix.

**Parameters:**
- **spec** (RouteSpec) - Required - Route specification object

**Route Specification Options:**
- **path** (string) - Required - Exact path starting with `/` (e.g., `/profile`)
- **pathPrefix** (string) - Required - Prefix path starting and ending with `/` (e.g., `/profile/`)
- **method** (string) - Required - HTTP method: GET, POST, PUT, DELETE, OPTIONS, PATCH
- **handler** (PublicHttpAction) - Required - HTTP action handler function

**Returns:** void

#### getRoutes()
Returns a list of all routed HTTP actions used by the Convex dashboard.

**Returns:** readonly [string, method, PublicHttpAction][] - Array of [path, method, endpoint] tuples

### Usage Example
```javascript
import { httpRouter } from "convex/server";
import { httpAction } from "./_generated/server";

const http = httpRouter();

// Exact path matching - matches /profile only
http.route({
  path: "/profile",
  method: "GET",
  handler: httpAction(async (ctx, request) => {
    return new Response("Profile data", { status: 200 });
  })
});

// Prefix matching - matches /profiles/, /profiles/abc, /profiles/a/c/b
http.route({
  pathPrefix: "/profiles/",
  method: "GET",
  handler: httpAction(async (ctx, request) => {
    return new Response("User profiles", { status: 200 });
  })
});

// POST handler with request body
http.route({
  path: "/message",
  method: "POST",
  handler: httpAction(async (ctx, request) => {
    const { author, body } = await request.json();
    return new Response(null, { status: 200 });
  })
});

export default http;
```

### Supported HTTP Methods
- GET
- POST
- PUT
- DELETE
- PATCH
- OPTIONS
```

--------------------------------

### Install Convex Client for Bun (Shell)

Source: https://context7_llms

Installs the Convex client library into the Bun project. This package provides the necessary tools and functions to interact with a Convex backend from a Bun application.

```shell
bun add convex
```

--------------------------------

### Create React App with Vite and TypeScript

Source: https://docs.convex.dev/quickstart/react

This command initializes a new React project using Vite as the build tool and TypeScript for type safety. It serves as the foundation for the Convex integration.

```bash
npm create vite@latest my-app -- --template react-ts
```

--------------------------------

### Integrate NPM Packages in Convex Queries (Shell, TypeScript)

Source: https://context7_llms

This snippet illustrates how to install and utilize NPM packages within Convex queries. It includes a shell command for installing `@faker-js/faker` and a TypeScript example demonstrating its use to generate random names within a Convex query. Note that not all NPM packages are supported.

```shell
npm install @faker-js/faker
```

```typescript
import { query } from "./_generated/server";
import { faker } from "@faker-js/faker";

export const randomName = query({
  args: {},
  handler: () => {
    faker.seed();
    return faker.person.fullName();
  },
});
```

--------------------------------

### Start Convex Development Server (Shell)

Source: https://context7_llms

Executes the Convex development command using Bun, which initiates a login process, creates a new Convex project, and saves deployment URLs. It also sets up a 'convex/' folder for backend functions and keeps running to sync them with the cloud deployment.

```shell
bunx convex dev
```

--------------------------------

### Create SvelteKit App

Source: https://docs.convex.dev/quickstart/svelte

Command to create a new SvelteKit application. Ensures necessary configurations for TypeScript and minimal template are selected for compatibility with Convex integration.

```bash
npx sv@latest create my-app
```

--------------------------------

### Create Next.js App with create-next-app

Source: https://docs.convex.dev/quickstart/nextjs

Initialize a new Next.js project using the official create-next-app command. This command scaffolds a complete Next.js application with default configurations by accepting all prompts with Enter.

```bash
npx create-next-app@latest my-app
```

--------------------------------

### Install and Run Convex Locally

Source: https://docs.convex.dev/ai/using-cursor

These commands demonstrate how to install and run the Convex development server locally. Keeping the Convex server running is essential for automatically generating client-side types, which prevents AI agents from encountering linting issues due to inaccessible type information.

```bash
npm install convex
npx convex dev
```

--------------------------------

### Display Tasks with TanStack React Query in React (TypeScript)

Source: https://docs.convex.dev/quickstart/tanstack-start

This React component, `Home`, uses `useSuspenseQuery` with `convexQuery(api.tasks.get, {})` to fetch tasks. It maps over the `data` array and renders each task's `text` within a `div`, displaying a live list of tasks. The component is part of `app/routes/index.tsx` and leverages server-side rendering and live updates.

```typescript
import { convexQuery } from "@convex-dev/react-query";
import { useSuspenseQuery } from "@tanstack/react-query";
import { createFileRoute } from "@tanstack/react-router";
import { api } from "../../convex/_generated/api";

export const Route = createFileRoute("/")({
  component: Home,
});

function Home() {
  const { data } = useSuspenseQuery(convexQuery(api.tasks.get, {}));

  return (
    <div>
      {data.map(({ _id, text }) => (
        <div key={_id}>{text}</div>
      ))}
    </div>
  );
}
```

--------------------------------

### Implement Composable UI to Display Tasks

Source: https://docs.convex.dev/quickstart/android

Creates a Jetpack Compose `@Composable` function 'Tasks' that subscribes to the 'tasks:get' query from the Convex deployment. It displays the fetched tasks in a LazyColumn, updating the UI when new data is received.

```kotlin
@Composable
fun Tasks(client: ConvexClient, modifier: Modifier = Modifier) {
    var tasks: List<Task> by remember { mutableStateOf(listOf())
    LaunchedEffect(key1 = "launch") {
        client.subscribe<List<Task>>("tasks:get").collect {
            result ->
            result.onSuccess { remoteTasks ->
                tasks = remoteTasks
            }
        }
    }
    LazyColumn(
        modifier = modifier
    ) {
        items(tasks) { task ->
            Text(text = "Text: ${task.text}, Completed?: ${task.isCompleted}")
        }
    }
}
```

--------------------------------

### Bun Project Initialization and Dependency Installation

Source: https://docs.convex.dev/quickstart/bun

Initializes a new Bun project and installs the necessary Convex client and server libraries. This sets up the basic structure for a Bun application and adds Convex as a dependency.

```bash
mkdir my-project && cd my-project && bun init -y
bun add convex
```

--------------------------------

### Install Convex npm Package

Source: https://context7_llms

This command first navigates into the newly created Remix project directory. Then, it installs the `convex` npm package, which provides the necessary client libraries for interacting with the Convex backend.

```bash
cd my-remix-app && npm install convex
```

--------------------------------

### Add Authentication Tables to Convex Schema

Source: https://labs.convex.dev/auth/setup

Integrate the predefined authentication tables from `@convex-dev/auth/server` into your Convex `defineSchema`. This ensures that your Convex backend has the necessary database structures for user authentication.

```typescript
import { defineSchema } from "convex/server";
import { authTables } from "@convex-dev/auth/server";

const schema = defineSchema({
  ...authTables,
  // Your other tables...
});

export default schema;
```

--------------------------------

### Integrate NPM Packages in Convex Mutations (Bash/TypeScript)

Source: https://docs.convex.dev/functions/mutation-functions

This section illustrates how to install and utilize external NPM packages within your Convex mutations. It provides a `npm install` command for adding a package and then shows a TypeScript example of a mutation using `@faker-js/faker` to generate data, demonstrating package integration. Note that not all NPM packages are supported.

```bash
npm install @faker-js/faker
```

```TypeScript
import { faker } from "@faker-js/faker";
import { mutation } from "./_generated/server";

export const randomName = mutation({
  args: {},
  handler: async (ctx) => {
    faker.seed();
    await ctx.db.insert("tasks", { text: "Greet " + faker.person.fullName() });
  },
});
```

--------------------------------

### Setup Complex Test Data with Test-Only Mutations

Source: https://stack.convex.dev/testing-with-local-oss-backend

Uses test-only mutations to establish complex initial state for testing. Example shows setting up a chess game near completion with specific player IDs and game state (PGN notation). Enables testing of functions that operate on pre-established data.

```typescript
// Two moves before the end of the game
const gameAlmostFinishedPgn = "1. Nf3 Nf6 2. d4 Nc6 3. e4 Nxe4" /* ... */

const gameId = await t.mutation(api.testing.setupGame, {
  player1: sarahId,
  player2: leeId,
  pgn: gameAlmostFinishedPgn,
  finished: false
});
```

--------------------------------

### Run Node.js Script to Fetch Data

Source: https://docs.convex.dev/quickstart/nodejs

Executes the `script.js` file using Node.js to fetch and log the tasks from the Convex database to the terminal.

```bash
node script.js
```

--------------------------------

### Import Sample Data to Convex Database

Source: https://docs.convex.dev/client/nextjs/pages-router/quickstart

Imports data from a JSON Lines file into a specified table in your Convex database. This is useful for populating your database with initial or test data.

```bash
npx convex import --table tasks sampleData.jsonl
```

--------------------------------

### Create React Native App

Source: https://docs.convex.dev/quickstart/react-native

Initializes a new React Native project using Expo CLI. This command sets up the basic project structure and dependencies required for a React Native application.

```bash
npx create-expo-app my-app
```

--------------------------------

### Install Project Dependencies (npm)

Source: https://docs.convex.dev/chef

This command installs all necessary dependencies for your Convex project using npm. Run this after navigating to your app's directory to ensure all required packages are available for development.

```bash
npm i
```

--------------------------------

### Install Convex Package

Source: https://context7_llms

Install the Convex client library for React applications. Navigate to the project directory and install the convex package via npm to enable Convex functionality in your Next.js app.

```bash
cd my-app && npm install convex
```

--------------------------------

### Install and Configure Convex Component via convex.config.ts

Source: https://context7_llms

Demonstrates how to install a Convex Component (Agent) using npm and configure it in the convex.config.ts file. Multiple instances of the same component can be registered with different names, each maintaining isolated tables and functions. The configuration uses the defineApp() function and component.use() method.

```bash
npm i @convex-dev/agent
```

```typescript
import { defineApp } from "convex/server";
import agent from "@convex-dev/agent/convex.config.js";

const app = defineApp();

app.use(agent);
app.use(agent, { name: "agent2" });
//... Add other components here

export default app;
```

--------------------------------

### Initialize a new npm project

Source: https://context7_llms

This command creates a new directory, navigates into it, and initializes a new npm project with default settings, preparing it for Convex integration.

```shell
mkdir my-project && cd my-project && npm init -y
```

--------------------------------

### Create Python Virtual Environment

Source: https://docs.convex.dev/quickstart/python

This command creates a new directory for your Python application and sets up a virtual environment within it to manage project dependencies.

```shell
python3 -m venv my-app/venv
```

--------------------------------

### Create a New SvelteKit Application

Source: https://context7_llms

Initializes a new SvelteKit project named 'my-app' using the `npx sv create` command. This setup creates a minimal SvelteKit app with TypeScript and npm as the package manager, serving as the foundation for integrating Convex.

```bash
npx sv@latest create my-app
```

--------------------------------

### Advanced Context Handler with Message Filtering and Memory Injection

Source: https://context7_llms

Advanced contextHandler example that filters search results, fetches user memories and sample messages, retrieves user context, and combines messages from related threads. Demonstrates enrichment patterns for guiding LLM responses and maintaining conversation context.

```JavaScript
const result = await agent.generateText(
  ctx,
  { threadId },
  { prompt },
  {
    contextHandler: async (ctx, args) => {
      const relevantSearch = args.search.filter((m) => messageIsRelevant(m));
      const userMemories = await getUserMemories(ctx, args.userId);
      const sampleMessages = [
        { role: "user", content: "Generate a function that adds two numbers" },
        { role: "assistant", content: "function add(a, b) { return a + b; }" },
      ];
      const userContext = await getUserContext(ctx, args.userId, args.threadId);
      const related = await getRelatedThreadMessages(ctx, args.threadId);
      return [
        ...(await summarizeOrTruncateIfTooLong(related)),
        ...relevantSearch,
        ...userMemories,
        ...sampleMessages,
        ...userContext,
        ...args.recent,
        ...args.inputMessages,
        ...args.inputPrompt,
        ...args.existingResponses,
      ];
    },
  },
);
```

--------------------------------

### Install Convex and Convex-Nuxt Libraries in Nuxt

Source: https://context7_llms

Navigate into your new Nuxt project directory and install the necessary Convex packages. This command adds the core `convex` library and the `convex-nuxt` module, which provides Nuxt-specific integrations for Convex. These dependencies are crucial for connecting your app to the Convex backend.

```bash
cd my-nuxt-app && npm install convex && npx nuxi module add convex-nuxt
```

--------------------------------

### Configure Root Route with QueryClient in TanStack Start

Source: https://context7_llms

Set up the root route component with QueryClient context in TanStack Start. This makes React Query available throughout the application via router context. Includes meta tags configuration and document structure.

```typescript
import { QueryClient } from "@tanstack/react-query";
import { createRootRouteWithContext } from "@tanstack/react-router";
import { Outlet, Scripts, HeadContent } from "@tanstack/react-router";
import * as React from "react";

export const Route = createRootRouteWithContext<{
  queryClient: QueryClient;
}>()({
  head: () => ({
    meta: [
      {
        charSet: "utf-8",
      },
      {
        name: "viewport",
        content: "width=device-width, initial-scale=1",
      },
      {
        title: "TanStack Start Starter",
      },
    ],
  }),
  component: RootComponent,
});

function RootComponent() {
  return (
    <RootDocument>
      <Outlet />
    </RootDocument>
  );
}

function RootDocument({ children }: { children: React.ReactNode }) {
  return (
    <html>
      <head>
        <HeadContent />
      </head>
      <body>
        {children}
        <Scripts />
      </body>
    </html>
  );
}
```

--------------------------------

### Install WorkOS AuthKit React and Convex Integration Packages

Source: https://context7_llms

This command installs the necessary npm packages for integrating WorkOS AuthKit with a React application and Convex. It includes the `@workos-inc/authkit-react` SDK for client-side authentication and the `@convex-dev/workos` library for Convex-specific integration.

```bash
npm install @workos-inc/authkit-react @convex-dev/workos
```

--------------------------------

### Connect Android App to Convex Backend URL

Source: https://docs.convex.dev/quickstart/android

Updates the `onCreate` method in `MainActivity.kt` to initialize the `ConvexClient` with the deployment URL obtained from the `.env.local` file. This establishes the connection between the Android app and the Convex backend.

```kotlin
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    enableEdgeToEdge()
    setContent {
        ConvexQuickstartTheme {
            Scaffold(modifier = Modifier.fillMaxSize()) {
                innerPadding ->
                Tasks(
                    client = ConvexClient($YOUR_CONVEX_URL),
                    modifier = Modifier.padding(innerPadding)
                )
            }
        }
    }
}
```

--------------------------------

### Import Sample Data into Convex Database

Source: https://docs.convex.dev/quickstart/python

Use the Convex CLI's `import` command to load the contents of your `sampleData.jsonl` file into a new `tasks` table within your Convex database. This populates your backend with initial data for querying.

```shell
npx convex import --table tasks sampleData.jsonl
```

--------------------------------

### Shell: Installing Convex TanStack Query Adapter via npm

Source: https://context7_llms

This command installs the `@convex-dev/react-query` library, which is essential for integrating Convex's reactive data capabilities with TanStack Query in a JavaScript/TypeScript project. This adapter provides the necessary Query Option functions.

```bash
npm i @convex-dev/react-query
```

--------------------------------

### Create a new Rust Cargo project

Source: https://docs.convex.dev/quickstart/rust

Initializes a new Rust project using Cargo, the Rust package manager. This creates a standard project structure for a new application.

```bash
cargo new my_app
cd my_app
```

--------------------------------

### Install Convex and React Query Dependencies

Source: https://context7_llms

Install the Convex client library along with React Query and TanStack Router integration packages. These dependencies enable querying Convex backend from the React frontend.

```bash
npm install convex @convex-dev/react-query @tanstack/react-router-with-query @tanstack/react-query
```

--------------------------------

### TypeScript: Example Circular Import in `convex/functions.ts`

Source: https://context7_llms

Demonstrates a file (`functions.ts`) importing from `validators.ts` and defining a mutation (`myMutation`) that uses a validator (`myValidator`). This setup creates a circular dependency where `myValidator` might be `undefined` during import time.

```ts
import { mutation } from "./_generated/server";
// Both functions.ts and validators.ts import from each other.
import { myValidator } from "./validators";

export function someUtility() {
  // ...
}

export const myMutation = mutation({
  args: {
    data: myValidator, // <-- May be undefined due to import cycle
  },
  handler: async (ctx, args) => {
    // ...
  },
});
```

--------------------------------

### Initialize Vue Application with npm

Source: https://context7_llms

Creates a new Vue project with TypeScript support using the official Vue create command. Prompts user to select project options, with TypeScript recommended for this quickstart.

```bash
npm create vue@latest my-vue-app
```

--------------------------------

### Install Action Retrier npm package

Source: https://convex.dev/components/retrier

Install the @convex-dev/action-retrier package as an NPM dependency. This is the first step in setting up the Action Retrier component for your Convex project.

```bash
npm install @convex-dev/action-retrier
```

--------------------------------

### Install Convex testing and Vitest dependencies

Source: https://docs.convex.dev/testing/convex-test

Install the necessary development dependencies, including `convex-test` for mocking Convex functions, `vitest` as the test runner, and `@edge-runtime/vm` for a compatible test environment. This command should be run in your project's root directory.

```bash
npm install --save-dev convex-test vitest @edge-runtime/vm
```

--------------------------------

### Configure Convex HTTP Router with multiple routes (TypeScript)

Source: https://docs.convex.dev/functions/http-actions

This TypeScript example shows how to configure the Convex `httpRouter` with multiple HTTP routes, including POST and GET methods, and a path prefix. It demonstrates mapping defined HTTP actions to specific URL paths and methods for a public API endpoint.

```typescript
import { httpRouter } from "convex/server";
import { postMessage, getByAuthor, getByAuthorPathSuffix } from "./messages";

const http = httpRouter();

http.route({
  path: "/postMessage",
  method: "POST",
  handler: postMessage,
});

// Define additional routes
http.route({
  path: "/getMessagesByAuthor",
  method: "GET",
  handler: getByAuthor,
});

// Define a route using a path prefix
http.route({
  // Will match /getAuthorMessages/User+123 and /getAuthorMessages/User+234 etc.
  pathPrefix: "/getAuthorMessages/",
  method: "GET",
  handler: getByAuthorPathSuffix,
});

// Convex expects the router to be the default export of `convex/http.js`.
export default http;
```

--------------------------------

### Install Convex CLI

Source: https://docs.convex.dev/using/cli

Installs the Convex command-line interface globally using npm, allowing access to Convex project and function management tools.

```bash
npm install convex
```

--------------------------------

### Install Convex Helpers npm Package

Source: https://context7_llms

Installs the `convex-helpers` npm package, which provides command-line utilities for Convex development, including the capability to generate an OpenAPI specification.

```bash
npm install convex-helpers
```

--------------------------------

### Handling Convex Workflow Results with onComplete Callback

Source: https://www.convex.dev/components/workflow

This example shows how to use the `onComplete` option when starting a workflow to define a callback handler for its completion. The `handleOnComplete` mutation processes the workflow's result, distinguishing between success, error, or cancellation. It also demonstrates passing custom `context` data from the start site to the completion handler and using validators like `vWorkflowId`, `vResultValidator`, and `v.any()`.

```typescript
import { vWorkflowId } from "@convex-dev/workflow";
import { vResultValidator } from "@convex-dev/workpool";

export const foo = mutation({
  handler: async (ctx) => {
    const name = "James";
    const workflowId = await workflow.start(
      ctx,
      internal.example.exampleWorkflow,
      { name },
      { onComplete: internal.example.handleOnComplete,
        context: name,
      },
    );
  },
});

export const handleOnComplete = mutation({
  args: {
    workflowId: vWorkflowId,
    result: vResultValidator,
    context: v.any(), // used to pass through data from the start site.
  },
  handler: async (ctx, args) => {
    const name = (args.context as { name: string }).name;
    if (args.result.kind === "success") {
      const text = args.result.returnValue;
      console.log(`${name} result: ${text}`);
    } else if (args.result.kind === "error") {
      console.error("Workflow failed", args.result.error);
    } else if (args.result.kind === "canceled") {
      console.log("Workflow canceled", args.context);
    }
  },
});
```

--------------------------------

### Initialize Remix Application with npx

Source: https://context7_llms

This command initializes a new Remix project in a directory named `my-remix-app`. It uses `npx` to execute the `create-remix` package, setting up the basic project structure and dependencies.

```bash
npx create-remix@latest my-remix-app
```

--------------------------------

### Example .env.local file for Convex Deployment

Source: https://docs.convex.dev/client/react/deployment-urls

An example of a `.env.local` file used to store environment variables for frontend applications connecting to Convex. It demonstrates setting the `NEXT_PUBLIC_CONVEX_URL` and other common environment variables like Sentry DSN and LaunchDarkly SDK ID.

```env
NEXT_PUBLIC_CONVEX_URL=https://guiltless-dog-960.convex.cloud

# examples of other environment variables that might be passed to the frontend
NEXT_PUBLIC_SENTRY_DSN=https://123abc@o123.ingest.sentry.io/1234
NEXT_PUBLIC_LAUNCHDARKLY_SDK_CLIENT_SIDE_ID=01234567890abcdef
```

--------------------------------

### Create Sample Data for Convex Database

Source: https://docs.convex.dev/quickstart/python

Generate a `sampleData.jsonl` file containing line-delimited JSON objects. Each object represents a task with a text description and a completion status, which will be imported into your Convex database.

```json
{"text": "Buy groceries", "isCompleted": true}
{"text": "Go for a swim", "isCompleted": true}
{"text": "Integrate Convex", "isCompleted": false}
```

--------------------------------

### Create Vue Site

Source: https://docs.convex.dev/quickstart/vue

Command to create a new Vue.js project using npm. It prompts the user for configuration options like TypeScript support.

```bash
npm create vue@latest my-vue-app
```

--------------------------------

### Call Convex Function via API (Python)

Source: https://docs.convex.dev/http-api

This Python snippet illustrates how to call a Convex function using the requests library. It defines the URL, headers, and request body, then makes a GET request (Note: the provided example uses GET but the endpoint is POST, this might be an error in the source) to the API. The body is expected to be JSON.

```python
import requests
import json

url = "https://acoustic-panther-728.convex.cloud/api/run/messages/list"
headers = {"accept": "application/json"}
body = {"args": {}, "format": "json"}

# Note: The provided example uses requests.get, but the endpoint is POST.
# Assuming a POST request is intended:
response = requests.post(url, headers=headers, json=body)
```

--------------------------------

### Start Local Convex Deployment for Existing Project

Source: https://docs.convex.dev/cli/local-deployments

Initialize a local Convex deployment for an existing project using the CLI. This command starts a local backend as a subprocess and enables faster development without using cloud resources. The local backend runs only while the command is active.

```bash
npx convex dev --local --once
```

--------------------------------

### Configure Convex Auth React Provider

Source: https://labs.convex.dev/auth/setup

Replace the standard `ConvexProvider` with `ConvexAuthProvider` in your React application's root file (e.g., `src/main.tsx`). This wraps your application with the authentication context, making Convex Auth features available throughout your React components.

```tsx
import { ConvexAuthProvider } from "@convex-dev/auth/react";
import React from "react";
import ReactDOM from "react-dom/client";
import { ConvexReactClient } from "convex/react";
import App from "./App.tsx";
import "./index.css";

const convex = new ConvexReactClient(import.meta.env.VITE_CONVEX_URL as string);

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <ConvexAuthProvider client={convex}>
      <App />
    </ConvexAuthProvider>
  </React.StrictMode>
);
```

--------------------------------

### Start React Native development server

Source: https://context7_llms

Launch the Expo development server which provides a QR code for scanning on your phone to run the app on your mobile device.

```bash
npm start
```

--------------------------------

### Start Convex MCP Server

Source: https://docs.convex.dev/ai/convex-mcp-server

Command to start the Convex MCP server. This is typically added to the MCP server's configuration.

```bash
npx -y convex@latest mcp start
```

--------------------------------

### Create a New Nuxt Application

Source: https://context7_llms

This command initializes a new Nuxt project named `my-nuxt-app`. It's the first step to setting up your frontend development environment. Ensure you have Node.js and npm installed to run this command successfully.

```bash
npm create nuxt@latest my-nuxt-app
```

--------------------------------

### Install Convex client and server libraries

Source: https://context7_llms

Installs the `convex` npm package for backend development and the `convex` Rust client library, `tokio` runtime, and `dotenvy` for environment variable management into the Rust project using Cargo. This sets up both the JavaScript backend and Rust client dependencies.

```bash
npm init -y && npm install convex && cargo add convex tokio dotenvy
```

--------------------------------

### Initialize Git Repository for Convex App (Git)

Source: https://docs.convex.dev/chef

These three commands initialize a new Git repository, stage all current files (including the provided `.gitignore`), and create the initial commit. This is a recommended step for version control and preparing your project for remote hosting.

```bash
git init
git add --all
git commit -m "Initial commit"
```

--------------------------------

### Install an NPM Package for Convex Functions

Source: https://docs.convex.dev/understanding/convex-fundamentals/functions

This command demonstrates how to install an NPM package, `@faker-js/faker`, for use within Convex functions. Packages installed this way will be available in your Convex backend code.

```Shell
npm install @faker-js/faker
```

--------------------------------

### Run Python Client Script

Source: https://docs.convex.dev/quickstart/python

Execute the `main.py` script using the Python interpreter from your virtual environment. This will run the client application, fetching and displaying the serialized list of tasks from your Convex database.

```shell
venv/bin/python -m main
```

--------------------------------

### Install Migrations Component Package

Source: https://www.convex.dev/components/migrations

Install the @convex-dev/migrations npm package into your Convex project. This is the first step before setting up the migrations component.

```bash
npm install @convex-dev/migrations
```

--------------------------------

### Initialize Convex client in Swift

Source: https://context7_llms

Create a ConvexClient instance with the deployment URL to establish connection to the Convex backend. The URL should be retrieved from the .env.local file generated during 'npx convex dev'.

```swift
import SwiftUI
import ConvexMobile

let convex = ConvexClient(deploymentUrl: "YOUR_CONVEX_URL")

struct ContentView: View {
  // View implementation follows
}
```

--------------------------------

### Index Range Query Example - Multi-field equality and bound

Source: https://context7_llms

Example demonstrating proper IndexRangeBuilder usage for querying messages with projectId equality and priority lower bound. Shows the required field ordering pattern for efficient index usage with chained method calls.

```typescript
q.eq("projectId", myProjectId)
 .gte("priority", 100)
```

--------------------------------

### Create Next.js App with Pages Router

Source: https://docs.convex.dev/client/nextjs/pages-router/quickstart

Initializes a new Next.js application using the Pages Router and JavaScript. This command ensures a basic project structure is set up for further development.

```bash
npx create-next-app@latest my-app --no-app --js
```

--------------------------------

### Define Convex Query Function to Fetch Tasks (JavaScript)

Source: https://docs.convex.dev/quickstart/python

Create a `tasks.js` file inside the `convex/` folder to define and export a Convex query function. This JavaScript function uses the `db` object to query all documents from the `tasks` table, making them available through a `tasks:get` API endpoint.

```javascript
import { query } from "./_generated/server";

export const get = query({
  args: {},
  handler: async ({ db }) => {
    return await db.query("tasks").collect();
  },
});
```

--------------------------------

### Implementing TanStack Start Route Loader with Convex Data Prefetching

Source: https://docs.convex.dev/client/tanstack/tanstack-start

This code defines a TanStack Start route with a loader that prefetches Convex data, optimizing client-side navigation. The `ensureQueryData` method, combined with `convexQuery`, ensures that `api.messages.list` data is available before the route component renders. The component then uses `useSuspenseQuery` to access this pre-loaded data and displays it.

```typescript
export const Route = createFileRoute('/posts')({
  loader: async (opts) => {
    await opts.context.queryClient.ensureQueryData(
      convexQuery(api.messages.list, {}),
    );
  };
  component: () => {
    const { data } = useSuspenseQuery(convexQuery(api.messages.list, {}));
    return (
      <div>
	{data.map((message) => (
	  <Message key={message.id} post={message} />
	))}
      </div>
    );
  }
})
```

--------------------------------

### Start Convex Model Context Protocol (MCP) Server

Source: https://context7_llms

This command initiates the Convex Model Context Protocol (MCP) server, which provides tools for AI agents to interact with a Convex deployment. It allows AI agents to query and optimize the project.

```bash
npx -y convex@latest mcp start
```

--------------------------------

### Initialize New Bun Project (Shell)

Source: https://context7_llms

Commands to create a new directory for a Bun project, navigate into it, and initialize a new Bun project with default settings using the '-y' flag to auto-confirm prompts.

```shell
mkdir my-project && cd my-project && bun init -y
```

--------------------------------

### GET /list_log_streams

Source: https://context7_llms

Lists configurations for all existing log streams in a deployment. Use this endpoint to get an overview of all log stream configurations.

```APIDOC
## GET /list_log_streams

### Description
List configs for all existing log streams in a deployment.

### Method
GET

### Endpoint
/list_log_streams

### Authorization
- Required: Authorization header with Convex deployment key or access token
- Format: `Authorization: Convex {token}`

### Response
#### Success Response (200)
- Returns an array of log stream configuration objects

### Example Request
```
GET /list_log_streams
Headers:
  Authorization: Convex ey...0=
```
```

--------------------------------

### Initialize Convex Client and Provider in React

Source: https://docs.convex.dev/quickstart/react

Sets up the Convex client and wraps the React application with `ConvexProvider`. This makes the Convex client instance available throughout the application, enabling data fetching and mutations.

```typescript
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import "./index.css";
import { ConvexProvider, ConvexReactClient } from "convex/react";

const convex = new ConvexReactClient(import.meta.env.VITE_CONVEX_URL as string);

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <ConvexProvider client={convex}>
      <App />
    </ConvexProvider>
  </React.StrictMode>,
);

```

--------------------------------

### Initialize Convex Client with Script Tag

Source: https://context7_llms

Creates a Convex client instance directly in an HTML file using a CDN-hosted bundle. The client subscribes to a query function and logs results to the console. This approach requires no build steps or package installation.

```html
<!doctype html>
<script src="https://unpkg.com/convex@1.3.1/dist/browser.bundle.js"></script>
<script>
  const CONVEX_URL = "CONVEX_URL_GOES_HERE";
  const client = new convex.ConvexClient(CONVEX_URL);
  client.onUpdate("messages:list", {}, (messages) =>
    console.log(messages.map((msg) => msg.body)),
  );
</script>
```

--------------------------------

### Set Clerk Production Publishable Key in .env (Environment Variable)

Source: https://docs.convex.dev/auth/clerk

This environment variable configuration sets `NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY` in `.env` for production environments. This key, formatted as `pk_live_...`, is used by Clerk's frontend SDK to initialize authentication, ensuring proper setup for live deployments.

```Environment Variable
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY="pk_live_..."
```

--------------------------------

### HTTP GET Request for Query Execution

Source: https://docs.convex.dev/public-deployment-api/public-query-get

This snippet illustrates the basic structure of an HTTP GET request used to execute a query function. It specifies the HTTP method 'GET' and the endpoint path '/query' as part of the request line.

```HTTP
GET 
/query
```

--------------------------------

### Install Clerk React SDK using npm

Source: https://docs.convex.dev/auth/clerk

Install the official Clerk React SDK package into your project using npm. This package provides the necessary components and hooks for integrating Clerk authentication into your React application.

```shell
npm install @clerk/clerk-react
```

--------------------------------

### Configure Clerk Middleware for Next.js

Source: https://docs.convex.dev/auth/clerk

This configuration snippet for Clerk middleware demonstrates how to define routes that should be ignored by Clerk's authentication process. By default, all routes are public, and you must explicitly opt-in to protect specific paths. The example shows how to ignore API and tRPC routes from Clerk's protection.

```typescript
clerkMiddleware({
  ignoredRoutes: [
    // Public routes that don't require authentication
    '/(api|trpc)(.*)', // Always run for API routes
  ],
})
```

--------------------------------

### Initialize and Subscribe with Convex Client (TypeScript)

Source: https://context7_llms

This example shows how to initialize the reactive `ConvexClient` in TypeScript to subscribe to real-time updates from Convex queries and execute mutations. It requires importing `ConvexClient` from `convex/browser` and the generated `api` object, and assumes `process.env.CONVEX_URL` is configured.

```typescript
import { ConvexClient } from "convex/browser";
import { api } from "../convex/_generated/api";

const client = new ConvexClient(process.env.CONVEX_URL!);

// subscribe to query results
client.onUpdate(api.messages.listAll, {}, (messages) =>
  console.log(messages.map((msg) => msg.body)),
);

// execute a mutation
function hello() {
  client.mutation(api.messages.sendAnon, {
    body: `hello at ${new Date()}`,
  });
}
```

--------------------------------

### Convex Vercel Preview Build Command with Initial Data Setup

Source: https://docs.convex.dev/production/hosting/vercel

Configures the Vercel Build Command for preview deployments, including a mechanism to set up initial data. The '--preview-run 'functionName'' argument executes a specified Convex function only for preview deployments, useful for populating fresh backends with necessary data.

```shell
npx convex deploy --cmd 'npm run build' --preview-run 'functionName'
```

--------------------------------

### Install convex-helpers Package

Source: https://stack.convex.dev/triggers

Install the convex-helpers npm package which provides the Triggers API for database trigger functionality.

```bash
npm i convex-helpers@latest
```

--------------------------------

### Install Aggregate Component via npm

Source: https://convex.dev/components/aggregate

Install the @convex-dev/aggregate package from npm. This is a prerequisite for using the Aggregate component in your Convex backend.

```bash
npm install @convex-dev/aggregate
```

--------------------------------

### Programmatically Get Convex Migration Status (TypeScript)

Source: https://www.convex.dev/components/migrations

These TypeScript examples demonstrate how to programmatically fetch the status of Convex migrations. You can retrieve a specified number of the most recent statuses using a `limit`, or query the status of specific migrations by providing an array of their references. The `MigrationStatus[]` type annotation clarifies the expected return type, ensuring type safety.

```typescript
const status: MigrationStatus[] = await migrations.getStatus(ctx, { limit: 10, });
```

```typescript
const status: MigrationStatus[] = await migrations.getStatus(ctx, {
  migrations: [
    internal.migrations.setDefaultValue,
    internal.migrations.validateRequiredField,
    internal.migrations.convertUnionField,
  ],
});
```

--------------------------------

### Check Node.js Version

Source: https://docs.convex.dev/tutorial

Verifies the installed version of Node.js on the system. Node.js 18+ is required as a prerequisite for the Convex tutorial.

```shell
node --version
```

--------------------------------

### Create Convex React Client Provider Component

Source: https://docs.convex.dev/quickstart/nextjs

Build a client-side provider component that wraps the ConvexProvider with ConvexReactClient initialization. This component uses the NEXT_PUBLIC_CONVEX_URL environment variable to establish the connection to Convex backend services.

```typescript
"use client";

import { ConvexProvider, ConvexReactClient } from "convex/react";
import { ReactNode } from "react";

const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL!);

export function ConvexClientProvider({ children }: { children: ReactNode }) {
  return <ConvexProvider client={convex}>{children}</ConvexProvider>;
}
```

--------------------------------

### Wrap Next.js App with Clerk and Convex Providers

Source: https://docs.convex.dev/auth/clerk

This `app/layout.tsx` server component demonstrates how to integrate `ClerkProvider` and the custom `ConvexClientProvider` into a Next.js application. It's crucial that `ClerkProvider` wraps `ConvexClientProvider` to ensure Convex can access Clerk's authentication context. This setup provides a global authentication and data layer for the entire application.

```typescript
import type { Metadata } from 'next'\nimport { Geist, Geist_Mono } from 'next/font/google'\nimport './globals.css'\nimport { ClerkProvider } from '@clerk/nextjs'\nimport ConvexClientProvider from '@/components/ConvexClientProvider'\n\nconst geistSans = Geist({ variable: '--font-geist-sans', subsets: ['latin'], })\nconst geistMono = Geist_Mono({ variable: '--font-mono', subsets: ['latin'], })\n\nexport const metadata: Metadata = {\n  title: 'Clerk Next.js Quickstart',\n  description: 'Generated by create next app',\n}\n\nexport default function RootLayout({ children, }: Readonly<{ children: React.ReactNode }>) {\n  return (\n    <ClerkProvider>\n      <ConvexClientProvider>\n        <html lang="en" className={`${geistSans.variable} ${geistMono.variable}`}>\n          <body>{children}</body>\n        </html>\n      </ConvexClientProvider>\n    </ClerkProvider>\n  )\n}
```

--------------------------------

### Configure ConvexProvider in Next.js App (JavaScript)

Source: https://docs.convex.dev/client/nextjs/pages-router/quickstart

Sets up the `ConvexProvider` in your Next.js application's root file (`pages/_app.js`). It initializes the `ConvexReactClient` with your Convex deployment URL and wraps the application to provide Convex context.

```javascript
import "@/styles/globals.css";
import { ConvexProvider, ConvexReactClient } from "convex/react";

const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL);

export default function App({ Component, pageProps }) {
  return (
    <ConvexProvider client={convex}>
      <Component {...pageProps} />
    </ConvexProvider>
  );
}
```

--------------------------------

### GET /

Source: https://docs.convex.dev/functions/http-actions

A basic HTTP GET endpoint that returns a simple 'Hello from' message including the request URL. This demonstrates the fundamental structure of an HTTP action handler.

```APIDOC
## GET /

### Description
A basic HTTP GET endpoint that returns a simple 'Hello from' message, including the URL of the incoming request. Useful for health checks or simple greetings.

### Method
GET

### Endpoint
/

### Parameters
#### Path Parameters
- No path parameters.

#### Query Parameters
- No query parameters.

#### Request Body
- No request body.

### Request Example
N/A

### Response
#### Success Response (200)
- **response** (string) - A greeting message including the request URL.

#### Response Example
```json
"Hello from https://your-deployment-name.convex.site/"
```
```

--------------------------------

### Using `useSuspenseQuery` for Server-Side Rendering Convex Data

Source: https://docs.convex.dev/client/tanstack/tanstack-start

This snippet demonstrates the simplest way to perform server-side rendering (SSR) of Convex queries within a TanStack Start application. By using `useSuspenseQuery()`, data is fetched on the server and then live-updated on the client, providing a seamless experience. It leverages `convexQuery` to integrate with the Convex backend.

```typescript
const { data } = useSuspenseQuery(convexQuery(api.messages.list, {}));
```

--------------------------------

### GET /query

Source: https://context7_llms

Execute a query function using an HTTP GET request, typically for read-only operations.

```APIDOC
## GET /query

### Description
Execute a query function via GET request.

### Method
GET

### Endpoint
/query

### Parameters
#### Path Parameters

#### Query Parameters

#### Request Body

### Request Example
{}

### Response
#### Success Response (200)

#### Response Example
{}
```

--------------------------------

### Convex: Example of using `useQueries` React Hook

Source: https://docs.convex.dev/api/modules/react

This example illustrates how to use the `useQueries` React hook to fetch data from multiple Convex queries simultaneously. It demonstrates passing a configuration object with query references and arguments, and shows the structure of the returned results.

```javascript
const results = useQueries({
  messagesInGeneral: {
    query: "listMessages",
    args: { channel: "#general" }
  }
});
```

```javascript
{
  messagesInGeneral: [{
    channel: "#general",
    body: "hello"
    _id: ...,
    _creationTime: ...
  }]
}
```

--------------------------------

### Install Convex Agent Component

Source: https://docs.convex.dev/agents/getting-started

Installs the agent component package using npm. This is a prerequisite for using the agent functionality within a Convex project.

```bash
npm install @convex-dev/agent
```

--------------------------------

### Store and retrieve UTC timestamps in Convex

Source: https://docs.convex.dev/using/types

When only a point in time is needed, storing a UTC timestamp as a `number` (milliseconds since epoch) is recommended in Convex. This example demonstrates how to get the current timestamp using `Date.now()` for storage and how to reconstruct a JavaScript `Date` object from a retrieved timestamp.

```javascript
// Storing current timestamp
const currentTime = Date.now();
// ctx.db.insert("myTable", { creationTime: currentTime });

// Retrieving and converting
// const doc = await ctx.db.get(id);
const retrievedTime = 1711046235000; // Example retrieved timestamp
const dateObject = new Date(retrievedTime);
// console.log(dateObject.toISOString());
```

--------------------------------

### GET /query

Source: https://docs.convex.dev/public-deployment-api/public-query-get

Execute a query function via GET request. This endpoint allows you to run query functions defined in your Convex backend and retrieve the results.

```APIDOC
## GET /query

### Description
Execute a query function via GET request to retrieve data from the Convex backend.

### Method
GET

### Endpoint
```
/query
```

### Parameters
#### Query Parameters
- **format** (string) - Optional - Response format specification

### Request Example
```
GET /query
```

### Response
#### Success Response (200)
- **result** (object) - The result returned by the executed query function

#### Response Example
```json
{
  "result": {}
}
```

### Status Codes
- **200** - Query executed successfully
```

--------------------------------

### Install Action Cache Component via NPM

Source: https://www.convex.dev/components/action-cache

Install the @convex-dev/action-cache package from npm. This is the first step to add caching functionality to your Convex project.

```bash
npm install @convex-dev/action-cache
```

--------------------------------

### Install Convex npm dependency

Source: https://docs.convex.dev/understanding/workflow

Add the Convex client library as a dependency to your project. This command downloads and installs the necessary packages to interact with Convex services from your application.

```bash
npm i convex
```

--------------------------------

### Fetch and Display Tasks Using useQuery Hook

Source: https://docs.convex.dev/quickstart/nextjs

Create a client component that uses the useQuery hook to fetch tasks from the Convex API and render them as a list. The hook automatically handles data fetching, loading states, and reactivity when data changes.

```typescript
"use client";

import Image from "next/image";
import { useQuery } from "convex/react";
import { api } from "../convex/_generated/api";

export default function Home() {
  const tasks = useQuery(api.tasks.get);
  return (
    <main className="flex min-h-screen flex-col items-center justify-between p-24">
      {tasks?.map(({ _id, text }) => <div key={_id}>{text}</div>)}
    </main>
  );
}
```

--------------------------------

### Access Client-side User Info with Clerk's useUser Hook (TypeScript)

Source: https://docs.convex.dev/auth/clerk

This React component, `Badge.tsx`, illustrates how to retrieve the authenticated user's information on the client-side using Clerk's `useUser()` hook. It destructures the `user` object to display details like `fullName`, providing a simple example of client-side user data access.

```TypeScript
export default function Badge() {
  const { user } = useUser();
  return Logged in as {user.fullName};
}
```

--------------------------------

### Integrate Convex and Clerk Providers in React (TypeScript/TSX)

Source: https://docs.convex.dev/auth/clerk

This React component setup combines `ClerkProvider` and `ConvexProviderWithClerk` to enable authentication in a Convex React application. `ClerkProvider` initializes Clerk using the publishable key, and `ConvexProviderWithClerk` connects Convex to Clerk's authentication state via the `useAuth()` hook, ensuring that Convex queries and mutations are authenticated.

```typescript
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import "./index.css";
import { ClerkProvider, useAuth } from "@clerk/clerk-react";
import { ConvexProviderWithClerk } from "convex/react-clerk";
import { ConvexReactClient } from "convex/react";

const convex = new ConvexReactClient(import.meta.env.VITE_CONVEX_URL as string);

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <ClerkProvider publishableKey={import.meta.env.VITE_CLERK_PUBLISHABLE_KEY!}>
      <ConvexProviderWithClerk client={convex} useAuth={useAuth}>
        <App />
      </ConvexProviderWithClerk>
    </ClerkProvider>
  </React.StrictMode>,
);
```

--------------------------------

### Initialize Convex Client (Swift)

Source: https://docs.convex.dev/quickstart/swift

Initializes the Convex client instance with your Convex deployment URL. This client is used to interact with your Convex backend from a Swift application.

```swift
import SwiftUI
import ConvexMobile

let convex = ConvexClient(deploymentUrl: "YOUR_CONVEX_URL")
```

--------------------------------

### Configure Convex Functions Directory

Source: https://docs.convex.dev/quickstart/svelte

Modifies the `convex.json` file to specify the directory for Convex functions. This ensures SvelteKit can correctly reference the backend code, typically placing it under `src/convex/`.

```json
{
	"functions": "src/convex/"
}
```

--------------------------------

### Best Practice for `ctx.db` Functions: Including Table Names (TypeScript)

Source: https://docs.convex.dev/understanding/best-practices

This example demonstrates the importance of explicitly providing the table name as the first argument when calling Convex `ctx.db` functions (e.g., `get`, `patch`, `replace`, `delete`). While historically optional, this practice is now recommended as a safeguard for future custom ID generation and ensures more robust and explicit database interactions. The snippet contrasts the older, less explicit syntax () with the recommended, explicit syntax ().

```typescript
// 
await ctx.db.get(movieId);
await ctx.db.patch(movieId, { title: "Whiplash" });
await ctx.db.replace(movieId, {
  title: "Whiplash",
  director: "Damien Chazelle",
  votes: 0,
});
await ctx.db.delete(movieId);

//             vvvvvvvv
await ctx.db.get("movies", movieId);
await ctx.db.patch("movies", movieId, { title: "Whiplash" });
await ctx.db.replace("movies", movieId, {
  title: "Whiplash",
  director: "Damien Chazelle",
  votes: 0,
});
await ctx.db.delete("movies", movieId);
```

--------------------------------

### Setup React Root with ClerkProvider and ConvexProviderWithClerk

Source: https://context7_llms

React application entry point configuration that wraps the app with authentication providers. ClerkProvider handles Clerk authentication context, while ConvexProviderWithClerk connects Convex client to Clerk's authentication state using the useAuth hook. Requires Convex URL environment variable.

```typescript
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import "./index.css";
import { ClerkProvider, useAuth } from "@clerk/clerk-react";
import { ConvexProviderWithClerk } from "convex/react-clerk";
import { ConvexReactClient } from "convex/react";

const convex = new ConvexReactClient(import.meta.env.VITE_CONVEX_URL as string);

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <ClerkProvider publishableKey="pk_test_...">
      <ConvexProviderWithClerk client={convex} useAuth={useAuth}>
        <App />
      </ConvexProviderWithClerk>
    </ClerkProvider>
  </React.StrictMode>,
);
```

--------------------------------

### Install Convex Agent Component using npm

Source: https://docs.convex.dev/components/using

This command installs the `@convex-dev/agent` component package from npm. It's the first step to make the component available for use in your Convex application's `node_modules`.

```bash
npm i @convex-dev/agent
```

--------------------------------

### Call Convex Mutations with TanStack React Query

Source: https://docs.convex.dev/client/tanstack/tanstack-query

Demonstrates how to integrate Convex mutations with TanStack Query's useMutation hook. The useConvexMutation function wraps the Convex API function as a mutationFn. This setup provides automatic loading state (isPending) and mutation triggering via the mutate function. The example shows calling api.functions.doSomething with a simple object parameter.

```typescript
import { useMutation } from "@tanstack/react-query";
import { useConvexMutation } from "@convex-dev/react-query";
import { api } from "../convex/_generated/api";

export function App() {
  const { mutate, isPending } = useMutation({
    mutationFn: useConvexMutation(api.functions.doSomething),
  });
  return <button onClick={() => mutate({a: "Hello"})}>Click me</button>;
}
```

--------------------------------

### Install LaunchDarkly Convex Component

Source: https://www.convex.dev/components/launchdarkly

Install the official Convex component for LaunchDarkly feature flagging using npm. This package provides the necessary integration logic to sync LaunchDarkly data with your Convex backend.

```bash
npm install @convex-dev/launchdarkly
```

--------------------------------

### Install React Native Presence Dependencies

Source: https://www.convex.dev/components/presence

Install required dependencies for React Native presence support using expo. This command installs react-native and expo-crypto packages needed for presence functionality in React Native applications.

```bash
npx expo install react-native expo-crypto
```

--------------------------------

### Install and Configure Convex Aggregate Component

Source: https://convex.dev/components/aggregate

Install the @convex-dev/aggregate package and configure it in the convex.config.ts file using the defineApp and use pattern. This sets up the aggregate component for use in your Convex project.

```bash
npm install @convex-dev/aggregate
```

```typescript
// convex/convex.config.ts
import { defineApp } from "convex/server";
import aggregate from "@convex-dev/aggregate/convex.config.js";

const app = defineApp();
app.use(aggregate);
export default app;
```

--------------------------------

### Install Convex Dependencies

Source: https://context7_llms

Installs the required Convex packages for React Query and Vue integrations. The convex-vue package is used for Vue applications while @convex-dev/react-query is used for React applications with React Query.

```bash
npm install convex @convex-dev/react-query @tanstack/react-query
```

```bash
npm install convex-vue
```

--------------------------------

### Initialize New Node.js Project

Source: https://context7_llms

Create a new directory for the Node.js project, initialize it with npm, and configure it to use ES modules by setting the 'type' field in package.json.

```bash
mkdir my-project && cd my-project && npm init -y && npm pkg set type="module"
```

--------------------------------

### Configure Claude AI with Convex MCP Server

Source: https://context7_llms

These commands demonstrate how to add and retrieve the Convex MCP server configuration within Claude AI's environment. This setup allows Claude to leverage the MCP server's tools for interacting with Convex deployments.

```bash
claude mcp add-json convex '{\"type\":\"stdio\",\"command\":\"npx\",\"args\":[\"convex\",\"mcp\",\"start\"]}'
claude mcp get convex
```

--------------------------------

### Set Up Convex Client in SvelteKit Layout

Source: https://context7_llms

Configures the Convex client within `src/routes/+layout.svelte` using the `setupConvex` function from `convex-svelte`. This ensures the Convex client is initialized with the public Convex URL and made available across all pages of the Svelte application.

```svelte
<script lang="ts">
	import { PUBLIC_CONVEX_URL } from '$env/static/public';
	import { setupConvex } from 'convex-svelte';

	const { children } = $props();
	setupConvex(PUBLIC_CONVEX_URL);
</script>

{@render children()}
```

--------------------------------

### GET Request to Retrieve Canonical URLs

Source: https://docs.convex.dev/deployment-api/get-canonical-urls

HTTP GET request to fetch canonical URLs for a deployment. This endpoint accepts a GET method and returns canonical URL information with a 200 OK response status.

```http
GET /get_canonical_urls HTTP/1.1
```

--------------------------------

### Install Rate Limiter Package via npm

Source: https://convex.dev/components/rate-limiter

Install the Convex rate limiter component package using npm. This is the first step to integrate rate limiting into your Convex backend application.

```bash
npm install @convex-dev/rate-limiter
```

--------------------------------

### Setup ConvexProvider for React Context

Source: https://docs.convex.dev/api/modules/react

Wraps your React application with ConvexProvider to store the ConvexReactClient in React context, making it accessible to all child components. This is a required setup step before using Convex hooks.

```javascript
import { ConvexProvider } from "convex/react";
```

--------------------------------

### Install Latest Convex CLI

Source: https://docs.convex.dev/functions/bundling

Ensures you are using the most recent version of the Convex CLI, which may include improvements or fixes related to bundling.

```bash
npm install convex@latest
```

--------------------------------

### Configure Convex Server-Side Authentication with Clerk Issuer (TypeScript)

Source: https://docs.convex.dev/auth/clerk

This code configures Convex to validate access tokens issued by Clerk. It defines an `AuthConfig` with a provider that uses the Clerk JWT issuer domain, typically sourced from an environment variable for flexibility between development and production environments. This file (`auth.config.ts`) is crucial for server-side authentication setup in Convex.

```typescript
import { AuthConfig } from "convex/server";

export default {
  providers: [
    {
      // Replace with your own Clerk Issuer URL from your "convex" JWT template
      // or with `process.env.CLERK_JWT_ISSUER_DOMAIN`
      // and configure CLERK_JWT_ISSUER_DOMAIN on the Convex Dashboard
      // See https://docs.convex.dev/auth/clerk#configuring-dev-and-prod-instances
      domain: process.env.CLERK_JWT_ISSUER_DOMAIN!,
      applicationID: "convex",
    },
  ]
} satisfies AuthConfig;
```

--------------------------------

### Install Dependencies for Deprecated ESLint Format

Source: https://docs.convex.dev/eslint

Install both @typescript-eslint/eslint-plugin and @convex-dev/eslint-plugin for .eslintrc.js configuration. Required for projects using the legacy ESLint configuration format.

```bash
npm i @typescript-eslint/eslint-plugin @convex-dev/eslint-plugin --save-dev
```

--------------------------------

### JavaScript: Configure Convex ESLint Plugin (Legacy `.eslintrc.js`)

Source: https://context7_llms

Example `.eslintrc.js` configuration for integrating `@typescript-eslint/eslint-plugin` and `@convex-dev/eslint-plugin`. It extends recommended configurations and specifies patterns to ignore, such as `node_modules/` and build directories.

```js
module.exports =
  extends: [
    // Other configurations
    "plugin:@typescript-eslint/recommended",
    "plugin:@convex-dev/recommended",
  ],
  ignorePatterns: ["node_modules/", "dist/", "build/"],
};
```

--------------------------------

### Install Sharded Counter Component via npm

Source: https://www.convex.dev/components/sharded-counter

Install the @convex-dev/sharded-counter package to add counter functionality to your Convex application. This is the first step in setting up the component.

```bash
npm install @convex-dev/sharded-counter
```

--------------------------------

### Configure ConvexProvider in Vue (TypeScript)

Source: https://docs.convex.dev/quickstart/vue

Configuration in `src/main.ts` to set up the Convex client using `convexVue`. It makes the Convex client available throughout the Vue application via the ConvexProvider.

```typescript
import { convexVue } from 'convex-vue'
import { createApp } from 'vue'
import App from './App.vue'

const app = createApp(App)

app.use(convexVue, {
  url: import.meta.env.VITE_CONVEX_URL,
})

app.mount('#app')
```

--------------------------------

### Install Convex Polar Component npm Package

Source: https://www.convex.dev/components/polar

This command installs the `@convex-dev/polar` package, providing the necessary client-side and Convex-side components for integrating Polar. It's the initial step to add subscription and billing functionalities to your Convex application.

```bash
npm install @convex-dev/polar
```

--------------------------------

### Convex Dev Deployment

Source: https://docs.convex.dev/quickstart/bun

Starts a Convex development deployment, prompting for GitHub login, project creation, and saving deployment URLs. It also generates a `convex/` folder for backend functions and syncs them to the cloud.

```bash
bunx convex dev
```

--------------------------------

### JavaScript Object Response Example

Source: https://context7_llms

Example of a Convex query function returning a JavaScript object with various data types including string, array, and BigInt values that need to be converted to Kotlin types.

```javascript
{
	name: "Guardians",
	uniformColors: ["blue", "white", "red"],
	wins: 80n,
	losses: 60n
}
```

--------------------------------

### GET /get_canonical_urls

Source: https://docs.convex.dev/deployment-api/get-canonical-urls

Retrieves the canonical URLs associated with a deployment.

```APIDOC
## GET /get_canonical_urls

### Description
Get the canonical URLs for a deployment.

### Method
GET

### Endpoint
/get_canonical_urls

### Parameters
#### Path Parameters
(None)

#### Query Parameters
(None)

#### Request Body
(None)

### Request Example
(None)

### Response
#### Success Response (200)
(Successful retrieval of canonical URLs)

#### Response Example
(None)
```

--------------------------------

### Open Convex documentation

Source: https://docs.convex.dev/using/cli

Directs your web browser to the official Convex documentation, offering a quick way to access help and guides.

```bash
npx convex docs
```

--------------------------------

### Display Data using useQuery in Svelte (TypeScript)

Source: https://docs.convex.dev/quickstart/svelte

Fetches and displays task data in `src/routes/+page.svelte` using the `useQuery` hook from `convex-svelte`. It subscribes to the `api.tasks.get` query and renders the data, handling loading and error states.

```typescript
<script lang="ts">
	import { useQuery } from 'convex-svelte';
	import { api } from '../convex/_generated/api.js';

	const query = useQuery(api.tasks.get, {});
</script>

{#if query.isLoading}
	Loading...
{:else if query.error}
	failed to load: {query.error.toString()}
{:else}
	<ul>
		{#each query.data as task}
			<li>
				{task.isCompleted ? '' : ''}
				<span>{task.text}</span>
				<span>assigned by {task.assigner}</span>
			</li>
		{/each}
	</ul>
{/if}
```

--------------------------------

### Create Sample Data File

Source: https://context7_llms

Create a sampleData.jsonl file containing JSON lines with task objects. Each line represents a document with text and completion status properties for database import.

```json
{"text": "Buy groceries", "isCompleted": true}
{"text": "Go for a swim", "isCompleted": true}
{"text": "Integrate Convex", "isCompleted": false}
```

--------------------------------

### Call Convex Deployment Management API with Authorization Header (JavaScript)

Source: https://context7_llms

This example demonstrates how to make an authenticated API call to a Convex deployment endpoint using a fetch request in JavaScript. It shows how to construct the Authorization header with a 'Convex' prefix followed by the deployment token. This token grants admin access to the deployment.

```javascript
const token = "ey...0=";
const response = await fetch(
  "https://happy-otter-123.convex.cloud/api/v1/list_environment_variables",
  {
    headers: {
      Authorization: `Convex ${token}`,
    },
  },
);
console.log(await response.json());
```

--------------------------------

### Configure ConvexProvider in Remix Root (TypeScript)

Source: https://docs.convex.dev/quickstart/remix

Modifies the `app/root.tsx` file to set up the Convex client using `ConvexProvider`. It retrieves the `CONVEX_URL` from environment variables and makes the Convex client available throughout the application.

```typescript
import {
  Links,
  Meta,
  Outlet,
  Scripts,
  ScrollRestoration,
  useLoaderData,
} from "@remix-run/react";
import { ConvexProvider, ConvexReactClient } from "convex/react";
import { useState } from "react";

export async function loader() {
  const CONVEX_URL = process.env["CONVEX_URL"]!;
  return { ENV: { CONVEX_URL } };
}

export function Layout({ children }: { children: React.ReactNode }) {
  const { ENV } = useLoaderData<typeof loader>();
  const [convex] = useState(() => new ConvexReactClient(ENV.CONVEX_URL));
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <Meta />
        <Links />
      </head>
      <body>
        <ConvexProvider client={convex}>{children}</ConvexProvider>
        <ScrollRestoration />
        <Scripts />
      </body>
    </html>
  );
}

export default function App() {
  return <Outlet />;
}
```

--------------------------------

### GET /getMessagesByAuthor

Source: https://context7_llms

Retrieves messages associated with a specific author. This endpoint is exposed via an HTTP GET request.

```APIDOC
## GET /getMessagesByAuthor

### Description
This endpoint is used to fetch messages filtered by author. The specific parameters for filtering are not detailed in the provided documentation, but typically would involve query parameters.

### Method
GET

### Endpoint
/getMessagesByAuthor

### Parameters
#### Query Parameters
- **author** (string) - Optional - The name of the author to filter messages by. (Inferred, not explicitly specified in the provided text.)

### Request Example
```json
{}
```

### Response
#### Success Response (200)
Returns a list of messages by the specified author. The structure of the response body is not detailed in the provided text.

#### Response Example
```json
[
  { "id": "123", "author": "User 1", "body": "Message 1" },
  { "id": "456", "author": "User 1", "body": "Message 2" }
]
```
```

--------------------------------

### Install RAG Component via npm

Source: https://convex.dev/components/rag

Install the @convex-dev/rag package to add semantic search capabilities to your Convex backend. This is the first step in setting up RAG functionality.

```bash
npm install @convex-dev/rag
```

--------------------------------

### Install @convex-dev/prosemirror-sync npm Package

Source: https://www.convex.dev/components/prosemirror-sync

This command installs the `@convex-dev/prosemirror-sync` package, which is essential for adding collaborative text editing capabilities to a Convex application. It sets up the necessary dependencies for integrating real-time document synchronization.

```bash
npm install @convex-dev/prosemirror-sync
```

--------------------------------

### Configure AndroidManifest.xml for Internet Permission

Source: https://docs.convex.dev/quickstart/android

Adds the necessary internet permission to the AndroidManifest.xml file, allowing the application to make network requests to the Convex backend. This is a prerequisite for client-server communication.

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">
    <uses-permission android:name="android.permission.INTERNET"/>
    <application>
        <!-- ... existing application contents -->
    </application>
</manifest>
```

--------------------------------

### Measure Enqueue-to-Start Delay for Functions with KQL

Source: https://convex.dev/components/workpool

This KQL query calculates the average time, in seconds, between a function being enqueued and its actual start. It's crucial to set the workpool `logLevel` to 'INFO' or 'DEBUG' to gather the required 'started' events. The query aggregates this 'startLag' metric per function in 1-minute intervals, offering insight into processing delays.

```KQL
['your-dataset'] | extend parsed_message = iff(isnotnull(parse_json(trim("'", tostring(["data.message"])))), parse_json(trim("'", tostring(["data.message"]))), parse_json('{}') ) | where parsed_message["component"] == "workpool" and parsed_message["event"] == "started" | summarize start_lag_seconds = avg(todouble(parsed_message["startLag"])/1000) by bin(_time, 1m), function = tostring(parsed_message["fnName"])
```

--------------------------------

### Execute Query via GET HTTP Endpoint

Source: https://context7_llms

Execute a query function using a GET request to the /query endpoint. This method is suitable for read-only operations and returns a 200 status code on success.

```http
GET /query
```

--------------------------------

### Efficiently Count Records or Denormalize in Convex TypeScript

Source: https://docs.convex.dev/understanding/best-practices

This snippet presents strategies for efficiently counting records in Convex without loading the entire dataset. The '' example shows an inefficient method of collecting all records to get a count. The first '' solution uses `take()` to limit the number of fetched records, suitable for displaying approximate counts like '99+'. The second '' solution demonstrates denormalization, where the count is stored and retrieved from a separate, optimized table for direct access.

```ts
//  -- potentially unbounded
const watchedMovies = await ctx.db
  .query("watchedMovies")
  .withIndex("by_user", (q) => q.eq("user", "Tom"))
  .collect();
const numberOfWatchedMovies = watchedMovies.length;
```

```ts
//  -- Show "99+" instead of needing to load all documents
const watchedMovies = await ctx.db
  .query("watchedMovies")
  .withIndex("by_user", (q) => q.eq("user", "Tom"))
  .take(100);
const numberOfWatchedMovies =
  watchedMovies.length === 100 ? "99+" : watchedMovies.length.toString();
```

```ts
//  -- Denormalize the number of watched movies in a separate table
const watchedMoviesCount = await ctx.db
  .query("watchedMoviesCount")
  .withIndex("by_user", (q) => q.eq("user", "Tom"))
  .unique();
```

--------------------------------

### Create Next.js App with npx

Source: https://context7_llms

Initialize a new Next.js project using the create-next-app command. This sets up a basic Next.js application with default configuration options.

```bash
npx create-next-app@latest my-app
```

--------------------------------

### Run Convex Agent Playground Locally

Source: https://context7_llms

Command to start the Convex Agent Playground locally using npx. The playground uses the VITE_CONVEX_URL environment variable, typically loaded from a .env.local file for configuration.

```bash
npx @convex-dev/agent-playground
```

--------------------------------

### Example Convex function test with Vitest (TypeScript)

Source: https://docs.convex.dev/testing/convex-test

A complete example of a Vitest test file for Convex functions. It demonstrates how to import `convexTest`, mock `mutation` and `query` calls, and use `expect` to assert the results returned by your Convex API. This test simulates sending and listing messages.

```typescript
import { convexTest } from "convex-test";
import { expect, test } from "vitest";
import { api } from "./_generated/api";
import schema from "./schema";

test("sending messages", async () => {
  const t = convexTest(schema);
  await t.mutation(api.messages.send, { body: "Hi!", author: "Sarah" });
  await t.mutation(api.messages.send, { body: "Hey!", author: "Tom" });
  const messages = await t.query(api.messages.list);
  expect(messages).toMatchObject([
    { body: "Hi!", author: "Sarah" },
    { body: "Hey!", author: "Tom" }
  ]);
});
```

--------------------------------

### Integrate ConvexClientProvider in Root Layout

Source: https://docs.convex.dev/quickstart/nextjs

Wrap the body content with the ConvexClientProvider in the root layout file (app/layout.tsx). This makes Convex functionality available to all child components throughout the application.

```typescript
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { ConvexClientProvider } from "./ConvexClientProvider";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <ConvexClientProvider>{children}</ConvexClientProvider>
      </body>
    </html>
  );
}
```

--------------------------------

### Run Convex Function for Preview Deployments (CLI)

Source: https://docs.convex.dev/production/hosting/netlify

This command demonstrates how to deploy Convex functions with a specific function to be run only for preview deployments. It ensures that initial data setup is isolated to preview environments and does not affect production.

```shell
npx convex deploy --cmd 'npm run build' --preview-run 'functionName'
```

--------------------------------

### Define Convex Action with Default or Node.js Runtime

Source: https://context7_llms

Illustrates defining Convex actions. The first example uses the default Convex JavaScript environment for `fetch` calls, which is faster. The second demonstrates configuring an action to run in a Node.js environment by adding the `"use node";` directive, necessary for unsupported NPM packages or Node.js APIs.

```TypeScript
import { action } from "./_generated/server";

export const doSomething = action({
  args: {},
  handler: async () => {
    const data = await fetch("https://api.thirdpartyservice.com");
    // do something with data
  }
});
```

```TypeScript
"use node";

import { action } from "./_generated/server";
import SomeNpmPackage from "some-npm-package";

export const doSomething = action({
  args: {},
  handler: () => {
    // do something with SomeNpmPackage
  }
});
```

--------------------------------

### Initialize Convex Clients in Node.js with CommonJS Modules

Source: https://context7_llms

This example shows how to import and use `ConvexHttpClient` and `ConvexClient` in a Node.js project that uses CommonJS `require()` syntax. It relies on the `api_cjs.cjs` file generated by Convex after configuring `generateCommonJSApi` in `convex.json`.

```javascript
const { ConvexHttpClient, ConvexClient } = require("convex/browser");
const { api } = require("./convex/_generated/api_cjs.cjs");
const httpClient = new ConvexHttpClient(CONVEX_URL_GOES_HERE);
```

--------------------------------

### Initialize Convex Client and Router with Query Integration

Source: https://context7_llms

Create and configure the Convex client, ConvexQueryClient, and integrate with TanStack Router and React Query. Sets up the Convex provider wrapper and QueryClient with default options for Convex queries.

```typescript
import { createRouter } from "@tanstack/react-router";
import { QueryClient } from "@tanstack/react-query";
import { routerWithQueryClient } from "@tanstack/react-router-with-query";
import { ConvexQueryClient } from "@convex-dev/react-query";
import { ConvexProvider } from "convex/react";
import { routeTree } from "./routeTree.gen";

export function getRouter() {
  const CONVEX_URL = (import.meta as any).env.VITE_CONVEX_URL!;
  if (!CONVEX_URL) {
    console.error("missing envar VITE_CONVEX_URL");
  }
  const convexQueryClient = new ConvexQueryClient(CONVEX_URL);

  const queryClient: QueryClient = new QueryClient({
    defaultOptions: {
      queries: {
        queryKeyHashFn: convexQueryClient.hashFn(),
        queryFn: convexQueryClient.queryFn(),
      },
    },
  });
  convexQueryClient.connect(queryClient);

  const router = routerWithQueryClient(
    createRouter({
      routeTree,
      defaultPreload: "intent",
      context: { queryClient },
      scrollRestoration: true,
      Wrap: ({ children }) => (
        <ConvexProvider client={convexQueryClient.convexClient}>
          {children}
        </ConvexProvider>
      ),
    }),
    queryClient,
  );

  return router;
}
```

--------------------------------

### Subscribe to Convex Query with Arguments in Android

Source: https://context7_llms

This example illustrates passing arguments to a Convex query subscription using `ConvexClient.subscribe`. It shows how to construct a `Map<String, Any?>` to provide parameters, such as 'favoriteColors', to the backend 'users:list' query, allowing for filtered or customized results.

```kotlin
val favoriteColors = mapOf("favoriteColors" to listOf("blue", "red"))
client.subscribe<List<String>>("users:list", args = favoriteColors)
```

--------------------------------

### HttpRouter - GET /getMessagesByAuthor

Source: https://docs.convex.dev/api/classes/server.HttpRouter

Defines a GET endpoint at /getMessagesByAuthor to retrieve messages by a specific author. It uses an imported handler function for its logic.

```APIDOC
## GET /getMessagesByAuthor

### Description
Defines a GET endpoint at `/getMessagesByAuthor` to retrieve messages by a specific author. It uses an imported handler function for its logic.

### Method
GET

### Endpoint
/getMessagesByAuthor

### Parameters
#### Query Parameters
- **author** (string) - Required - The author whose messages should be retrieved.

### Request Example
```json
{
  "author": "Jane Smith"
}
```

### Response
#### Success Response (200)
- **messages** (array) - A list of messages from the specified author.

#### Response Example
```json
{
  "messages": [
    {
      "body": "Message 1",
      "author": "Jane Smith"
    },
    {
      "body": "Message 2",
      "author": "Jane Smith"
    }
  ]
}
```
```

--------------------------------

### Seed Convex Preview Deployments in Vercel via CLI

Source: https://context7_llms

This script demonstrates how to seed Convex preview deployments with sample data, specifically in a Vercel environment. It deploys the application and, if in a preview environment, imports data from a `seed_data.zip` file using the preview deployment's name.

```shell
npx convex deploy --cmd 'npm run build' &&\nif [ "$VERCEL_ENV" == "preview" ]; then\nnpx convex import --preview-name "$VERCEL_GIT_COMMIT_REF" seed_data.zip;\nfi
```

--------------------------------

### Install Convex Crons Component via npm

Source: https://www.convex.dev/components/crons

This command installs the `@convex-dev/crons` package, which provides runtime cron job management for Convex applications. It is a prerequisite for using the component in your project.

```bash
npm install @convex-dev/crons
```

--------------------------------

### Install Convex Workpool Component via npm

Source: https://convex.dev/components/workpool

This snippet shows the command to install the Convex Workpool component from npm, making it available for use in your Convex project. This is the first step to integrate Workpool into your backend.

```bash
npm install @convex-dev/workpool
```

--------------------------------

### Display Convex Data in Nuxt App

Source: https://docs.convex.dev/quickstart/nuxt

Uses the `useQuery` composable from `convex-nuxt` to fetch and subscribe to data from a Convex query function (`api.tasks.get`). The fetched data is then displayed in a list format within the Nuxt application's template.

```vue
<script setup lang="ts">
import { api } from "../convex/_generated/api";
const { data: tasks } = useConvexQuery(api.tasks.get);
</script>

<template>
  <div>
    <h1>Tasks</h1>
    <ul>
      <li v-for="task in tasks" :key="task._id">
        <span>{{ task.text }}</span>
      </li>
    </ul>
  </div>
</template>
```

--------------------------------

### Install Twilio Convex Component Package

Source: https://www.convex.dev/components/twilio

This command installs the `@convex-dev/twilio` package, which provides the necessary client and integration for sending and receiving SMS messages within a Convex application. It's the first step to setting up Twilio SMS functionality in your project.

```shell
npm install @convex-dev/twilio
```

--------------------------------

### Vector Search Complete Workflow

Source: https://context7_llms

A complete example demonstrating the three-step vector search workflow in Convex: embedding generation, vector similarity search, and document retrieval.

```APIDOC
## Vector Search Workflow

### Description
Complete end-to-end workflow for performing vector searches in Convex, combining embedding generation, similarity search, and document retrieval.

### Step 1: Generate Embedding
Generate a vector embedding from user input using a third-party service (e.g., OpenAI)

### Step 2: Search for Similar Documents
Use ctx.vectorSearch to find documents with similar embeddings

### Step 3: Retrieve Document Details
Load full document information for the matched results

### Complete Example
```
import { v } from "convex/values";
import { action, internalQuery } from "./_generated/server";

// Step 1 & 2: Search for similar documents
export const similarFoods = action({
  args: {
    descriptionQuery: v.string(),
  },
  handler: async (ctx, args) => {
    // Generate embedding from description
    const embedding = await embed(args.descriptionQuery);
    
    // Search for similar foods
    const results = await ctx.vectorSearch("foods", "by_embedding", {
      vector: embedding,
      limit: 16,
      filter: (q) => q.eq("cuisine", "French"),
    });
    
    // Fetch full documents
    const foods = await ctx.runQuery(
      internal.foods.fetchResults,
      { ids: results.map((result) => result._id) }
    );
    
    return foods;
  },
});

// Helper query to fetch multiple documents
export const fetchResults = internalQuery({
  args: { ids: v.array(v.id("foods")) },
  handler: async (ctx, args) => {
    const results = [];
    for (const id of args.ids) {
      const doc = await ctx.db.get("foods", id);
      if (doc !== null) {
        results.push(doc);
      }
    }
    return results;
  },
});
```

### Workflow Summary
1. User provides text query (e.g., "creamy chicken dishes")
2. Generate embedding vector from query text
3. Search database for documents with similar embeddings
4. Filter results by optional criteria (cuisine type)
5. Retrieve full document details for matched IDs
6. Return enriched results to client
```

--------------------------------

### Optimize Convex Indexes by Avoiding Redundancy in TypeScript

Source: https://docs.convex.dev/understanding/best-practices

This example demonstrates how to optimize Convex database indexes by using a more comprehensive index (`by_team_and_user`) to serve multiple query patterns, thereby reducing redundancy. The '' example shows using two separate indexes for querying all team members by `team` and a specific team member by `team` and `user`. The '' example consolidates these by using the `by_team_and_user` index for both scenarios, improving storage efficiency and write overhead.

```ts
// 
const allTeamMembers = await ctx.db
  .query("teamMembers")
  .withIndex("by_team", (q) => q.eq("team", teamId))
  .collect();
const currentUserId = /* get current user id from `ctx.auth` */
const currentTeamMember = await ctx.db
  .query("teamMembers")
  .withIndex("by_team_and_user", (q) =>
    q.eq("team", teamId).eq("user", currentUserId),
  )
  .unique();
```

```ts
// 
// Just don't include a condition on `user` when querying for results on `team`
const allTeamMembers = await ctx.db
  .query("teamMembers")
  .withIndex("by_team_and_user", (q) => q.eq("team", teamId))
  .collect();
const currentUserId = /* get current user id from `ctx.auth` */
const currentTeamMember = await ctx.db
  .query("teamMembers")
  .withIndex("by_team_and_user", (q) =>
    q.eq("team", teamId).eq("user", currentUserId),
  )
  .unique();
```

--------------------------------

### Connect Bun Script to Convex Backend (TypeScript)

Source: https://context7_llms

Initializes a `ConvexClient` in an `index.ts` file using the development environment URL. It then subscribes to real-time updates from the `api.tasks.get` query, logging the fetched tasks to the console and managing the client's lifecycle.

```typescript
import { ConvexClient } from "convex/browser";
import { api } from "./convex/_generated/api.js";

const client = new ConvexClient(process.env["CONVEX_URL"]);

const unsubscribe = client.onUpdate(api.tasks.get, {}, async (tasks) => {
  console.log(tasks);
});

await Bun.sleep(1000);
unsubscribe();
await client.close();
```

--------------------------------

### Example Convex Filter Values

Source: https://docs.convex.dev/dashboard/deployments/data

Valid Convex value examples that can be entered in the filter value input box when filtering documents. Supports strings, numbers, and complex nested objects.

```javascript
"a string"
123
{ a: { b: 2 } }
```

--------------------------------

### Connect Rust app to Convex backend and fetch data

Source: https://context7_llms

Initializes a `ConvexClient` in a Rust Tokio application, loading environment variables for the Convex deployment URL. It then uses the client to query the `"tasks:get"` API endpoint and prints the result. This demonstrates connecting a Rust client to a Convex backend.

```rust
use std::{
    collections::BTreeMap,
    env,
};

use convex::ConvexClient;

#[tokio::main]
async fn main() {
    dotenvy::from_filename(".env.local").ok();
    dotenvy::dotenv().ok();

    let deployment_url = env::var("CONVEX_URL").unwrap();

    let mut client = ConvexClient::new(&deployment_url).await.unwrap();
    let result = client.query("tasks:get", BTreeMap::new()).await.unwrap();
    println!("{result:#?}");
}
```

--------------------------------

### Serve Files from HTTP Action with Access Control

Source: https://context7_llms

Demonstrates how to serve files directly from HTTP actions by mapping query parameters to storage IDs. Returns a Blob object retrieved from storage, enabling access control at serve time. Includes 404 error handling for missing files and is limited to 20MB response size.

```typescript
import { httpRouter } from "convex/server";
import { httpAction } from "./_generated/server";
import { Id } from "./_generated/dataModel";

const http = httpRouter();

http.route({
  path: "/getImage",
  method: "GET",
  handler: httpAction(async (ctx, request) => {
    const { searchParams } = new URL(request.url);
    const storageId = searchParams.get("storageId")! as Id<"_storage">;
    const blob = await ctx.storage.get(storageId);
    if (blob === null) {
      return new Response("Image not found", {
        status: 404,
      });
    }
    return new Response(blob);
  }),
});

export default http;
```

--------------------------------

### getUrl

Source: https://docs.convex.dev/api/interfaces/server.StorageReader

Retrieves a URL for a file stored in Convex, allowing it to be fetched via HTTP GET. The GET response includes a standard HTTP Digest header with a sha256 checksum. A deprecated signature allows passing a string `StorageId`.

```APIDOC
## Function: getUrl

### Description
Get the URL for a file in storage by its `Id<"_storage">`. The GET response includes a standard HTTP Digest header with a sha256 checksum.
A deprecated signature allows passing a string `StorageId`, but `Id<"_storage">` is preferred.

### Method
Function Call

### Endpoint
getUrl(storageId)

### Parameters
#### Path Parameters
(Not Applicable)

#### Query Parameters
(Not Applicable)

#### Request Body
(Not Applicable)

### Function Parameters
- **storageId** (GenericId<"_storage">) - Required - The `Id<"_storage">` of the file to fetch from Convex storage.
- **storageId** (StorageId (string)) - Deprecated, Required - The `StorageId` (string) of the file to fetch from Convex storage. Use `Id<"_storage">` instead.

### Request Example
(Not Applicable)

### Response
#### Success Response (Implied: URL Retrieval)
- **return** (Promise<null | string>) - A URL which fetches the file via an HTTP GET, or `null` if the file no longer exists.

#### Response Example
(Not Applicable)
```

--------------------------------

### Display Tasks using useQuery Hook in React

Source: https://docs.convex.dev/quickstart/react

Fetches tasks from the Convex backend using the `useQuery` hook and displays them in the React component. It maps over the fetched tasks to render each task's text.

```typescript
import "./App.css";
import { useQuery } from "convex/react";
import { api } from "../convex/_generated/api";

function App() {
  const tasks = useQuery(api.tasks.get);
  return (
    <div className="App">
      {tasks?.map(({ _id, text }) => <div key={_id}>{text}</div>)}
    </div>
  );
}

export default App;

```

--------------------------------

### Initialize ConvexClient in Android Application Subclass (Kotlin)

Source: https://context7_llms

This Kotlin example shows how to initialize the `ConvexClient` within a custom Android `Application` subclass's `onCreate` method. This pattern ensures the client is globally available and consistently manages the connection to your Convex backend throughout the app's lifecycle.

```Kotlin
package com.example.convexapp

import android.app.Application
import dev.convex.android.ConvexClient

class MyApplication : Application() {
    lateinit var convex: ConvexClient

    override fun onCreate() {
        super.onCreate()
        convex = ConvexClient("https://<your domain here>.convex.cloud")
    }
}
```

--------------------------------

### Initialize ConvexClient with deployment URL in Swift

Source: https://context7_llms

Creates a single instance of ConvexClient that establishes and maintains a connection to your Convex backend. Pass your backend deployment URL to the constructor. The connection is lazy-initialized on first method call and automatically re-establishes if dropped.

```swift
import ConvexMobile

let convex = ConvexClient(deploymentUrl: "https://<your domain here>.convex.cloud")
```

--------------------------------

### Initialize Convex Provider in React Native App (TypeScript)

Source: https://docs.convex.dev/quickstart/react-native

Sets up the Convex client and wraps the application component tree with `ConvexProvider`. This makes the Convex client available throughout the React Native app via context.

```typescript
import { ConvexProvider, ConvexReactClient } from "convex/react";
import { Stack } from "expo-router";

const convex = new ConvexReactClient(process.env.EXPO_PUBLIC_CONVEX_URL!, {
  unsavedChangesWarning: false,
});

export default function RootLayout() {
  return (
    <ConvexProvider client={convex}>
      <Stack>
        <Stack.Screen name="index" />
      </Stack>
    </ConvexProvider>
  );
}
```

--------------------------------

### ROUTABLE_HTTP_METHODS - Supported HTTP Methods

Source: https://docs.convex.dev/api/modules/server

A constant list of HTTP methods supported by Convex HTTP actions. Includes GET, POST, PUT, DELETE, OPTIONS, and PATCH. HEAD is handled by running GET and stripping the response body.

```APIDOC
## ROUTABLE_HTTP_METHODS

### Description
A list of the HTTP methods supported by Convex HTTP actions.

### Supported Methods
- **GET** - Retrieve resource data
- **POST** - Create new resources
- **PUT** - Update existing resources
- **DELETE** - Remove resources
- **OPTIONS** - Describe communication options
- **PATCH** - Partial resource updates

### Special Handling
- **HEAD** - Handled by running GET and stripping the response body
- **CONNECT** - Not supported
- **TRACE** - Not supported

### Type
```typescript
readonly ["GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"]
```

### Usage
```typescript
for (const method of ROUTABLE_HTTP_METHODS) {
  // Register route for method
}
```

### Defined in
server/router.ts:14
```

--------------------------------

### Deploy Convex Functions to Production or Preview Environments

Source: https://context7_llms

Deploys Convex functions, indexes, and schema to a target environment. The target is determined by `CONVEX_DEPLOY_KEY` (for CI) or `CONVEX_DEPLOYMENT` (for local development). For preview deployments, `CONVEX_DEPLOY_KEY` with a Preview Deploy Key is used, potentially creating a new deployment with `--preview-create`. The command can execute a pre-deployment script via `--cmd` and customize the URL environment variable name with `--cmd-url-env-var-name`. It also typechecks functions, regenerates code, and bundles dependencies.

```bash
npx convex deploy
```

```bash
npx convex deploy --cmd "npm run build"
```

```bash
npx convex deploy --cmd 'npm run build' --cmd-url-env-var-name CUSTOM_CONVEX_URL
```

```bash
npx convex deploy --preview-create my-branch-name
```

```bash
npx convex deploy --preview-run myFunction
```

--------------------------------

### Action Constructor - Basic Example

Source: https://docs.convex.dev/functions/actions

Create a basic action using the action constructor function. Actions can perform side effects and optionally return values, unlike queries and mutations.

```APIDOC
## action() Constructor

### Description
Defines a Convex action that can call third-party services and interact with the database through queries and mutations.

### Method
Function Constructor

### Parameters
#### Constructor Arguments
- **args** (object) - Optional - Validator object defining action parameters
- **handler** (function) - Required - Async function that executes the action logic

### Request Example
```typescript
import { action } from "./generated/server";

export const doSomething = action({
  args: {},
  handler: () => {
    // implementation goes here
    return "success";
  },
});
```

### Response
#### Handler Return
- **value** (any) - Optional - Any serializable value to return from the action

#### Response Example
```typescript
return "success";
```
```

--------------------------------

### Deploy Convex Configuration Changes

Source: https://docs.convex.dev/auth/auth0

Run this command in your terminal to automatically synchronize your local Convex configuration, including authentication settings, with your Convex backend. This ensures the server-side changes are active.

```shell
npx convex dev
```

--------------------------------

### Define User Onboarding Workflow

Source: https://convex.dev/components/workflow

Example workflow that demonstrates core features: running mutations and actions, awaiting events, handling conditional logic, running nested workflows, and scheduling delayed steps. The workflow sends verification emails, waits for user verification, generates content with retry logic, and sends follow-up emails after a delay.

```typescript
import { WorkflowManager } from "@convex-dev/workflow";
import { components } from "./\u005fgenerated/api";

export const workflow = new WorkflowManager(components.workflow);

export const userOnboarding = workflow.define({
  args: {
    userId: v.id("users")
  },
  handler: async (ctx, args): Promise => {
    const status = await ctx.runMutation(
      internal.emails.sendVerificationEmail,
      { storageId: args.storageId }
    );
    if (status === "needsVerification") {
      // Waits until verification is completed asynchronously.
      await ctx.awaitEvent({ name: "verificationEmail" });
    }
    const result = await ctx.runAction(
      internal.llm.generateCustomContent,
      { userId: args.userId },
      // Retry this on transient errors with the default retry policy.
      { retry: true }
    );
    if (result.needsHumanInput) {
      // Run a whole workflow as a single step.
      await ctx.runWorkflow(internal.llm.refineContentWorkflow, {
        userId: args.userId
      });
    }
    await ctx.runMutation(
      internal.emails.sendFollowUpEmailMaybe,
      { userId: args.userId },
      // Runs one day after the previous step.
      { runAfter: 24 * 60 * 60 * 1000 }
    );
  }
});
```

--------------------------------

### Create React Native app with Expo

Source: https://context7_llms

Initialize a new React Native project using the Expo CLI. This command scaffolds a complete React Native application with the necessary configuration and dependencies.

```bash
npx create-expo-app my-app
```

--------------------------------

### Define a basic GET HTTP action in Convex (TypeScript)

Source: https://docs.convex.dev/functions/http-actions

This TypeScript code defines a basic HTTP GET route using Convex's `httpRouter`. It responds with a 'Hello from' message including the request URL. This snippet demonstrates how to set up an initial HTTP entry point for a Convex application.

```typescript
import { httpRouter } from "convex/server";
import { httpAction } from "./_generated/server";

const http = httpRouter();

http.route({
  path: "/",
  method: "GET",
  handler: httpAction(async (ctx, request) => {
    return new Response(`Hello from ${request.url}`);
  }),
});
export default http;
```

--------------------------------

### Configure OpenAI Client in Chef (JavaScript)

Source: https://context7_llms

Demonstrates how to configure the OpenAI client within a Chef project. Initially, it uses Chef's built-in proxy with a `baseURL` for quick prototyping. After exhausting proxy calls, the configuration is updated to use a personal OpenAI API key by removing the `baseURL` parameter, requiring the `CONVEX_OPENAI_API_KEY` environment variable.

```javascript
const openai = new OpenAI({
  baseURL: process.env.CONVEX_OPENAI_BASE_URL,
  apiKey: process.env.CONVEX_OPENAI_API_KEY,
});
```

```javascript
const openai = new OpenAI({
  apiKey: process.env.CONVEX_OPENAI_API_KEY,
});
```

--------------------------------

### Define and Apply Application-Level Rate Limiting Rules (TypeScript)

Source: https://www.convex.dev/components/rate-limiter

This example shows how to instantiate the `RateLimiter` with custom rate limit configurations, including both 'fixed window' and 'token bucket' algorithms. It then demonstrates how to apply these limits to different actions, such as sign-ups and message sending, and how to check the rate limit status programmatically.

```typescript
const rateLimiter = new RateLimiter(components.rateLimiter, {
  freeTrialSignUp: { kind: "fixed window", rate: 100, period: HOUR },
  sendMessage: { kind: "token bucket", rate: 10, period: MINUTE, capacity: 3 }
});

// Restrict how fast free users can sign up to deter bots
const status = await rateLimiter.limit(ctx, "freeTrialSignUp");

// Limit how fast a user can send messages
const status = await rateLimiter.limit(ctx, "sendMessage", { key: userId });

// Use the React hook to check the rate limit
const { status, check } = useRateLimit(api.example.getRateLimit, { count });
```

--------------------------------

### Setup ConvexProviderWithClerk in Next.js

Source: https://docs.convex.dev/auth/clerk

Create a Client Component that wraps children with ConvexProviderWithClerk, passing the Convex client and Clerk's useAuth hook. This component bridges Clerk authentication with Convex backend access.

```typescript
<ConvexProviderWithClerk client={convex} useAuth={useAuth}>
  {children}
</ConvexProviderWithClerk>
```

--------------------------------

### POST /query

Source: https://context7_llms

Execute a query function using an HTTP POST request, which can support larger or more complex parameters than GET.

```APIDOC
## POST /query

### Description
Execute a query function via POST request.

### Method
POST

### Endpoint
/query

### Parameters
#### Path Parameters

#### Query Parameters

#### Request Body

### Request Example
{}

### Response
#### Success Response (200)

#### Response Example
{}
```

--------------------------------

### Seed Convex Dev Deployments with Sample Data via CLI

Source: https://context7_llms

These commands demonstrate how to seed a development Convex deployment with sample data. You can import a full backup ZIP or import specific data into a single table from a JSONL/CSV file. This is useful for initializing new development environments.

```shell
npx convex import seed_data.zip
```

```shell
npx convex import --table <table name> data.jsonl
```

--------------------------------

### Fetch and Display Data using useQuery Hook (TypeScript)

Source: https://docs.convex.dev/quickstart/react-native

Uses the `useQuery` hook from `convex/react` to fetch data from the `api.tasks.get` Convex query and renders the task text. It handles potential null values for tasks during loading.

```typescript
import { api } from "@/convex/_generated/api";
import { useQuery } from "convex/react";
import { Text, View } from "react-native";

export default function Index() {
  const tasks = useQuery(api.tasks.get);
  return (
    <View
      style={{
        flex: 1,
        justifyContent: "center",
        alignItems: "center",
      }}
    >
      {tasks?.map(({ _id, text }) => <Text key={_id}>{text}</Text>)}
    </View>
  );
}
```

--------------------------------

### Install Expo Push Notifications Package

Source: https://convex.dev/components/push-notifications

Install the Convex Expo Push Notifications component package via npm. This is the first step to integrate push notification functionality into your Convex backend.

```bash
npm install @convex-dev/expo-push-notifications
```

--------------------------------

### GET StorageActionWriter.getUrl()

Source: https://docs.convex.dev/api/interfaces/server.StorageActionWriter

Retrieves the URL for a file in storage by its Id<"_storage">. The GET response includes a standard HTTP Digest header with a sha256 checksum. This method can accept either a GenericId<"_storage"> or a deprecated string StorageId.

```APIDOC
## GET StorageActionWriter.getUrl()

### Description
Get the URL for a file in storage by its `Id<"_storage">`. The GET response includes a standard HTTP Digest header with a sha256 checksum.

### Method
GET

### Endpoint
Storage URL retrieval method

### Parameters
#### Method Parameters
- **storageId** (GenericId<"_storage">) - Required - The `Id<"_storage">` of the file to fetch from Convex storage.

### Returns
`Promise<null | string>`

- A url which fetches the file via an HTTP GET, or `null` if it no longer exists.

### Response Example
```
"https://example.convex.cloud/storage/file-id"
```

### Notes
- Inherited from [StorageWriter](/api/interfaces/server.StorageWriter.md)
- Defined in [server/storage.ts:51](https://github.com/get-convex/convex-js/blob/main/src/server/storage.ts#L51)
- **Deprecated Overload**: Passing a string is deprecated, use `storage.getUrl(Id<"_storage">)` instead
```

--------------------------------

### Install Convex Sharded Counter Component

Source: https://convex.dev/components

Command to install the @convex-dev/sharded-counter npm package for managing distributed counter operations in Convex applications. This component provides efficient counter functionality for high-concurrency scenarios.

```bash
npm i @convex-dev/sharded-counter
```

--------------------------------

### Initialize OpenAI with Proxy URL in JavaScript

Source: https://docs.convex.dev/chef

Creates an OpenAI client instance configured with Chef's built-in proxy URL and API key from environment variables. This is the default configuration during prototyping with limited call allowance. Once the proxy call limit is reached, the baseURL parameter must be removed to use a personal OpenAI API key.

```javascript
const openai = new OpenAI({
  baseURL: process.env.CONVEX_OPENAI_BASE_URL,
  apiKey: process.env.CONVEX_OPENAI_API_KEY,
});
```

--------------------------------

### GET /projects/:project_id/list_deployments

Source: https://context7_llms

Retrieve all deployments associated with a project. Returns deployment details including type, status, and configuration.

```APIDOC
## GET /projects/:project_id/list_deployments

### Description
List deployments for a project.

### Method
GET

### Endpoint
/projects/:project_id/list_deployments

### Authentication
Bearer Token (obtained through Convex OAuth application)

### Path Parameters
- **project_id** (string) - Required - The ID of the project

### Response
#### Success Response (200)
- **deployments** (array) - Array of deployment objects
  - **deployment_name** (string) - Unique deployment identifier
  - **deployment_type** (string) - Either 'dev' or 'prod'
  - **created_at** (string) - ISO 8601 timestamp of deployment creation

### Error Responses
- **400** - Bad Request - Invalid project ID
- **401** - Unauthorized - Invalid or missing authentication token
- **404** - Not Found - Project does not exist
```

--------------------------------

### Instantiate PushNotifications Client in Convex Functions with Optional Type

Source: https://www.convex.dev/components/push-notifications

These examples show how to instantiate the `PushNotifications` client within your Convex functions. The first example demonstrates basic instantiation, while the second illustrates how to provide an optional type parameter (e.g., `Email`) for specifying a custom user identifier type for notification recipients.

```typescript
import { PushNotifications } from "@convex-dev/expo-push-notifications";
const pushNotifications = new PushNotifications(components.pushNotifications);
```

```typescript
import { PushNotifications } from "@convex-dev/expo-push-notifications";

export type Email = string & { __isEmail: true };

const pushNotifications = new PushNotifications(
  components.pushNotifications,
);
```

--------------------------------

### Create React app with Vite and TypeScript

Source: https://context7_llms

Initialize a new React project using Vite with TypeScript template. This command creates the project structure and necessary configuration files for a modern React development environment.

```bash
npm create vite@latest my-app -- --template react-ts
```

--------------------------------

### Example Convex Scheduled Function Document (JSON)

Source: https://docs.convex.dev/scheduling/scheduled-functions

An example of the JSON document structure returned when querying the `_scheduled_functions` system table. It shows key fields like `_id`, `_creationTime`, `args`, `completedTime`, `name`, `scheduledTime`, and `state`, which indicate the function's identity, execution details, and current status.

```json
{
  "_creationTime": 1699931054642.111,
  "_id": "3ep33196167235462543626ss0scq09aj4gqn9kdxrdr",
  "args": [{}],
  "completedTime": 1699931054690.366,
  "name": "messages.js:destruct",
  "scheduledTime": 1699931054657,
  "state": { "kind": "success" }
}
```

--------------------------------

### GET /connectionState

Source: https://context7_llms

Retrieves the current connection status between the client and the Convex backend.

```APIDOC
## GET /connectionState\n\n### Description\nGet the current connection state between the client and the Convex backend.\n\n### Method\nGET\n\n### Endpoint\n/connectionState\n\n### Parameters\n(None)\n\n### Request Example\n(None)\n\n### Response\n#### Success Response (200)\n- **state** (ConnectionState) - The current connection state with the Convex backend (e.g., 'CONNECTED', 'CONNECTING', 'DISCONNECTED').\n\n#### Response Example\n```json\n{\n  "state": "CONNECTED"\n}\n```
```

--------------------------------

### Install Cloudflare R2 Component via npm

Source: https://www.convex.dev/components/cloudflare-r2

Install the @convex-dev/r2 package to enable Cloudflare R2 file storage integration with Convex. This package provides utilities for uploading files, generating signed URLs, and managing file metadata.

```bash
npm install @convex-dev/r2
```

--------------------------------

### Expose database query in Convex backend (JavaScript)

Source: https://context7_llms

Defines a Convex query function named `get` in `convex/tasks.js`. This function uses the `db` object to query the `tasks` table and collect all its documents, making it available as an API endpoint `"tasks:get"`.

```javascript
import { query } from "./_generated/server";

export const get = query({
  handler: async ({ db }) => {
    return await db.query("tasks").collect();
  },
});
```

--------------------------------

### List All Tasks in Convex using db.query (TypeScript)

Source: https://context7_llms

Demonstrates how to fetch all documents from the 'tasks' table using `ctx.db.query` and `collect()` within a Convex query function. This serves as the basic pattern for starting any document query.

```TypeScript
import { query } from "./_generated/server";

export const listTasks = query({
  args: {},
  handler: async (ctx) => {
    const tasks = await ctx.db.query("tasks").collect();
    // do something with `tasks`
  }
});
```

--------------------------------

### GET /query

Source: https://docs.convex.dev/api/classes/browser.BaseConvexClient

Executes a Convex query function, fetching data based on the provided name and arguments.

```APIDOC
## GET /query

### Description
Executes a Convex query function, fetching data based on the provided name and arguments.

### Method
GET

### Endpoint
/query

### Parameters
#### Request Body
- **name** (string) - Required - The name of the query.
- **args?** (`Record<string, Value>`) - Optional - The arguments object for this query.

### Request Example
```json
{
  "name": "myQueryFunction",
  "args": {
    "userId": "123",
    "limit": 10
  }
}
```

### Response
#### Success Response (200)
- **result** (`undefined` | [`QueryJournal`](/api/modules/browser.md#queryjournal)) - The query's QueryJournal or undefined.

#### Response Example
```json
{
  "journal": {
    "reads": [],
    "writes": []
  }
}
```
```

--------------------------------

### Reset Expo Project

Source: https://docs.convex.dev/quickstart/react-native

Resets the Expo project, typically clearing caches and reinstalling dependencies to ensure a clean state. This is often done before major updates or to resolve build issues.

```bash
npm run reset-project
```

--------------------------------

### StorageReader.getUrl()

Source: https://context7_llms

Get the URL for a file in storage by its Id<"_storage">. The GET response includes a standard HTTP Digest header with a sha256 checksum. Supports both the current GenericId<"_storage"> parameter type and deprecated string-based StorageId.

```APIDOC
## StorageReader.getUrl()

### Description
Get the URL for a file in storage by its Id<"_storage">. The GET response includes a standard HTTP Digest header with a sha256 checksum.

### Method
Async Function

### Signature
```typescript
getUrl(storageId: GenericId<"_storage">): Promise<null | string>
```

### Parameters
#### Required Parameters
- **storageId** (GenericId<"_storage">) - The Id<"_storage"> of the file to fetch from Convex storage.

### Returns
- **Promise<null | string>** - A url which fetches the file via an HTTP GET, or `null` if it no longer exists.

### Notes
- A deprecated overload exists that accepts string-based StorageId, but using `GenericId<"_storage">` is recommended.
- The GET response includes a standard HTTP Digest header with a sha256 checksum.

### Defined in
server/storage.ts:51
```

--------------------------------

### Query with Document Scanning Limit

Source: https://docs.convex.dev/functions/error-handling

Demonstrates how Convex scans documents during query execution. The first example scans only 5 documents with take(), while the second example using filter() may scan all documents in the table to find the first match. Understanding document scanning is critical for optimizing performance and staying within read limits.

```javascript
db.query("table").take(5).collect()
```

```javascript
db.query("table").filter(...).first()
```

--------------------------------

### Setup HTML with Separate JavaScript File for TypeScript Support

Source: https://context7_llms

Splits Convex initialization into a separate JavaScript file to enable VS Code TypeScript autocompletion and type checking. The HTML file loads the Convex bundle and references the external script file.

```html
<!doctype html>
<form>
  <input placeholder="type here" />
</form>
<div class="messages"></div>

<script src="https://unpkg.com/convex@1.3.1/dist/browser.bundle.js"></script>
<!--VS Code TypeScript autocompletion doesn't work in HTML files so use a file-->
<script src="./script.js"></script>
```

--------------------------------

### GET /value - Get Rate Limit Current Value

Source: https://convex.dev/components/rate-limiter

Fetch the current value and metadata of a rate limit. Returns the current token count, timestamp, and configuration details.

```APIDOC
## GET /value

### Description
Retrieve the current state of a rate limit including token count, last update timestamp, and configuration.

### Method
GET

### Endpoint
rateLimiter.getValue(ctx, name, options)

### Parameters

#### Required Parameters
- **ctx** (object) - Convex context object
- **name** (string) - Required - Name of the rate limit configuration

#### Optional Parameters
- **key** (string) - Optional - User/team/session identifier

### Request Example
```javascript
const { config, value, ts } = await rateLimiter.getValue(ctx, "sendMessage", {
  key: userId
});
```

### Response

#### Success Response (200)
- **config** (object) - The rate limit configuration (kind, rate, period, capacity, etc.)
- **value** (number) - Current number of available tokens
- **ts** (number) - Unix timestamp in milliseconds when value was last updated

#### Response Example
```javascript
{
  "config": {
    "kind": "token bucket",
    "rate": 10,
    "period": 60000,
    "capacity": 20
  },
  "value": 8,
  "ts": 1704067200000
}
```
```

--------------------------------

### Example audit_log Event Schema for push_config (JSON)

Source: https://context7_llms

This JSON object demonstrates an `audit_log` event, specifically for a `push_config` action. These events record changes to a Convex deployment, providing details like the action performed (`audit_log_action`) and stringified JSON metadata about the change (`audit_log_metadata`), along with a timestamp and topic.

```json
{
  "topic": "audit_log",
  "timestamp": 1714421999886,
  "audit_log_action": "push_config",
  "audit_log_metadata": "{\"auth\":{\"added\":[],\"removed\":[]},\"crons\":{\"added\":[],\"deleted\":[],\"updated\":[]},..."
}
```

--------------------------------

### Configure Convex MCP Server for VS Code

Source: https://context7_llms

This configuration snippet for `.vscode/mcp.json` sets up the Convex Model Context Protocol (MCP) server within VS Code. It uses `npx` to run the `convex@latest mcp start` command, enabling AI coding agents like GitHub Copilot to interact with your Convex deployment for queries and project optimization.

```json
{
  "servers": {
    "convex-mcp": {
      "type": "stdio",
      "command": "npx",
      "args": ["-y", "convex@latest", "mcp", "start"]
    }
  }
}
```

--------------------------------

### ConvexReactClient Initialization with Deployment URL

Source: https://context7_llms

Initializes a single Convex React client for the frontend application by passing the deployment URL from environment variables. The client connects to the Convex backend and enables reactive query results over WebSocket.

```javascript
import { ConvexProvider, ConvexReactClient } from "convex/react";

const deploymentURL = import.meta.env.VITE_CONVEX_URL;

const convex = new ConvexReactClient(deploymentURL);
```

--------------------------------

### GET /connectionState

Source: https://docs.convex.dev/api/classes/browser.BaseConvexClient

Retrieves the current connection state between the client and the Convex backend.

```APIDOC
## GET /connectionState

### Description
Get the current `ConnectionState` between the client and the Convex backend.

### Method
GET

### Endpoint
/connectionState

### Parameters
This endpoint does not require any parameters.

### Request Example
// No request body for this GET endpoint.

### Response
#### Success Response (200)
- **state** ([`ConnectionState`](/api/modules/browser.md#connectionstate)) - The `ConnectionState` with the Convex backend.

#### Response Example
```json
"Connected"
```
```

--------------------------------

### GET /table/query

Source: https://context7_llms

Initiates a query operation for a table. Queries are lazily evaluated and do not execute immediately until their results are utilized.

```APIDOC
## GET /table/query

### Description
Begin a query for the table. Queries don't execute immediately, so calling this method and extending its query are free until the results are actually used.
This method is available on `BaseTableReader` and `BaseTableWriter` interfaces.

### Method
GET (conceptual)

### Endpoint
/table/query (conceptual)

### Parameters
No direct parameters for initiating the query; subsequent methods on the returned `QueryInitializer` will take parameters.

### Request Example
{}

### Response
#### Success Response (200)
- **initializer** (object) - A `QueryInitializer` object to start building a query, allowing chaining of filters, limits, etc.

#### Response Example
{
  "type": "QueryInitializer",
  "description": "Object to start building a query"
}
```

--------------------------------

### Convex File Metadata Document Structure (JSON)

Source: https://context7_llms

This JSON example illustrates the typical structure of a file metadata document retrieved from the Convex `_storage` system table. It includes essential details like `_creationTime`, `_id`, `contentType`, `sha256` checksum, and `size` in bytes.

```json
{
  "_creationTime": 1700697415295.742,
  "_id": "3k7ty84apk2zy00ay4st1n5p9kh7tf8",
  "contentType": "image/jpeg",
  "sha256": "cb58f529b2ed5a1b8b6681d91126265e919ac61fff6a367b8341c0f46b06a5bd",
  "size": 125338
}
```

--------------------------------

### Integrate Convex HTTP and Subscription Clients with Bun (TypeScript)

Source: https://context7_llms

This snippet shows how to utilize both `ConvexHttpClient` and `ConvexClient` within a Bun runtime environment. It demonstrates performing a point-in-time query with the HTTP client, and then initializing the reactive client to subscribe to updates and execute a mutation, showcasing Bun's compatibility with Convex clients.

```typescript
import { ConvexHttpClient, ConvexClient } from "convex/browser";
import { api } from "./convex/_generated/api.js";

// HTTP client
const httpClient = new ConvexHttpClient(process.env.CONVEX_URL);
httpClient.query(api.messages.list).then((messages) => {
  console.log(messages);
});

// Subscription client
const client = new ConvexClient(process.env.CONVEX_URL);
const unsubscribe = client.onUpdate(api.messages.list, {}, (messages) =>
  console.log(messages),
);
await Bun.sleep(1000);
client.mutate(api.messages.send, {}, { body: "hello!", author: "me" });
await Bun.sleep(1000);
```

--------------------------------

### Initialize New Convex Project with Auth

Source: https://docs.convex.dev/auth/convex-auth

This shell command initializes a new Convex project using the latest `convex` CLI. Users should select 'React (Vite)' and 'Convex Auth' from the prompts to set up a new project with Convex Auth pre-configured for web applications.

```shell
npm create convex@latest
```

--------------------------------

### Configure Rate Limiter with Fixed Window and Token Bucket

Source: https://docs.convex.dev/agents/rate-limiting

Sets up a RateLimiter instance with configurations for message frequency (fixed window) and token usage (token bucket). It defines limits per user and globally, controlling request rates and resource consumption.

```typescript
import { MINUTE, RateLimiter, SECOND } from "@convex-dev/rate-limiter";
import { components } from "./_generated/api";

export const rateLimiter = new RateLimiter(components.rateLimiter, {
  sendMessage: {
    kind: "fixed window",
    period: 5 * SECOND,
    rate: 1,
    capacity: 2,
  },
  globalSendMessage: { kind: "token bucket", period: MINUTE, rate: 1_000 },
  tokenUsagePerUser: {
    kind: "token bucket",
    period: MINUTE,
    rate: 2000,
    capacity: 10000,
  },
  globalTokenUsage: { kind: "token bucket", period: MINUTE, rate: 100_000 },
});
```

--------------------------------

### Create Convex Project with React Vite and AuthKit

Source: https://context7_llms

Initialize a new Convex project with React Vite template and WorkOS AuthKit authentication. Prompts create an associated WorkOS account linked to your Convex team, enabling automatic provisioning of WorkOS environments for future deployments.

```bash
npm create convex@latest -- -t react-vite-authkit
cd my-app
npm run dev
```

--------------------------------

### Fetch Convex Data in Python Script

Source: https://context7_llms

This Python script initializes a `ConvexClient` using a URL loaded from environment variables via `python-dotenv`. It first performs a one-time query to 'tasks:get' and then subscribes to real-time updates for the tasks, demonstrating both static and reactive data fetching from a Convex backend.

```python
import os

from convex import ConvexClient
from dotenv import load_dotenv

load_dotenv(".env.local")
CONVEX_URL = os.getenv("CONVEX_URL")
# or you can hardcode your deployment URL instead
# CONVEX_URL = "https://happy-otter-123.convex.cloud"

client = ConvexClient(CONVEX_URL)

print(client.query("tasks:get"))

for tasks in client.subscribe("tasks:get"):
    print(tasks)
    # this loop lasts forever, ctrl-c to exit it
```

--------------------------------

### Convex Data Type Examples and Validators

Source: https://docs.convex.dev/using/types

Examples of all supported Convex data types with their TypeScript/JavaScript representations and corresponding validators. This covers primitives like numbers, strings, and booleans, as well as complex types like arrays and objects used in document schemas.

```javascript
// Id type
const id = doc._id;

// Null type
const nullValue = null;

// Int64 type (BigInt)
const largeNumber = 3n;

// Float64 type
const decimal = 3.1;

// Boolean type
const flag = true;

// String type
const text = "abc";

// Bytes type
const buffer = new ArrayBuffer(8);

// Array type
const arr = [1, 3.2, "abc"];

// Object type
const obj = {a: "abc"};

// Record type
const record = {"a": "1", "b": "2"};
```

```javascript
import { v } from "convex/values";

// Validators for argument validation and schemas
v.id("tableName");
v.null();
v.int64();
v.number();
v.boolean();
v.string();
v.bytes();
v.array(v.number());
v.object({property: v.string()});
v.record(v.string(), v.string());

// Optional fields
v.optional(v.string());
```

--------------------------------

### Test Notes App Access Control with Convex

Source: https://stack.convex.dev/testing-with-local-oss-backend

Example test demonstrating access control verification in a notes application. Tests that users can only read their own notes by creating notes for two different users and verifying isolation of queries. Uses Convex mutations and queries with session-based user identification.

```JavaScript
test("can only read own notes", async () => {
  const personASessionId = "Person A";
  await t.mutation(api.notes.add, {
    sessionId: personASessionId,
    note: "Hello from Person A"
  });

  await t.mutation(api.notes.add, {
    sessionId: personASessionId,
    note: "Hello again from Person A"
  });

  const personBSessionId = "Person B";
  await t.mutation(api.notes.add, {
    sessionId: personBSessionId,
    note: "Hello from Person B"
  });

  const personANotes = await t.query(api.notes.list, {
    sessionId: personASessionId
  });
  expect(personANotes.length).toEqual(2);
});
```

--------------------------------

### Set Up ConvexProvider in Next.js Pages App

Source: https://context7_llms

Configure the Convex React client and wrap the entire Next.js app with ConvexProvider in pages/_app.js. Instantiate ConvexReactClient with the Convex deployment URL from environment variables to enable backend connectivity.

```javascript
import "@/styles/globals.css";
import { ConvexProvider, ConvexReactClient } from "convex/react";

const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL);

export default function App({ Component, pageProps }) {
  return (
    <ConvexProvider client={convex}>
      <Component {...pageProps} />
    </ConvexProvider>
  );
}
```

--------------------------------

### Install Convex Presence Component

Source: https://www.convex.dev/components/presence

Use this `npm` command to add the `@convex-dev/presence` package to your project. This package provides the core functionality for managing user presence in your Convex application.

```bash
npm install @convex-dev/presence
```

--------------------------------

### Create new Cargo project

Source: https://context7_llms

Initializes a new Rust project named `my_app` using Cargo and navigates into its directory. This command is a standard first step for any new Rust application.

```bash
cargo new my_app
cd my_app
```

--------------------------------

### Database Read: get(id)

Source: https://context7_llms

Fetches a single document from the database by its unique identifier. Returns the document or `null` if not found.

```APIDOC
## FUNCTION_CALL db.get(id)

### Description
Fetch a single document from the database by its [GenericId](/api/modules/values.md#genericid).

### Method
Function Call

### Endpoint
db.get<TableName>(id: GenericId<TableName>)

### Parameters
#### Function Arguments
- **id** (GenericId<TableName>) - Required - The [GenericId](/api/modules/values.md#genericid) of the document to fetch from the database.

#### Path Parameters
- No path parameters for this method.

#### Query Parameters
- No query parameters for this method.

#### Request Body
- No request body for this method.

### Request Example
```javascript
// Example call:
const userDoc = await db.get("users:abc123def456");

// userDoc might be:
// { _id: "users:abc123def456", name: "Alice", email: "alice@example.com" }
// or null if not found
```

### Response
#### Return Value
- **Document** (Promise<null | DocumentByName<DataModel, TableName>>) - The [GenericDocument](/api/modules/server.md#genericdocument) of the document at the given [GenericId](/api/modules/values.md#genericid), or `null` if it no longer exists.

#### Response Example
```json
{
  "_id": "users:abc123def456",
  "_creationTime": 1678886400000,
  "name": "Alice",
  "email": "alice@example.com"
}
```
Or `null` if the document is not found.
```json
null
```
```

--------------------------------

### Configure Convex MCP Server in Cursor's mcp.json

Source: https://context7_llms

This JSON configuration snippet shows how to manually set up the Convex Model Context Protocol (MCP) server within Cursor's `mcp.json` file. By defining a 'convex' server entry, it enables Cursor's AI agent to access and optimize Convex deployments, allowing the AI to query Convex data and suggest improvements. The configuration specifies the `npx` command to start the Convex MCP server.

```json
{
  "mcpServers": {
    "convex": {
      "command": "npx",
      "args": ["-y", "convex@latest", "mcp", "start"]
    }
  }
}
```

--------------------------------

### GET /table/{id}

Source: https://context7_llms

Fetches a single document from the table using its unique `GenericId`.

```APIDOC
## GET /table/{id}

### Description
Fetch a single document from the table by its `GenericId`. Returns the document if found, otherwise `null`.
This method is available on the `BaseTableReader` and `BaseTableWriter` interfaces.

### Method
GET

### Endpoint
/table/{id}

### Parameters
#### Path Parameters
- **id** (string) - Required - The unique `GenericId` of the document to fetch from the database.

#### Query Parameters
None

#### Request Body
None

### Request Example
{}

### Response
#### Success Response (200)
- **document** (object | null) - The document object corresponding to the given ID, or `null` if the document does not exist.

#### Response Example
{
  "_id": "65c853f0-459f-431e-9a96-f0f5c156f4e1",
  "_creationTime": 1678886400000,
  "name": "Example Document",
  "data": {
    "key": "value"
  }
}
```

--------------------------------

### Create TanStack Router with Convex and Query Client

Source: https://context7_llms

Sets up a TanStack router with Convex client, ConvexQueryClient, and React Query integration. Initializes the Convex client with the VITE_CONVEX_URL environment variable and connects the query client to enable synchronized data fetching. Wraps the router with ConvexProvider to make Convex available throughout the application.

```TypeScript
import { createRouter as createTanStackRouter } from '@tanstack/react-router'
import { routeTree } from './routeTree.gen'
import { DefaultCatchBoundary } from './components/DefaultCatchBoundary'
import { NotFound } from './components/NotFound'
import { routerWithQueryClient } from '@tanstack/react-router-with-query'
import { ConvexProvider, ConvexReactClient } from 'convex/react'
import { ConvexQueryClient } from '@convex-dev/react-query'
import { QueryClient } from '@tanstack/react-query'

export function createRouter() {
  const CONVEX_URL = (import.meta as any).env.VITE_CONVEX_URL!
  if (!CONVEX_URL) {
    throw new Error('missing VITE_CONVEX_URL envar')
  }
  const convex = new ConvexReactClient(CONVEX_URL, {
    unsavedChangesWarning: false,
  })
  const convexQueryClient = new ConvexQueryClient(convex)

  const queryClient: QueryClient = new QueryClient({
    defaultOptions: {
      queries: {
        queryKeyHashFn: convexQueryClient.hashFn(),
        queryFn: convexQueryClient.queryFn(),
      },
    },
  })
  convexQueryClient.connect(queryClient)

  const router = routerWithQueryClient(
    createTanStackRouter({
      routeTree,
      defaultPreload: 'intent',
      defaultErrorComponent: DefaultCatchBoundary,
      defaultNotFoundComponent: () => <NotFound />,
      context: { queryClient, convexClient: convex, convexQueryClient },
      scrollRestoration: true,
      Wrap: ({ children }) => (
        <ConvexProvider client={convexQueryClient.convexClient}>
          {children}
        </ConvexProvider>
      ),
    }),
    queryClient,
  )

  return router
}

declare module '@tanstack/react-router' {
  interface Register {
    router: ReturnType<typeof createRouter>
  }
}
```

--------------------------------

### Configure Convex Development Server for AI Agents

Source: https://context7_llms

This snippet provides commands to start the Convex development server in 'agent mode' for remote cloud-based coding agents. Running Convex in anonymous agent mode (`CONVEX_AGENT_MODE=anonymous`) with `--once` limits permissions and allows agents to perform tasks like codegen, testing, and function execution.

```bash
npm i
CONVEX_AGENT_MODE=anonymous npx convex dev --once
```

```bash
bun i
CONVEX_AGENT_MODE=anonymous bun x convex dev --once
```

--------------------------------

### Convex Function Definition Syntaxes

Source: https://context7_llms

Demonstrates various syntaxes for defining Convex functions, ranging from simple handlers to those specifying arguments and return types using validators. These examples illustrate the flexibility in function declaration for queries.

```typescript
- query(async (ctx, args) => {...})
- query({ handler: async (ctx, args) => {...} })
- query({ args: { a: v.string }, handler: async (ctx, args) => {...} } })
- query({ args: { a: v.string }, returns: v.string(), handler: async (ctx, args) => {...} } })
```

--------------------------------

### Deploy Preview and Run Function

Source: https://docs.convex.dev/cli

Deploy to a preview deployment and execute a specified function after deployment succeeds. The --preview-run option works similarly to the --run option for npx convex dev, allowing automated testing or initialization of preview deployments.

```bash
npx convex deploy --preview-run myFunction
```

--------------------------------

### Query Search Index with Filters

Source: https://context7_llms

Execute a search query against a search index with both search and equality expressions. This example demonstrates querying messages that contain specific text in a particular channel.

```APIDOC
## Query Search Index with Filters

### Description
Query a search index with search expressions and equality filters to retrieve ranked and filtered documents from the database.

### Method
GET (Database Query)

### Endpoint
`ctx.db.query(tableName).withSearchIndex(indexName, filterExpression).take(limit)`

### Parameters
#### Required Parameters
- **tableName** (string) - Name of the table to query
- **indexName** (string) - Name of the search index to use
- **filterExpression** (function) - Function defining search and equality filters
- **searchField** (string) - Field name to search against
- **searchQuery** (string) - Search query string to match against the field

#### Optional Parameters
- **limit** (number) - Maximum number of results to return using `.take(n)`
- **filterField** (string) - Field name for equality filtering
- **filterValue** (any) - Exact value to match for equality filter

### Request Example
```typescript
const messages = await ctx.db
  .query("messages")
  .withSearchIndex("search_body", (q) =>
    q.search("body", "hello hi").eq("channel", "#general")
  )
  .take(10);
```

### Response
#### Success Response
- **results** (array) - Array of documents matching the search criteria, ordered by relevance
- **document fields** (object) - Each document contains all fields from the database record

#### Response Example
```typescript
[
  {
    "_id": "message_id_1",
    "body": "hello there",
    "channel": "#general",
    "_creationTime": 1234567890
  },
  {
    "_id": "message_id_2",
    "body": "hi everyone",
    "channel": "#general",
    "_creationTime": 1234567891
  }
]
```

### Notes
- Search expressions are always required as the first filter in the chain
- Equality expressions filter for exact matches only
- Results are always returned in relevance order based on search match quality
- Use `.withSearchIndex()` for better performance than post-query filtering
```

--------------------------------

### Restart Convex Migration from Beginning (CLI)

Source: https://www.convex.dev/components/migrations

This CLI command demonstrates how to restart a Convex migration from the very beginning. By passing `cursor: null`, the migration is forced to start over, which can be useful for debugging or re-running failed migrations from a clean state. Alternatively, a specific valid cursor can be provided to resume from a particular point, often obtained from `getStatus` calls.

```bash
npx convex run migrations:runIt '{cursor: null}'
```

--------------------------------

### Deploy Convex Backend to Production with Environment Variable

Source: https://context7_llms

Deploy Convex functions to production by setting the CONVEX_DEPLOY_KEY environment variable and running the deploy command. This allows deployment to specific projects and staging environments outside the default production deployment.

```bash
CONVEX_DEPLOY_KEY=[YOUR_DEPLOY_KEY] npx convex deploy
```

--------------------------------

### GET /client/url

Source: https://docs.convex.dev/api/classes/react.ConvexReactClient

Retrieves the address for the current client instance. The returned URL may be canonicalized and may not exactly match the address used during client construction.

```APIDOC
## GET Client URL

### Description
Returns the address/URL for the current ConvexReactClient instance, useful for creating a new client with the same configuration.

### Method
Getter accessor

### Syntax
```
const url = client.url
```

### Returns
- **url** (string) - The canonical address of the Convex deployment

### Notes
The returned URL may differ from the original address provided during client construction, as it may be canonicalized.
```

--------------------------------

### BaseConvexClient Constructor

Source: https://docs.convex.dev/api/classes/browser.BaseConvexClient

Initializes a new instance of the `BaseConvexClient` class. This is a low-level client for direct integration with Convex state management.

```APIDOC
## POST /BaseConvexClient

### Description
Initializes a new instance of the `BaseConvexClient` class. This constructor sets up the connection to a Convex deployment and defines how state transitions are handled.

### Method
POST (Constructor)

### Endpoint
/BaseConvexClient

### Parameters
#### Request Body
- **address** (string) - Required - The URL of your Convex deployment (e.g., `https://small-mouse-123.convex.cloud`).
- **onTransition** (function) - Required - A callback function `(updatedQueries: QueryToken[]) => void` that receives an array of query tokens corresponding to query results that have changed.
- **options?** (BaseConvexClientOptions) - Optional - Configuration options for the BaseConvexClient. See `BaseConvexClientOptions` for full details.

### Request Example
```json
{
  "address": "https://your-deployment.convex.cloud",
  "onTransition": "(updatedQueries) => { /* handle updates */ }",
  "options": {
    "//": "See BaseConvexClientOptions for properties"
  }
}
```

### Response
#### Success Response (200 - Object Instantiation)
- **instance** (BaseConvexClient) - Returns a new instance of the BaseConvexClient.

#### Response Example
```json
{
  "status": "client_initialized",
  "message": "BaseConvexClient instance successfully created."
}
```
```

--------------------------------

### Import Sample Data to Convex Database

Source: https://context7_llms

Import sample data from a JSONL file into a Convex database table using the import command. This populates the tasks table with initial data for development and testing.

```bash
npx convex import --table tasks sampleData.jsonl
```

--------------------------------

### GET /api/streaming_import/primary_key_indexes_ready

Source: https://context7_llms

The primary_key_indexes_ready endpoint checks if primary key indexes on specified tables are ready. Returns true if all indexes are prepared. Newly created tables have indexes ready immediately, while existing tables may require time for backfilling.

```APIDOC
## GET /api/streaming_import/primary_key_indexes_ready

### Description
Takes a list of table names and returns true if the primary key indexes (created by `add_primary_key_indexes`) on all those tables are ready. If the tables are newly created, the indexes should be ready immediately; however if there are existing documents in the tables, it may take some time to backfill the primary key indexes.

### Method
GET

### Endpoint
/api/streaming_import/primary_key_indexes_ready

### Headers
- **Authorization** (string) - Required - Deployment admin authorization. Format: `Convex <access_key>` where the access key comes from "Deploy key" on the Convex dashboard.
- **Convex-Client** (string) - Optional - Semantic version of streaming import API. Format: `streaming-import-<version>`. Defaults to latest version if not specified.

### Parameters
#### Query Parameters
- **tables** (string[]) - Required - Comma-separated list of table names to check for primary key index readiness.

### Response
#### Success Response (200)
- **indexesReady** (boolean) - True if the primary key indexes on all specified tables are ready, false otherwise.

### Response Example
{
  "indexesReady": true
}
```

--------------------------------

### Convex.dev Example Document Structure for 'items' Table (JSON)

Source: https://stack.convex.dev/how-convex-works

This JSON object illustrates the structure of a document stored in the 'items' table as defined by the Convex schema. It shows typical fields like '_id' (a system-generated unique ID), 'description', 'image', 'name', 'price', and 'remaining', along with their respective values, providing a concrete example of data representation.

```json
{
 "_id": "j970pq0asyav77fekdj08grwan6npmh1",
 "description": "Keeps you shady",
 "image": "hat.png",
 "name": "Convex Hat",
 "price": 19.5,
 "remaining": 11
}
```

--------------------------------

### GET /BaseConvexClient/url

Source: https://docs.convex.dev/api/classes/browser.BaseConvexClient

Retrieves the canonicalized address URL associated with this Convex client instance.

```APIDOC
## GET /BaseConvexClient/url

### Description
Returns the address used by this client. This URL may be canonicalized and might not exactly match the address provided during construction.

### Method
GET

### Endpoint
/BaseConvexClient/url

### Parameters
#### Query Parameters
- No parameters.

### Request Example
```json
{}
```

### Response
#### Success Response (200)
- **url** (string) - The canonicalized URL of the Convex deployment.

#### Response Example
```json
{
  "url": "https://small-mouse-123.convex.cloud"
}
```
```

--------------------------------

### Configure Nuxt Dev Script for Dotenv

Source: https://docs.convex.dev/quickstart/nuxt

Updates the `dev` script in `package.json` to include the `--dotenv .env.local` flag. This ensures that Nuxt loads environment variables from `.env.local` when running the development server, which is where Convex typically stores its configuration.

```json
{
  "name": "nuxt-app",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "nuxt build",
    "dev": "nuxt dev --dotenv .env.local",
    "generate": "nuxt generate",
    "preview": "nuxt preview",
    "postinstall": "nuxt prepare"
  },
  "dependencies": {
    "convex": "^1.25.2",
    "convex-nuxt": "^0.1.3",
    "nuxt": "^3.17.6",
    "vue": "^3.5.17",
    "vue-router": "^4.5.1"
  }
}
```

--------------------------------

### Environment Variables Configuration in .env.local File

Source: https://context7_llms

Shows example .env.local file configuration for Next.js with Convex URL and other public environment variables. These variables are loaded by the bundler and made available to frontend code. The NEXT_PUBLIC_CONVEX_URL is automatically saved by 'npx convex dev' during development.

```plaintext
NEXT_PUBLIC_CONVEX_URL=https://guiltless-dog-960.convex.cloud

# examples of other environment variables that might be passed to the frontend
NEXT_PUBLIC_SENTRY_DSN=https://123abc@o123.ingest.sentry.io/1234
NEXT_PUBLIC_LAUNCHDARKLY_SDK_CLIENT_SIDE_ID=01234567890abcdef
```

--------------------------------

### skipConvexDeploymentUrlCheck Configuration

Source: https://docs.convex.dev/api/interfaces/react.ConvexReactClientOptions

An optional boolean flag to bypass the validation of the Convex deployment URL, useful for custom or self-hosted backend setups.

```APIDOC
## CONFIG OPTION skipConvexDeploymentUrlCheck

### Description
Skip validating that the Convex deployment URL looks like `https://happy-animal-123.convex.cloud` or localhost. This can be useful if running a self-hosted Convex backend that uses a different URL. The default value is `false`.

### Method
Configuration Property

### Parameters
#### Request Body
- **skipConvexDeploymentUrlCheck** (boolean) - Optional - Whether to skip validation of the Convex deployment URL. Defaults to `false`.

### Response
#### Property Type
- **Type** (boolean) - The data type of this configuration option.

```

--------------------------------

### Instantiate Class-Based Client in TypeScript

Source: https://docs.convex.dev/components/authoring

Shows basic and dynamic instantiation patterns for class-based clients. Demonstrates static instantiation with configuration options and dynamic instantiation within query handlers using runtime-provided arguments.

```typescript
import Foo from "@convex-dev/foo";
import { components } from "./_generated/server.js";

const foo = new Foo(components.foo, {
  maxShards: 10,
});
```

```typescript
export const myQuery = query({
  handler: async (ctx, args) => {
    const foo = new Foo(components.foo, {
      apiKey: args.customApiKey,
    });
    await foo.count(ctx);
  },
});
```

--------------------------------

### Initialize Convex Data Import CLI

Source: https://docs.convex.dev/database/import-export/import

This command initializes the Convex data import utility, providing a starting point for various data import operations. It is the base command for interacting with the Convex import tool.

```bash
npx convex import
```

--------------------------------

### Query Result - Initial Task List Response

Source: https://context7_llms

Sample JSON response from the getAllOpenTasks query showing the initial state of incomplete tasks. Each task object contains an ID, title, and completion status. This demonstrates the data structure returned by the query before any mutations are applied.

```json
[
  { _id: "e4g", title: "Grocery shopping", complete: false },
  { _id: "u9v", title: "Plant new flowers", complete: false }
]
```

--------------------------------

### Get Authentication Token

Source: https://context7_llms

Retrieves the current JWT authentication token and its decoded claims, if available.

```APIDOC
## SDK Function client.getAuth

### Description
Get the current JWT auth token and decoded claims.

### Method
SDK Function

### Endpoint
client.getAuth()

### Parameters

### Response
#### Success Response (200)
- **undefined | { token: string; decoded: Record<string, any> }** (Object) - The current JWT token and its decoded claims, or `undefined` if no token is set.
```

--------------------------------

### Applying a Simple Global Rate Limit (JavaScript)

Source: https://convex.dev/components/rate-limiter

This example shows how to apply a global rate limit for a specific action, such as 'freeTrialSignUp'. It returns an `ok` boolean indicating success and `retryAfter` timestamp if the limit is exceeded. Users should add jitter when retrying to prevent thundering herds.

```javascript
const { ok, retryAfter } = await rateLimiter.limit(ctx, "freeTrialSignUp");
```

--------------------------------

### GET /teams/:team_id/list_projects

Source: https://context7_llms

List all projects belonging to a specific team. Returns an array of project objects with metadata.

```APIDOC
## GET /teams/:team_id/list_projects

### Description
List all projects for a team.

### Method
GET

### Endpoint
/teams/:team_id/list_projects

### Authentication
Bearer Token (obtained through Convex OAuth application)

### Path Parameters
- **team_id** (string) - Required - The ID of the team

### Response
#### Success Response (200)
- **projects** (array) - Array of project objects
  - **project_id** (string) - Unique project identifier
  - **name** (string) - Project name
  - **created_at** (string) - ISO 8601 timestamp of project creation

### Error Responses
- **400** - Bad Request - Invalid team ID
- **401** - Unauthorized - Invalid or missing authentication token
- **403** - Forbidden - Insufficient permissions
```

--------------------------------

### Example `push_config` Audit Log in Convex (JSON)

Source: https://docs.convex.dev/production/integrations/log-streams/legacy-event-schema

This JSON snippet demonstrates a typical audit log entry for a `push_config` action within the Convex system. It records the event topic, timestamp, the specific action performed, and detailed metadata, such as modules that were added or removed during the configuration push. These logs are crucial for tracking deployment changes and ensuring system accountability.

```json
{
  "_topic": "_audit_log",
  "_timestamp": 1695066350531,
  "action": "push_config",
  "actionMetadata": {
    "modules": {
      "added": ["ffmpeg.js", "fetch.js", "test.js"],
      "removed": ["removed.js"]
    }
  }
}
```

--------------------------------

### Configure WorkOS AuthKit Production Environment Variables

Source: https://context7_llms

Set up environment variables for WorkOS AuthKit production configuration in a .env file. Includes live API key format (sk_live_...), client ID, secure cookie password (minimum 32 characters), and production domain redirect URI.

```bash
WORKOS_CLIENT_ID="client_01XXXXXXXXXXXXXXXXXXXXXXXX"
WORKOS_API_KEY="sk_live_..."
WORKOS_COOKIE_PASSWORD="your_secure_password_here_must_be_at_least_32_characters_long"
NEXT_PUBLIC_WORKOS_REDIRECT_URI="https://your-domain.com/callback"
```

--------------------------------

### Configure Netlify Build Command for Convex Preview Deployments

Source: https://context7_llms

This command is used within Netlify's build settings to deploy Convex functions, trigger a frontend build, and optionally execute a specified Convex function (`functionName`) to seed initial data. It ensures that each preview deployment operates with a fresh, isolated Convex backend.

```shell
npx convex deploy --cmd 'npm run build' --preview-run 'functionName'
```

--------------------------------

### Create Next.js Project with Convex and Clerk

Source: https://docs.convex.dev/client/nextjs

Command-line instruction to scaffold a new Next.js project with Convex and Clerk authentication pre-configured. This simplifies the setup process by automatically generating the necessary configuration and boilerplate code for Next.js 15 compatibility.

```bash
npm create convex@latest -- -t nextjs-clerk
```

--------------------------------

### Configure Message Storage Options for Text Generation

Source: https://docs.convex.dev/agents/messages

This example shows how to configure `storageOptions` when calling `thread.generateText`. This allows control over which messages (prompt, output, all, none) are saved to the database.

```javascript
const result = await thread.generateText({ messages }, {
  storageOptions: {
    saveMessages: "all" | "none" | "promptAndOutput";
  },
});

```

--------------------------------

### BaseConvexClientOptions Configuration

Source: https://context7_llms

Configuration options for initializing BaseConvexClient and its subclasses. Includes settings for unsaved changes warnings, custom WebSocket constructors, and verbose logging.

```APIDOC
## BaseConvexClientOptions

### Description
Configuration options for BaseConvexClient initialization. These options control client behavior including unsaved changes warnings, WebSocket communication, and debug logging.

### Properties

#### unsavedChangesWarning
- **Name**: unsavedChangesWarning
- **Type**: boolean
- **Required**: Optional
- **Default**: true (in browsers)
- **Description**: Whether to prompt the user if they have unsaved changes pending when navigating away or closing a web page. Only available when the window object exists (in browsers).
- **Defined in**: browser/sync/client.ts:69

#### webSocketConstructor
- **Name**: webSocketConstructor
- **Type**: Object with WebSocket constructor signature
- **Required**: Optional
- **Description**: Specifies an alternate WebSocket constructor to use for client communication with the Convex cloud. The default behavior uses WebSocket from the global environment.
- **Parameters**:
  - url (string | URL) - The WebSocket connection URL
  - protocols (string | string[] optional) - Subprotocols to use
- **Returns**: WebSocket instance
- **Defined in**: browser/sync/client.ts:76

#### verbose
- **Name**: verbose
- **Type**: boolean
- **Required**: Optional
- **Default**: false
- **Description**: Adds additional logging for debugging purposes
- **Defined in**: browser/sync/client.ts:82

### Inheritance
- **Extended by**: ConvexReactClientOptions

### Usage
Pass these options when creating a BaseConvexClient instance to customize connection behavior and logging.
```

--------------------------------

### GET /BaseConvexClient/getCurrentAuthClaims

Source: https://docs.convex.dev/api/classes/browser.BaseConvexClient

Retrieves the currently active JWT authentication token and its decoded claims.

```APIDOC
## GET /BaseConvexClient/getCurrentAuthClaims

### Description
Returns the current authentication token and its decoded payload. If no authentication is active, it returns `undefined`.

### Method
GET

### Endpoint
/BaseConvexClient/getCurrentAuthClaims

### Parameters
#### Query Parameters
- No parameters.

### Request Example
```json
{}
```

### Response
#### Success Response (200)
- **authClaims** (object | undefined) - An object containing the `token` (string) and `decoded` (Record<string, any>) claims, or `undefined` if no token is present.

#### Response Example
```json
{
  "authClaims": {
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "decoded": {
      "sub": "user123",
      "exp": 1678972800,
      "iat": 1678886400
    }
  }
}
```
```

--------------------------------

### Optimize Convex Queries with Indexes in TypeScript

Source: https://docs.convex.dev/understanding/best-practices

This snippet demonstrates how to improve Convex database query performance by using an index instead of fetching and filtering all records. The '' example shows a potentially unbounded query that collects all movies and filters in-memory, while the '' example efficiently uses `withIndex` to query only relevant records, suitable for large datasets.

```ts
//  -- potentially unbounded
const allMovies = await ctx.db.query("movies").collect();
const moviesByDirector = allMovies.filter(
  (m) => m.director === "Steven Spielberg",
);
```

```ts
//  -- small number of results, so `collect` is fine
const moviesByDirector = await ctx.db
  .query("movies")
  .withIndex("by_director", (q) => q.eq("director", "Steven Spielberg"))
  .collect();
```

--------------------------------

### Call Convex Query Function via HTTP POST

Source: https://context7_llms

This code snippet demonstrates how to interact with Convex backend query functions by sending an HTTP POST request to the `/api/query` endpoint. Examples are provided for cURL, NodeJS (using `fetch`), and Python (using `requests`). Each example sends a JSON body containing the target function's `path`, `args`, and desired `format`, receiving a JSON response with the function's result or error details.

```bash
curl https://acoustic-panther-728.convex.cloud/api/query \
   -d '{"path": "messages:list", "args": {}, "format": "json"}' \
   -H "Content-Type: application/json"
```

```javascript
const url = "https://acoustic-panther-728.convex.cloud/api/query";
const request = { path: "messages:list", args: {}, format: "json" };

const response = fetch(url, {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify(request),
});
```

```python
import requests

url = "https://acoustic-panther-728.convex.cloud/api/query"
headers = {"accept": "application/json"}
body = {"path": "messages:list", "args": {}, "format": "json"}

response = requests.post(url, headers=headers, json=body)
```

--------------------------------

### Set Up Convex Provider in React Application

Source: https://context7_llms

Initializes the Convex client in the main React application entry point to make it available throughout the app. Uses environment variables to configure the Convex URL and integrates with React Query for data management.

```typescript
import { ConvexProvider, ConvexReactClient } from "convex/react";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ConvexQueryClient } from "@convex-dev/react-query";

const convex = new ConvexReactClient(import.meta.env.VITE_CONVEX_URL);
const queryClient = new QueryClient();
const convexQueryClient = new ConvexQueryClient(convex);

export default function App() {
  return (
    <ConvexProvider client={convex}>
      <QueryClientProvider client={queryClient}>
        {/* App components */}
      </QueryClientProvider>
    </ConvexProvider>
  );
}
```

--------------------------------

### GET /deployments/:deployment_name/custom_domains

Source: https://context7_llms

Retrieve all custom domains configured for a deployment. Returns a list of domains currently associated with the deployment.

```APIDOC
## GET /deployments/:deployment_name/custom_domains

### Description
Get all custom domains configured for a deployment.

### Method
GET

### Endpoint
/deployments/:deployment_name/custom_domains

### Authentication
Bearer Token (obtained through Convex OAuth application)

### Path Parameters
- **deployment_name** (string) - Required - The name of the deployment

### Response
#### Success Response (200)
- **custom_domains** (array) - Array of custom domain objects
  - **domain** (string) - The custom domain
  - **status** (string) - Domain configuration status
  - **created_at** (string) - ISO 8601 timestamp of creation

### Error Responses
- **401** - Unauthorized - Invalid or missing authentication token
- **404** - Not Found - Deployment does not exist
```

--------------------------------

### Register and Test Convex Agent Component with Helper Function

Source: https://docs.convex.dev/components/using

Demonstrates how to initialize a test instance with the agent component using a helper function, then run tests that create threads and query thread data. The helper function registers the component schema and validates inputs/outputs. This approach is recommended for reusable test setup across multiple test files.

```typescript
import agentTest from "@convex-dev/agent/test";
import { expect, test } from "vitest";
import { convexTest } from "convex-test";
import { components } from "./_generated/api";
import { createThread } from "@convex-dev/agent";

// Define this once, often in a shared test helper file.
export function initConvexTest() {
  const t = convexTest();
  agentTest.register(t);
  return t;
}

test("Agent createThread", async () => {
  const t = initConvexTest();

  const threadId = await t.run(async (ctx) => {
    // Calling functions that use ctx and components.agent
    return await createThread(ctx, components.agent, {
      title: "Hello, world!",
    });
  });
  // Calling functions directly on the component's API
  const thread = await t.query(components.agent.threads.getThread, {
    threadId,
  });
  expect(thread).toMatchObject({
    title: "Hello, world!",
  });
});
```

--------------------------------

### FUNCTION get

Source: https://docs.convex.dev/api/interfaces/server.StorageActionWriter

Retrieves a Blob from storage using its ID. Returns null if the file associated with the provided `storageId` is not found.

```APIDOC
## FUNCTION get

### Description
Get a Blob containing the file associated with the provided `storageId`, or `null` if there is no file.

### Method
Function Call

### Endpoint
get

### Parameters
#### Path Parameters
N/A

#### Query Parameters
N/A

#### Request Body
- **storageId** (`GenericId<"_storage">`) - Required - The ID of the stored blob to retrieve.

### Request Example
N/A

### Response
#### Success Response (Function Return)
- `Blob` - The stored file content.
- `null` - If no file is found for the given ID.

#### Response Example
N/A
```

--------------------------------

### GET /table/query

Source: https://docs.convex.dev/api/interfaces/server.BaseTableWriter

Initiates a query builder for the table, allowing for flexible data retrieval. This method returns a QueryInitializer that can be further chained with conditions before execution. This method is inherited from BaseTableReader.

```APIDOC
## GET /table/query

### Description
Initiates a query builder for the table, allowing for flexible data retrieval. This method returns a QueryInitializer that can be further chained with conditions before execution. This method is inherited from BaseTableReader.

### Method
GET

### Endpoint
/table/query

### Parameters
#### Query Parameters
- **No direct query parameters for the initial call, further chaining with QueryInitializer is expected.**

### Request Example
{}

### Response
#### Success Response (200)
- **query_initializer** (QueryInitializer<NamedTableInfo<DataModel, TableName>>) - An object to start building a query.

#### Response Example
{
  "query_initializer_object": "Represents an internal query builder object ready for further chaining."
}
```

--------------------------------

### Initialize ConvexClient and subscribe to query updates with onUpdate (TypeScript)

Source: https://docs.convex.dev/api/classes/browser.ConvexClient

This TypeScript example demonstrates how to instantiate a `ConvexClient` by providing the Convex cloud address. It then uses the `client.onUpdate` method to subscribe to changes from a Convex query function (e.g., `api.messages.list`). The provided callback function will execute whenever new results for the query are received, logging the first message's body.

```typescript
const client = new ConvexClient("https://happy-otter-123.convex.cloud");
const unsubscribe = client.onUpdate(api.messages.list, {}, (messages) => {
  console.log(messages[0].body);
});
```

--------------------------------

### GET /list_environment_variables

Source: https://context7_llms

Retrieves all environment variables configured in a deployment. Note that secret environment variables may not be included in future versions of this API.

```APIDOC
## GET /list_environment_variables

### Description
Get all environment variables in a deployment. In the future this might not include "secret" environment variables.

### Method
GET

### Endpoint
/list_environment_variables

### Authorization
- Required: Authorization header with Convex deployment key or access token
- Format: `Authorization: Convex {token}`

### Response
#### Success Response (200)
- Returns an array of environment variable objects configured in the deployment

### Example Request
```
GET /list_environment_variables
Headers:
  Authorization: Convex ey...0=
```
```

--------------------------------

### Calling Internal Convex Actions for Backend Operations

Source: https://context7_llms

This example illustrates how to define a Convex action that uses the `internal` API object to call other internal Convex functions. It showcases a scenario where an action interacts with an external service (e.g., payment provider) and then updates the Convex database securely using an internal mutation.

```javascript
import { action } from "../_generated/server";
import { internal } from "../_generated/api";

export default action({
  handler: async ({ runMutation }, { planId, ... }) => {
    // Call out to payment provider (e.g. Stripe) to charge customer
    const response = await fetch(...);
    if (response.ok) {
      // Mark the plan as "professional" in the Convex DB
      await runMutation(internal.plans.markPlanAsProfessional, { planId });
    }
  }
});
```

--------------------------------

### Configure Root Route with Clerk Authentication and Convex

Source: https://context7_llms

Configures the root route component for TanStack Start with Clerk authentication and Convex integration. Creates a server function to fetch Clerk auth tokens with the 'convex' template, sets the token in beforeLoad to enable server-side authenticated queries, and wraps the application with ClerkProvider and ConvexProviderWithClerk for client-side authentication state management.

```TypeScript
import {
  Link,
  Outlet,
  createRootRouteWithContext,
  useRouteContext,
} from '@tanstack/react-router'
import {
  ClerkProvider,
  SignInButton,
  SignedIn,
  SignedOut,
  UserButton,
  useAuth,
} from '@clerk/tanstack-start'
import { TanStackRouterDevtools } from '@tanstack/router-devtools'
import { Meta, Scripts, createServerFn } from '@tanstack/start'
import { QueryClient } from '@tanstack/react-query'
import * as React from 'react'
import { getAuth } from '@clerk/tanstack-start/server'
import { getWebRequest } from 'vinxi/http'
import { DefaultCatchBoundary } from '~/components/DefaultCatchBoundary.js'
import { NotFound } from '~/components/NotFound.js'
import appCss from '~/styles/app.css?url'
import { ConvexQueryClient } from '@convex-dev/react-query'
import { ConvexReactClient } from 'convex/react'
import { ConvexProviderWithClerk } from 'convex/react-clerk'

const fetchClerkAuth = createServerFn({ method: 'GET' }).handler(async () => {
  const auth = await getAuth(getWebRequest())
  const token = await auth.getToken({ template: 'convex' })

  return {
    userId: auth.userId,
    token,
  }
})

export const Route = createRootRouteWithContext<{
  queryClient: QueryClient
  convexClient: ConvexReactClient
  convexQueryClient: ConvexQueryClient
}>()({
  head: () => ({
    meta: [
      {
        charSet: 'utf-8',
      },
      {
        name: 'viewport',
        content: 'width=device-width, initial-scale=1',
      },
    ],
    links: [
      { rel: 'stylesheet', href: appCss },
      {
        rel: 'apple-touch-icon',
        sizes: '180x180',
        href: '/apple-touch-icon.png',
      },
      {
        rel: 'icon',
        type: 'image/png',
        sizes: '32x32',
        href: '/favicon-32x32.png',
      },
      {
        rel: 'icon',
        type: 'image/png',
        sizes: '16x16',
        href: '/favicon-16x16.png',
      },
      { rel: 'manifest', href: '/site.webmanifest', color: '#fffff' },
      { rel: 'icon', href: '/favicon.ico' },
    ],
  }),
  beforeLoad: async (ctx) => {
    const auth = await fetchClerkAuth()
    const { userId, token } = auth

    if (token) {
      ctx.context.convexQueryClient.serverHttpClient?.setAuth(token)
    }
  },
})
```

--------------------------------

### Set up ConvexProvider in React application

Source: https://context7_llms

Configure the Convex client and wrap your React app with ConvexProvider in the main entry point. This initializes the Convex connection using environment variables and enables all Convex hooks throughout your component tree.

```typescript
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import "./index.css";
import { ConvexProvider, ConvexReactClient } from "convex/react";

const convex = new ConvexReactClient(import.meta.env.VITE_CONVEX_URL as string);

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <ConvexProvider client={convex}>
      <App />
    </ConvexProvider>
  </React.StrictMode>,
);
```

--------------------------------

### Schedule a Convex Action via a Mutation (Recommended Pattern)

Source: https://docs.convex.dev/functions/actions

This example illustrates the recommended pattern for triggering actions by first calling a mutation, which captures user intent and writes to the database, and then scheduling an internal action. This approach allows the mutation to enforce invariants and prevents direct client-side action calls, which are often an anti-pattern.

```ts
import { v } from "convex/values";
import { internal } from "./_generated/api";
import { internalAction, mutation } from "./_generated/server";

export const mutationThatSchedulesAction = mutation({
  args: { text: v.string() },
  handler: async (ctx, { text }) => {
    const taskId = await ctx.db.insert("tasks", { text });
    await ctx.scheduler.runAfter(0, internal.myFunctions.actionThatCallsAPI, {
      taskId,
      text,
    });
  },
});

export const actionThatCallsAPI = internalAction({
  args: { taskId: v.id("tasks"), text: v.string() },
  handler: (_, args): void => {
    // do something with `taskId` and `text`, like call an API
    // then run another mutation to store the result
  },
});
```

--------------------------------

### Example OpenAPI Specification YAML Structure

Source: https://context7_llms

An illustrative snippet of the `convex-spec.yaml` file, which is generated automatically by the Convex Helpers tool. This YAML file describes the structure of your Convex application's API, including its title, version, server URLs, and general description, conforming to OpenAPI 3.0.3.

```yaml
# convex-spec.yaml
openapi: 3.0.3
info:
  title: Convex App - OpenAPI 3.0
  version: 0.0.0
  servers:
    - url: "{hostUrl}"
  description: Convex App API
  ...
```

--------------------------------

### Configure Convex URL in Nuxt

Source: https://docs.convex.dev/quickstart/nuxt

Adds the Convex application's URL to the Nuxt configuration file (`nuxt.config.ts`). This step is crucial for the Nuxt app to communicate with your Convex backend, typically by reading the URL from environment variables.

```typescript
export default defineNuxtConfig({
  compatibilityDate: '2025-07-15',
  devtools: { enabled: true },
  modules: ['convex-nuxt'],
  convex: {
    url: process.env.CONVEX_URL
  },
})
```

--------------------------------

### Specify HttpAction with Path and PathPrefix using HttpRouter

Source: https://docs.convex.dev/api/classes/server.HttpRouter

This example illustrates how to use the `route` method of HttpRouter to specify HTTP actions. It shows two common scenarios: matching an exact path and matching paths with a prefix. This method is crucial for defining how your Convex application responds to incoming HTTP requests.

```typescript
// matches `/profile` (but not `/profile/`)
http.route({ path: "/profile", method: "GET", handler: getProfile})

// matches `/profiles/`, `/profiles/abc`, and `/profiles/a/c/b` (but not `/profile`)
http.route({ pathPrefix: "/profile/", method: "GET", handler: getProfile})
```

--------------------------------

### Configure Root Layout with Clerk and Convex Providers

Source: https://docs.convex.dev/auth/clerk

Set up the Next.js root layout (app/layout.tsx) wrapping ConvexClientProvider with ClerkProvider. The ClerkProvider must wrap ConvexClientProvider to ensure Convex can access Clerk authentication context.

```typescript
import type { Metadata } from 'next'
import { Geist, Geist_Mono } from 'next/font/google'
import './globals.css'
import { ClerkProvider } from '@clerk/nextjs'
import ConvexClientProvider from '@/components/ConvexClientProvider'

const geistSans = Geist({
  variable: '--font-geist-sans',
  subsets: ['latin'],
})

const geistMono = Geist_Mono({
  variable: '--font-geist-mono',
  subsets: ['latin'],
})

export const metadata: Metadata = {
  title: 'Clerk Next.js Quickstart',
  description: 'Generated by create next app',
}

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode
}>) {
  return (
    <html lang="en">
      <body className={`${geistSans.variable} ${geistMono.variable} antialiased`}>
        <ClerkProvider>
          <ConvexClientProvider>{children}</ConvexClientProvider>
        </ClerkProvider>
      </body>
    </html>
  )
}
```

--------------------------------

### GET /getAuthorMessages/{authorSuffix}

Source: https://context7_llms

Retrieves messages for an author using a path suffix. This demonstrates routing with a path prefix to handle dynamic path segments.

```APIDOC
## GET /getAuthorMessages/{authorSuffix}

### Description
This endpoint allows retrieving messages where the author identifier is part of the URL path. It uses a `pathPrefix` routing mechanism.

### Method
GET

### Endpoint
/getAuthorMessages/{authorSuffix}

### Parameters
#### Path Parameters
- **authorSuffix** (string) - Required - A dynamic segment of the path identifying the author, e.g., `User+123`.

### Request Example
```json
{}
```

### Response
#### Success Response (200)
Returns messages associated with the author identified by the path suffix. The exact structure of the response is not specified in the provided text.

#### Response Example
```json
[
  { "id": "789", "author": "User 123", "body": "Hello from User 123" }
]
```
```

--------------------------------

### Configure React Client with Auth0Provider and Environment Variables

Source: https://docs.convex.dev/auth/auth0

Initialize ConvexReactClient and Auth0Provider with environment variables for VITE_CONVEX_URL, VITE_AUTH0_DOMAIN, and VITE_AUTH0_CLIENT_ID. Wraps application with ConvexProviderWithAuth0 to enable authentication across the app.

```TypeScript
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import "./index.css";
import { ConvexReactClient } from "convex/react";
import { ConvexProviderWithAuth0 } from "convex/react-auth0";
import { Auth0Provider } from "@auth0/auth0-react";

const convex = new ConvexReactClient(import.meta.env.VITE_CONVEX_URL as string);

ReactDOM.createRoot(document.getElementById("root")!).render(
  <Auth0Provider
    domain={import.meta.env.VITE_AUTH0_DOMAIN}
    clientId={import.meta.env.VITE_AUTH0_CLIENT_ID}
    authorizationParams={{
      redirect_uri: window.location.origin,
    }}
  >
    <ConvexProviderWithAuth0 client={convex}>
      <App />
    </ConvexProviderWithAuth0>
  </Auth0Provider>,
  document.getElementById("root")
);
```

--------------------------------

### GET /storage/{storageId}

Source: https://context7_llms

Retrieves a file from Convex storage as a Blob using its `Id<"_storage">`. Returns `null` if the file does not exist.

```APIDOC
## GET /storage/{storageId}

### Description
Retrieves a file from Convex storage as a Blob using its `Id<"_storage">`. Returns `null` if the file does not exist.

### Method
GET

### Endpoint
/storage/{storageId}

### Parameters
#### Path Parameters
- **storageId** (`GenericId<"_storage">`) - Required - The `Id<"_storage">` of the file to retrieve from Convex storage.

#### Request Body
(No request body required for this operation.)

### Request Example
{}

### Response
#### Success Response (200 OK)
- **file** (`Blob` | `null`) - The file content as a Blob, or `null` if not found.

#### Response Example
{
  "fileContent": "<binary_data_of_the_blob>"
}
```

--------------------------------

### Deploy to Convex with Build Command

Source: https://docs.convex.dev/production/hosting/custom

This command deploys your backend code to Convex and runs a specified build command. It's crucial for deploying production-ready code. Ensure you have configured your environment and dependencies correctly.

```bash
npx convex deploy --cmd 'npm run build'
```

```bash
npx convex deploy --cmd-url-env-var-name CUSTOM_CONVEX_URL --cmd 'npm run build'
```

--------------------------------

### POST /api/query, /api/mutation, /api/action

Source: https://context7_llms

These HTTP endpoints allow you to call Convex functions and get the result as a value. Use them to execute queries, mutations, or actions defined in your Convex backend.

```APIDOC
## POST /api/query, /api/mutation, /api/action

### Description
Call Convex backend functions (query, mutation, action) via HTTP POST.

### Method
POST

### Endpoint
/api/query, /api/mutation, /api/action

### Parameters
#### Request Body
- **path** (string) - Required - Path to the Convex function formatted as a string.
- **args** (object) - Required - Named argument object to pass to the Convex function.
- **format** (string) - Optional - Output format for values. Valid values: `json`

### Request Example
```json
{
  "path": "messages:list",
  "args": {},
  "format": "json"
}
```

### Response
#### Success Response (200)
- **status** (string) - "success"
- **value** (object) - Result of the Convex function in the requested format.
- **logLines** (list[string]) - Log lines printed out during the function execution.

#### Response Example
```json
{
  "status": "success",
  "value": {
    "_id": "123",
    "text": "Hello, Convex!"
  },
  "logLines": [
    "Function 'messages:list' executed."
  ]
}
```

#### Error Response
- **status** (string) - "error"
- **errorMessage** (string) - The error message.
- **errorData** (object) - Error data within an application error if it was thrown.
- **logLines** (list[string]) - Log lines printed out during the function execution.

#### Error Response Example
```json
{
  "status": "error",
  "errorMessage": "Function 'messages:get' not found.",
  "errorData": {
    "code": "NotFound"
  },
  "logLines": [
    "Attempted to call non-existent function."
  ]
}
```
```

--------------------------------

### Display Real-time Data with SwiftUI (Swift)

Source: https://docs.convex.dev/quickstart/swift

Connects a SwiftUI view to a Convex query to display a list of todo items. The UI automatically updates when data in the 'tasks' table changes.

```swift
struct ContentView: View {
  @State private var todos: [Todo] = []

  var body: some View {
    List {
      ForEach(todos, id: \._id) {
        todo in
        Text(todo.text)
      }
    }.task {
      for await todos: [Todo] in convex.subscribe(to: "tasks:get")
        .replaceError(with: []).values
      {
        self.todos = todos
      }
    }.padding()
  }
}
```

--------------------------------

### Configure Convex MCP Server for Windsurf

Source: https://docs.convex.dev/ai/using-windsurf

This configuration snippet sets up the Convex Model Context Protocol (MCP) server within Windsurf. It specifies the command to run ('npx') and the arguments needed to start the latest Convex MCP server. This enables AI agents to access and interact with your Convex deployment.

```json
{
  "mcpServers": {
    "convex": {
      "command": "npx",
      "args": ["-y", "convex@latest", "mcp", "start"]
    }
  }
}
```

--------------------------------

### GET /get_canonical_urls

Source: https://context7_llms

Retrieves the canonical URLs configured for a deployment. This endpoint allows you to fetch the currently set canonical URLs for your Convex deployment.

```APIDOC
## GET /get_canonical_urls

### Description
Get the canonical URLs for a deployment.

### Method
GET

### Endpoint
/get_canonical_urls

### Authorization
- Required: Authorization header with Convex deployment key or access token
- Format: `Authorization: Convex {token}`

### Response
#### Success Response (200)
- Returns the canonical URLs configured for the deployment

### Example Request
```
GET /get_canonical_urls
Headers:
  Authorization: Convex ey...0=
```
```

--------------------------------

### Add and Get Convex MCP Server via Claude

Source: https://docs.convex.dev/ai/convex-mcp-server

Commands to add a Convex MCP server configuration and retrieve its details using the Claude AI assistant.

```shell
claude mcp add-json convex '{"type":"stdio","command":"npx","args":["convex","mcp","start"]}'
claude mcp get convex
```

--------------------------------

### Setup Auth0 Provider with Convex in Next.js _app.jsx

Source: https://context7_llms

Configures Auth0 authentication provider and Convex client in the Next.js application root component. This wrapper enables client-side authentication by wrapping the app with Auth0Provider and ConvexProviderWithAuth0, allowing conditional rendering of pages until user authentication. Requires Auth0 domain, client ID, and Convex URL environment variables.

```typescript
import { ConvexReactClient } from "convex/react";
import { ConvexProviderWithAuth0 } from "convex/react-auth0";
import { Auth0Provider } from "@auth0/auth0-react";
import { AppProps } from "next/app";

const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL!);

export default function MyApp({ Component, pageProps }: AppProps) {
  return (
    <Auth0Provider
      domain={process.env.NEXT_PUBLIC_AUTH0_DOMAIN!}
      clientId={process.env.NEXT_PUBLIC_AUTH0_CLIENT_ID!}
      authorizationParams={{
        redirect_uri:
          typeof window === "undefined" ? undefined : window.location.origin,
      }}
      useRefreshTokens={true}
      cacheLocation="localstorage"
    >
      <ConvexProviderWithAuth0 client={convex}>
        <Component {...pageProps} />
      </ConvexProviderWithAuth0>
    </Auth0Provider>
  );
}
```

--------------------------------

### Using `tryUpdate` with `await` for Single-Flighted Functions (JavaScript)

Source: https://stack.convex.dev/throttling-requests-by-single-flighting

This example demonstrates how a single-flighted function, specifically `tryUpdate`, returns a Promise. Using `await` allows you to asynchronously handle the outcome of the function call, logging messages only when the request is actually sent to the server. If the call fails, the exception will be thrown during the `await` operation.

```javascript
console.log('trying to update');
const result = await tryUpdate(pos);
console.log('updated: ' + result);
```

--------------------------------

### GET /table/{id}

Source: https://docs.convex.dev/api/interfaces/server.BaseTableWriter

Fetches a single document from the specified table by its unique identifier (ID). This method is inherited from BaseTableReader.

```APIDOC
## GET /table/{id}

### Description
Fetches a single document from the specified table by its unique identifier (ID). This method is inherited from BaseTableReader.

### Method
GET

### Endpoint
/table/{id}

### Parameters
#### Path Parameters
- **id** (GenericId<TableName>) - Required - The unique identifier of the document to fetch from the database.

### Request Example
{}

### Response
#### Success Response (200)
- **document** (DocumentByName<DataModel, TableName> | null) - The document at the given GenericId, or null if it no longer exists.

#### Response Example
{
  "id": "12345",
  "name": "Example Document",
  "status": "active"
}

Alternatively:
null
```

--------------------------------

### Combined Search and Additional Filtering

Source: https://context7_llms

Execute a search query with a search index filter followed by additional post-query filtering. This example retrieves recent messages containing specific text.

```APIDOC
## Combined Search and Additional Filtering

### Description
Query a search index and then apply additional filtering using the `.filter()` method to further restrict results based on other criteria.

### Method
GET (Database Query)

### Endpoint
`ctx.db.query(tableName).withSearchIndex(indexName, filterExpression).filter(additionalFilter).take(limit)`

### Parameters
#### Required Parameters
- **tableName** (string) - Name of the table to query
- **indexName** (string) - Name of the search index
- **searchField** (string) - Field to search
- **searchQuery** (string) - Search query terms

#### Optional Parameters
- **additionalFilter** (function) - Function defining post-query filters
- **filterField** (string) - Field to apply additional filtering on
- **filterValue** (any) - Value to compare against
- **limit** (number) - Maximum results to return

### Request Example
```typescript
const messages = await ctx.db
  .query("messages")
  .withSearchIndex("search_body", (q) => q.search("body", "hi"))
  .filter((q) => q.gt(q.field("_creationTime"), Date.now() - 10 * 60000))
  .take(10);
```

### Response
#### Success Response
- **results** (array) - Documents matching both search index and filter criteria
- **_creationTime** (number) - Timestamp of document creation
- **document** (object) - All fields from matching documents

#### Response Example
```typescript
[
  {
    "_id": "msg_123",
    "body": "hi there",
    "_creationTime": 1234567890000
  },
  {
    "_id": "msg_124",
    "body": "hi everyone",
    "_creationTime": 1234567895000
  }
]
```

### Best Practices
- Put as many filters as possible in `.withSearchIndex()` for performance
- Use `.filter()` only for criteria that cannot be expressed in the search filter expression
- Search index filters are applied first, then post-query filters are applied one-by-one
- More specific search filter expressions reduce results faster and prevent hitting query limits
```

--------------------------------

### Schedule Internal Convex Action via a Mutation

Source: https://context7_llms

Illustrates the recommended pattern for client-initiated actions, where a client calls a mutation that then schedules an internal action. This approach allows the mutation to enforce invariants and ensures the action runs after database updates, providing a robust workflow for complex operations.

```TypeScript
import { v } from "convex/values";
import { internal } from "./_generated/api";
import { internalAction, mutation } from "./_generated/server";

export const mutationThatSchedulesAction = mutation({
  args: { text: v.string() },
  handler: async (ctx, { text }) => {
    const taskId = await ctx.db.insert("tasks", { text });
    await ctx.scheduler.runAfter(0, internal.myFunctions.actionThatCallsAPI, {
      taskId,
      text
    });
  }
});

export const actionThatCallsAPI = internalAction({
  args: { taskId: v.id("tasks"), text: v.string() },
  handler: (_, args): void => {
    // do something with `taskId` and `text`, like call an API
    // then run another mutation to store the result
  }
});
```

--------------------------------

### GET ConvexClient.client

Source: https://context7_llms

Accesses the underlying BaseConvexClient instance used by ConvexClient, allowing for additional control over the client's behavior.

```APIDOC
## GET ConvexClient.client

### Description
Accesses the underlying `BaseConvexClient` instance that this `ConvexClient` wraps, providing additional control and functionality.

### Method
GET (Accessor)

### Endpoint
ConvexClient.client

### Parameters
#### Path Parameters
- No path parameters.

#### Query Parameters
- No query parameters.

#### Request Body
- No request body.

### Request Example
```javascript
// Accessing the 'client' property
const baseClient = client.client;
```

### Response
#### Success Response (200)
- **client** (BaseConvexClient) - The underlying `BaseConvexClient` instance.

#### Response Example
```json
// Returns an instance of BaseConvexClient
```
```

--------------------------------

### GET ConvexClient.disabled

Source: https://context7_llms

Checks if the client is currently disabled, which might happen under certain conditions.

```APIDOC
## GET ConvexClient.disabled

### Description
Retrieves a boolean indicating whether the client is currently disabled.

### Method
GET (Accessor)

### Endpoint
ConvexClient.disabled

### Parameters
#### Path Parameters
- No path parameters.

#### Query Parameters
- No query parameters.

#### Request Body
- No request body.

### Request Example
```javascript
// Accessing the 'disabled' property
const isDisabled = client.disabled;
```

### Response
#### Success Response (200)
- **disabled** (boolean) - `true` if the client is disabled, `false` otherwise.

#### Response Example
```json
false
```
```

--------------------------------

### Setup Convex Client Provider with Auth0 in Next.js

Source: https://context7_llms

Configures Auth0 authentication provider with Convex React client for Next.js applications. Wraps the application with Auth0Provider and ConvexProviderWithAuth0 to enable authentication and real-time data access. Requires NEXT_PUBLIC_AUTH0_DOMAIN, NEXT_PUBLIC_AUTH0_CLIENT_ID, and NEXT_PUBLIC_CONVEX_URL environment variables.

```TypeScript
"use client";

import { Auth0Provider } from "@auth0/auth0-react";
import { ConvexReactClient } from "convex/react";
import { ConvexProviderWithAuth0 } from "convex/react-auth0";
import { ReactNode } from "react";

const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL!);

export function ConvexClientProvider({ children }: { children: ReactNode }) {
  return (
    <Auth0Provider
      domain={process.env.NEXT_PUBLIC_AUTH0_DOMAIN!}
      clientId={process.env.NEXT_PUBLIC_AUTH0_CLIENT_ID!}
      authorizationParams={{
        redirect_uri:
          typeof window === "undefined" ? undefined : window.location.origin,
      }}
      useRefreshTokens={true}
      cacheLocation="localstorage"
    >
      <ConvexProviderWithAuth0 client={convex}>
        {children}
      </ConvexProviderWithAuth0>
    </Auth0Provider>
  );
}
```

--------------------------------

### Cancel Scheduled Function API

Source: https://docs.convex.dev/api/interfaces/server.Scheduler

Cancels a previously scheduled function if it has not yet started.

```APIDOC
## DELETE /scheduler/cancel

### Description
Cancels a previously scheduled function. If the scheduled function is already in progress, it will continue running, but any new functions it attempts to schedule will be canceled.

### Method
DELETE

### Endpoint
/scheduler/cancel

### Parameters
#### Query Parameters
- **id** (GenericId<"_scheduled_functions">) - Required - The ID of the scheduled function to cancel.

### Request Example
```
DELETE /scheduler/cancel?id=_scheduled_functions/some_id
```

### Response
#### Success Response (200)
- **message** (string) - Indicates the cancellation status.

#### Response Example
```json
{
  "message": "Scheduled function canceled successfully."
}
```
```

--------------------------------

### GET /client.logger - Logger Accessor

Source: https://context7_llms

Retrieves the Logger instance associated with this client. The logger can be used for debugging and monitoring client activity.

```APIDOC
## Accessor: logger

### Description
Returns the Logger instance for this client, which can be used for debugging and tracking client operations.

### Method
GET

### Endpoint
client.logger

### Response
#### Success Response
- **logger** (Logger) - The Logger instance configured for this client

### Response Example
```typescript
const logger = client.logger;
// Use logger for debugging
logger.log('Client initialized');
```
```

--------------------------------

### Use NPM Packages in Query Handler

Source: https://docs.convex.dev/functions/query-functions

Demonstrates importing and using NPM packages within a query handler. Queries support many NPM packages installed in node_modules, with restrictions documented in the Convex runtime documentation.

```TypeScript
import { query } from "./_generated/server";
import { faker } from "@faker-js/faker";

export const randomName = query({
  args: {},
  handler: () => {
    faker.seed();
    return faker.person.fullName();
  },
});
```

--------------------------------

### GET Database Document by ID

Source: https://context7_llms

Fetch a single document from the database by its GenericId. This method returns the document if it exists or null if it has been deleted.

```APIDOC
## GET /{table}/{id}

### Description
Fetch a single document from the database by its GenericId. Returns the document or null if it no longer exists.

### Method
GET

### Endpoint
/{table}/{id}

### Parameters
#### Path Parameters
- **table** (string) - Required - The name of the table to fetch the document from.
- **id** (GenericId<TableName>) - Required - The GenericId of the document to fetch from the database.

### Response
#### Success Response (200)
- **document** (GenericDocument | null) - The document at the given GenericId, or null if it no longer exists.
- **_id** (GenericId<TableName>) - The unique identifier of the document.

#### Response Example
{
  "_id": "document_id",
  "field1": "value1",
  "field2": "value2"
}

#### Not Found Response (null)
Returns null if the document no longer exists.

### Notes
- Type parameter TableName extends string
- This is an inherited method from BaseDatabaseReader
- Defined in: server/database.ts:128
```

--------------------------------

### React/TypeScript: Configure Convex and TanStack Query in main.tsx

Source: https://context7_llms

This TypeScript code from `src/main.tsx` demonstrates the full setup for connecting Convex with TanStack Query in a React application. It initializes `ConvexReactClient` and `ConvexQueryClient`, configures `QueryClient` with Convex-specific hash and query functions, and wraps the app with both `ConvexProvider` and `QueryClientProvider` to enable both Convex and TanStack Query hooks.

```typescript
import { ConvexQueryClient } from "@convex-dev/react-query";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ConvexProvider, ConvexReactClient } from "convex/react";
import ReactDOM from "react-dom/client";
import App from "./App";
import "./index.css";

const convex = new ConvexReactClient(import.meta.env.VITE_CONVEX_URL);
const convexQueryClient = new ConvexQueryClient(convex);
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryKeyHashFn: convexQueryClient.hashFn(),
      queryFn: convexQueryClient.queryFn(),
    },
  },
});
convexQueryClient.connect(queryClient);

ReactDOM.createRoot(document.getElementById("root")!).render(
  <ConvexProvider client={convex}>
    <QueryClientProvider client={queryClient}>
      <App />
    </QueryClientProvider>
  </ConvexProvider>,
);
```

--------------------------------

### Unit Test Convex Functions with ConvexTestingHelper

Source: https://stack.convex.dev/testing-with-local-oss-backend

Complete test suite demonstrating how to use ConvexTestingHelper to test Convex queries and mutations. Shows setup/teardown lifecycle, calling mutations and queries with test data, and asserting results. Tests isolation of user data across sessions.

```typescript
import { api } from "./_generated/api";
import { ConvexTestingHelper } from "convex-helpers/testing";

describe("testingExample", () => {
  let t: ConvexTestingHelper;

  beforeEach(() => {
    t = new ConvexTestingHelper();
  });

  afterEach(async () => {
    await t.mutation(api.testingFunctions.clearAll, {});
    await t.close();
  });

  test("can only read own notes", async () => {
    const personASessionId = "Person A";
    await t.mutation(api.notes.add, {
      sessionId: personASessionId,
      note: "Hello from Person A"
    });

    await t.mutation(api.notes.add, {
      sessionId: personASessionId,
      note: "Hello again from Person A"
    });

    const personBSessionId = "Person B";
    await t.mutation(api.notes.add, {
      sessionId: personBSessionId,
      note: "Hello from Person B"
    });

    const personANotes = await t.query(api.notes.list, {
      sessionId: personASessionId
    });
    expect(personANotes.length).toEqual(2);
  });
});
```

--------------------------------

### Configure GitHub Actions Workflow for Automated Testing

Source: https://context7_llms

This GitHub Actions workflow defines a CI pipeline to automatically run tests for a Convex project. It triggers on pull requests and pushes, checks out the repository, sets up Node.js, installs npm dependencies, and executes the `npm run test` command on an Ubuntu runner.

```yaml
name: Run Tests

on: [pull_request, push]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
      - run: npm ci
      - run: npm run test
```

--------------------------------

### GET /api/list_snapshot

Source: https://context7_llms

Walks a consistent snapshot of documents from the database. Supports pagination through cursors and optional filtering by table. May require multiple calls to retrieve a complete snapshot.

```APIDOC
## GET /api/list_snapshot

### Description
Walks a consistent snapshot of documents in the database. It may take one or more calls to list_snapshot to walk a full snapshot. Supports pagination through cursors and optional table filtering.

### Method
GET

### Endpoint
/api/list_snapshot

### Query Parameters
- **snapshot** (int) - Optional - Database timestamp at which to continue the snapshot. The timestamp must not be older than 30 days. If omitted, the latest timestamp is selected.
- **cursor** (string) - Optional - An opaque cursor representing the progress in paginating through the snapshot. If omitted, starts from the first page of the snapshot.
- **tableName** (string) - Optional - If provided, filters the snapshot to a specific table. If omitted, provides snapshot across all tables.
- **format** (string) - Optional - Output format for values. Valid values: [json]

### Response
#### Success Response (200)
- **values** (List[ConvexValue]) - List of convex values in the requested format. Each value includes extra fields _ts and _table.
- **hasMore** (boolean) - True if there are more pages to the snapshot.
- **snapshot** (int) - A value that represents the database timestamp at which the snapshot was taken.
- **cursor** (string) - An opaque cursor representing the end of the progress on the given page. Pass this to subsequent calls.

### Response Example
{
  "values": [
    {"_ts": 1234567890, "_table": "users", "id": "user1", "name": "John Doe"},
    {"_ts": 1234567891, "_table": "posts", "id": "post1", "title": "First Post"}
  ],
  "hasMore": true,
  "snapshot": 1234567890,
  "cursor": "opaque_cursor_string_for_next_page"
}

### Usage Example
Pseudocode for retrieving a full snapshot:

```
def list_full_snapshot():
    snapshot_values = []
    snapshot = None
    cursor = None
    while True:
        result = api.list_snapshot(cursor=cursor, snapshot=snapshot)
        snapshot_values.extend(result.values)
        cursor = result.cursor
        snapshot = result.snapshot
        if not result.hasMore:
            break
    return (snapshot_values, result.snapshot)
```
```

--------------------------------

### GET /api/connectionState

Source: https://context7_llms

Retrieves the current connection state of the client with the Convex backend. This endpoint provides real-time information about the network connectivity status.

```APIDOC
## GET /api/connectionState

### Description
Retrieves the current connection state of the client with the Convex backend. This endpoint provides real-time information about the network connectivity status.

### Method
GET

### Endpoint
/api/connectionState

### Parameters
#### Path Parameters
(None)

#### Query Parameters
(None)

#### Request Body
(None)

### Request Example
(No request body needed)

### Response
#### Success Response (200)
- **connectionState** (string) - The current connection state with the Convex backend. Possible values include "Connected", "Disconnected", "Connecting".

#### Response Example
{
  "connectionState": "Connected"
}
```

--------------------------------

### ConvexClient Constructor

Source: https://docs.convex.dev/api/classes/browser.ConvexClient

Initialize a new ConvexClient instance and establish a WebSocket connection to the Convex deployment. The constructor takes the deployment URL and optional configuration parameters.

```APIDOC
## Constructor: new ConvexClient

### Description
Construct a client and immediately initiate a WebSocket connection to the passed Convex deployment address.

### Method
Constructor

### Parameters

#### Required Parameters
- **address** (string) - The Convex deployment URL (e.g., "https://happy-otter-123.convex.cloud")

#### Optional Parameters
- **options** (ConvexClientOptions) - Optional configuration object for client behavior customization

### Request Example
```javascript
const client = new ConvexClient("https://happy-otter-123.convex.cloud");
```

### Request Example with Options
```javascript
const client = new ConvexClient("https://happy-otter-123.convex.cloud", {
  // optional configuration
});
```

### Returns
ConvexClient instance with active WebSocket connection

### Notes
- Connection is initiated immediately upon construction
- No optimistic updates are provided by this client
- For additional control, consider wrapping BaseConvexClient
```

--------------------------------

### Configure Test Scripts in package.json

Source: https://stack.convex.dev/testing-with-local-oss-backend

NPM scripts configuration for running Convex tests with local backend. Includes commands for testing with existing backend and automatic backend lifecycle management. The first script assumes backend is already running, while the second uses backendHarness.js to handle setup and teardown.

```JSON
{
  "scripts": {
    "testFunctionsExistingBackend": "just convex env set IS_TEST true && just convex deploy && vitest",
    "testFunctions": "node backendHarness.js 'npm run testFunctionsExistingBackend'"
  }
}
```

--------------------------------

### Initialize ConvexHttpClient

Source: https://docs.convex.dev/api/modules/browser

Create and configure a ConvexHttpClient to establish a connection to the Convex Cloud. This is the primary entry point for browser-based applications that are not using React.

```APIDOC
## ConvexHttpClient Initialization

### Description
Initialize a ConvexHttpClient instance to connect to the Convex Cloud backend from a browser environment.

### Usage
```javascript
import { ConvexHttpClient } from "convex/browser";

const address = "https://small-mouse-123.convex.cloud";
const convex = new ConvexHttpClient(address);
```

### Parameters
- **address** (string) - Required - The Convex Cloud deployment URL

### Configuration
The address should typically be loaded from an environment variable for security and flexibility across deployments.

### Returns
- **ConvexHttpClient** - An initialized client instance ready to execute queries and mutations
```

--------------------------------

### GET /BaseConvexClient/getMaxObservedTimestamp

Source: https://docs.convex.dev/api/classes/browser.BaseConvexClient

Retrieves the maximum observed timestamp from the Convex client, if available.

```APIDOC
## GET /BaseConvexClient/getMaxObservedTimestamp

### Description
This method returns the highest timestamp observed by the client. It can be `undefined` if no timestamp has been observed yet.

### Method
GET

### Endpoint
/BaseConvexClient/getMaxObservedTimestamp

### Parameters
#### Query Parameters
- No parameters.

### Request Example
```json
{}
```

### Response
#### Success Response (200)
- **timestamp** (Long | undefined) - The maximum observed timestamp, or `undefined` if none is available.

#### Response Example
```json
{
  "timestamp": "1678886400000000000"
}
```
```

--------------------------------

### connectionState - Monitor Connection Status

Source: https://context7_llms

Get the current connection state between the client and the Convex backend. Useful for monitoring and responding to connection changes.

```APIDOC
## connectionState()

### Description
Retrieve the current connection state between the client and the Convex backend. This method allows you to monitor the status of the client-server connection.

### Method
Function call

### Signature
```
connectionState(): ConnectionState
```

### Returns
**ConnectionState** - The current connection state with the Convex backend.

### Source
Defined in: browser/sync/client.ts:792
```

--------------------------------

### Configure Convex MCP Server for VS Code

Source: https://docs.convex.dev/ai/using-github-copilot

This configuration file sets up the Convex Model Context Protocol (MCP) server within VS Code. It enables AI coding agents to interact with your Convex deployment by specifying the server type, command to execute, and arguments for starting the server. This allows for querying and optimizing Convex projects directly from your IDE.

```json
{
  "servers": {
    "convex-mcp": {
      "type": "stdio",
      "command": "npx",
      "args": ["-y", "convex@latest", "mcp", "start"]
    }
  }
}
```

--------------------------------

### useConvex Hook

Source: https://context7_llms

Get the ConvexReactClient within a React component. This relies on the ConvexProvider being above in the React component tree.

```APIDOC
## useConvex

### Description
Get the [ConvexReactClient](/api/classes/react.ConvexReactClient.md) within a React component.

This relies on the [ConvexProvider](/api/modules/react.md#convexprovider) being above in the React component tree.

### Method
N/A (React Hook)

### Endpoint
N/A

### Parameters
#### Path Parameters
N/A

#### Query Parameters
N/A

#### Request Body
N/A

### Request Example
```javascript
const convex = useConvex();
```

### Response
#### Success Response (N/A)
- **client** ([ConvexReactClient](/api/classes/react.ConvexReactClient.md)) - The active `ConvexReactClient` object, or `undefined`.

#### Response Example
```json
{
  "type": "ConvexReactClient",
  "status": "connected",
  "id": "client_abc123"
}
```
```

--------------------------------

### GET /storage/metadata

Source: https://context7_llms

Retrieves metadata for a file stored in Convex. This function is deprecated; use `db.system.get(Id<"_storage">)` for current implementations.

```APIDOC
## GET /storage/metadata

### Description
Retrieves metadata for a file stored in Convex. **This function is deprecated; use `db.system.get(Id<"_storage">)` instead.**

### Method
GET

### Endpoint
/storage/metadata/{storageId}

### Parameters
#### Path Parameters
- **storageId** (string) - Required - The StorageId of the file. (Note: In the deprecated version, this could be a string representation of the StorageId.)

### Request Example
{}

### Response
#### Success Response (200)
- **null** (null) - If the file is not found.
- **FileMetadata** (object) - An object containing metadata for the file if found.
  - **_id** (Id<"_storage">) - The ID of the storage entry.
  - **_creationTime** (number) - Timestamp of file creation (Unix milliseconds).
  - **contentType** (string) - MIME type of the file.
  - **size** (number) - Size of the file in bytes.

#### Response Example
```json
{
  "_id": "67y3d82y2j37w8d0x221",
  "_creationTime": 1678886400000,
  "contentType": "image/jpeg",
  "size": 12345
}
```
Or
```json
null
```

```

--------------------------------

### GET ConvexClient.closed

Source: https://context7_llms

Retrieves the current closed status of the ConvexClient connection. Once true, no further callbacks will be triggered by this client.

```APIDOC
## GET ConvexClient.closed

### Description
Retrieves a boolean indicating whether the client connection is closed. Once closed, no registered callbacks will fire again.

### Method
GET (Accessor)

### Endpoint
ConvexClient.closed

### Parameters
#### Path Parameters
- No path parameters.

#### Query Parameters
- No query parameters.

#### Request Body
- No request body.

### Request Example
```javascript
// Accessing the 'closed' property
const isClosed = client.closed;
```

### Response
#### Success Response (200)
- **closed** (boolean) - `true` if the client's connection is closed, `false` otherwise.

#### Response Example
```json
true
```
```

--------------------------------

### Conditionally Start Streaming Text with React useSmoothText Hook

Source: https://context7_llms

This advanced usage of the `useSmoothText` hook allows conditional control over when text streaming begins. By setting `startStreaming: true` based on a message's status (e.g., `message.status === "streaming"`), you can ensure that text starts animating only when it is actively being streamed, providing a more precise UI behavior.

```typescript
import { useSmoothText, type UIMessage } from "@convex-dev/agent/react";

function Message({ message }: { message: UIMessage }) {
  const [visibleText] = useSmoothText(message.text, {
    startStreaming: message.status === "streaming",
  });
  return <div>{visibleText}</div>;
}
```

--------------------------------

### Deploy to Dev Convex Backend with Deploy Key

Source: https://context7_llms

Pushes code to the development Convex backend using the Convex CLI with a deploy key set as an environment variable. The --once flag runs the dev server once without watching for changes. Requires CONVEX_DEPLOY_KEY environment variable to be set from the Create deploy key API.

```bash
CONVEX_DEPLOY_KEY="YOUR_DEPLOY_KEY" npx convex dev --once
```

--------------------------------

### Display Convex Data in Vue Component (Vue/TypeScript)

Source: https://docs.convex.dev/quickstart/vue

Vue component template using `useConvexQuery` from `convex-vue` to subscribe to the `api.tasks.get` query. It displays a loading state and then lists the fetched tasks.

```vue
<script setup lang="ts">
import { useConvexQuery } from "convex-vue";
import { api } from "../convex/_generated/api";

const { data, isPending } = useConvexQuery(api.tasks.get);
</script>

<template>
  <span v-if="isPending"> Loading... </span>
  <ul v-else>
    <li v-for="todo in data">
      {{ todo.text }} {{ todo.isCompleted ? "" : "" }}
    </li>
  </ul>
</template>
```

--------------------------------

### Start Workflow from Convex Mutation

Source: https://convex.dev/components/workflow

Initiate a workflow execution from a mutation using workflow.start(), passing the workflow definition and arguments. Returns a workflowId that can be used to track the workflow's execution in the background.

```TypeScript
export const kickoffWorkflow = mutation({
  handler: async (ctx) => {
    const workflowId = await workflow.start(
      ctx,
      internal.example.exampleWorkflow,
      { name: "James" },
    );
  },
});
```

--------------------------------

### FunctionReturnType Type Definition

Source: https://docs.convex.dev/api/modules/server

Given a FunctionReference, get the return type of the function.

```APIDOC
## Type: FunctionReturnType

### Description
Given a [FunctionReference](/api/modules/server.md#functionreference), get the return type of the function.

### Type Parameters
- **FuncRef** (extends `AnyFunctionReference`) -

### Type Definition
 FunctionReturnType<`FuncRef`>: `FuncRef`\[`"_returnType"`\]
```

--------------------------------

### Create Base HTML Document Layout with Navigation (React)

Source: https://docs.convex.dev/client/tanstack/tanstack-start/clerk

The `RootDocument` component provides the foundational HTML structure for the application. It includes metadata, a navigation bar with `Link` components, integrates Clerk's `UserButton` and `SignInButton` for user management, renders children, and includes developer tools and scripts.

```tsx
function RootDocument({ children }: { children: React.ReactNode }) {
  return (
    <html>
      <head>
        <Meta />
      </head>
      <body>
        <div className="p-2 flex gap-2 text-lg">
          <Link
            to="/"
            activeProps={{
              className: 'font-bold',
            }}
            activeOptions={{ exact: true }}
          >
            Home
          </Link>{' '}
          <Link
            to="/posts"
            activeProps={{
              className: 'font-bold',
            }}
          >
            Posts
          </Link>
          <div className="ml-auto">
            <SignedIn>
              <UserButton />
            </SignedIn>
            <SignedOut>
              <SignInButton mode="modal" />
            </SignedOut>
          </div>
        </div>
        <hr />
        {children}
        <TanStackRouterDevtools position="bottom-right" />
        <Scripts />
      </body>
    </html>
  )
}
```

--------------------------------

### Run Convex tests using NPM script

Source: https://docs.convex.dev/testing/convex-test

Execute your configured Vitest tests by running the `test` NPM script. This command will start the test runner, which automatically re-runs tests when relevant files are changed, providing a fast feedback loop during development.

```bash
npm run test
```

--------------------------------

### BaseTableReader Interface - get()

Source: https://context7_llms

Database table reader interface for fetching individual documents from Convex tables by their GenericId. Returns the document or null if it no longer exists.

```APIDOC
## BaseTableReader Interface

### Description
Base interface for reading documents from Convex database tables.

### Type Parameters
- **DataModel** - Extends GenericDataModel - The data model schema
- **TableName** - Extends TableNamesInDataModel - The specific table name

### Method: get()

Fetch a single document from the table by its GenericId.

#### Method
GET (async)

#### Parameters
- **id** (GenericId<TableName>) - Required - The GenericId of the document to fetch from the database

#### Returns
- `Promise<null | DocumentByName<DataModel, TableName>>` - The document at the given GenericId, or null if it no longer exists

### Request Example
```javascript
const docId = "document_123";
const document = await tableReader.get(docId);
```

### Response
#### Success Response (200)
- **Document** (object) - The retrieved document object
- **null** - If document does not exist

#### Response Example
```javascript
{
  "_id": "document_123",
  "_creationTime": 1234567890,
  "field1": "value1",
  "field2": "value2"
}
```

#### Defined in
[server/database.ts:88](https://github.com/get-convex/convex-js/blob/main/src/server/database.ts#L88)
```

--------------------------------

### Deploy Convex Functions to Production

Source: https://docs.convex.dev/cli

Deploy Convex functions to production using CONVEX_DEPLOY_KEY or CONVEX_DEPLOYMENT environment variables to determine the target deployment. The command typechecks functions, regenerates code in convex/_generated, bundles dependencies, and pushes functions, indexes, and schema. New functions become available immediately upon successful completion.

```bash
npx convex deploy
```

--------------------------------

### GET ctx.db.get - Load Document by ID

Source: https://context7_llms

Retrieves a full document from the database by its Document ID. Used after vector search to load the complete document information for matched results.

```APIDOC
## GET ctx.db.get

### Description
Retrieves a complete document from a specified table using its Document ID. Commonly used to load document details after obtaining result IDs from vector searches.

### Method
GET (invoked as ctx.db.get within queries or actions)

### Endpoint
ctx.db.get(tableName, documentId)

### Parameters
#### Required Parameters
- **tableName** (string) - Required - The name of the table containing the document
- **documentId** (DocumentID) - Required - The Document ID of the document to retrieve

### Request Example
```
const doc = await ctx.db.get("foods", "kg23d8f9d2");
```

### Response
#### Success Response (200)
Returns the complete document object with all fields, or null if document not found

#### Response Example
```
{
  "_id": "kg23d8f9d2",
  "_creationTime": 1234567890,
  "name": "Coq au Vin",
  "cuisine": "French",
  "description": "Classic French braised chicken dish",
  "embedding": [0.1, 0.2, 0.3, 0.4]
}
```

### Error Handling
- Returns null if the document does not exist
- Document ID must be valid and correspond to a document in the specified table
```

--------------------------------

### Get canonical URLs via Convex Deployment API

Source: https://context7_llms

Retrieves the canonical URLs configured for a specific Convex deployment. This endpoint provides details about the deployment's custom domain settings.

```HTTP
GET 
/get_canonical_urls
```

--------------------------------

### Access Environment Variables in Convex Functions

Source: https://context7_llms

Demonstrates how to access environment variables within Convex functions using process.env.KEY notation. The example constructs a Giphy API URL using the GIPHY_KEY environment variable, returning a string if set or undefined if not present.

```javascript
function giphyUrl(query) {
  return (
    "https://api.giphy.com/v1/gifs/translate?api_key=" +
    process.env.GIPHY_KEY +
    "&s=" +
    encodeURIComponent(query)
  );
}
```

--------------------------------

### Utilize Shorthand Syntax for Convex Migrations (TypeScript & Bash)

Source: https://www.convex.dev/components/migrations

These examples demonstrate how to configure and use a shorthand syntax for Convex migrations. By setting `migrationsLocationPrefix` during `Migrations` instantiation, you can refer to migrations by their short names in both CLI commands and programmatic calls for status retrieval or cancellation, improving readability and conciseness.

```typescript
export const migrations = new Migrations(components.migrations, {
  internalMigration,
  migrationsLocationPrefix: "migrations:",
});
```

```bash
npx convex run migrations:run '{fn: "myNewMutation", next: ["myNextMutation"]}'
```

```typescript
await migrations.getStatus(ctx, { migrations: ["myNewMutation"] });
```

```typescript
await migrations.cancel(ctx, "myNewMutation");
```

--------------------------------

### GET url

Source: https://docs.convex.dev/api/classes/browser.ConvexHttpClient

Retrieve the address for the current ConvexHttpClient instance. This method returns the client's URL which may be canonicalized and is useful for creating new client instances.

```APIDOC
## GET url

### Description
Return the address for this client, useful for creating a new client.

### Method
GET

### Returns
**string** - The client's URL address (may be canonicalized)

### Response Example
```
"https://api.example.convex.cloud"
```

### Notes
Not guaranteed to match the address with which this client was constructed: it may be canonicalized.
```

--------------------------------

### GET /api/streaming_import/primary_key_indexes_ready

Source: https://docs.convex.dev/streaming-import-api

Checks if the primary key indexes on specified tables are ready. This is useful after creating new tables or adding indexes to existing ones.

```APIDOC
## GET /api/streaming_import/primary_key_indexes_ready

### Description
Checks if the primary key indexes on specified tables are ready. Returns true if all specified indexes are ready, false otherwise.

### Method
GET

### Endpoint
`/api/streaming_import/primary_key_indexes_ready`

### Query Parameters
- **tableNames** (array of strings) - Required - A list of table names for which to check index readiness.

### Response
#### Success Response (200)
- **indexesReady** (boolean) - True if all specified primary key indexes are ready, false otherwise.

#### Response Example
```json
{
  "indexesReady": true
}
```
```

--------------------------------

### GET /query/watchQuery

Source: https://docs.convex.dev/api/classes/react.ConvexReactClient

Constructs a new Watch on a Convex query function for reactive query monitoring. This method is typically not called directly by application code; use the useQuery hook instead.

```APIDOC
## GET Watch Query

### Description
Creates a Watch instance for a Convex query function to enable reactive query monitoring and updates.

### Method
Method call

### Syntax
```
const watch = client.watchQuery(query, ...argsAndOptions)
```

### Type Parameters
- **Query** - A FunctionReference extending type 'query' from the server module

### Parameters
- **query** (FunctionReference<'query'>) - The query function to watch
- **argsAndOptions** (variadic) - Arguments and options to pass to the query

### Returns
- **Watch** - A Watch instance of type FunctionReturnType<Query>

### Notes
Most application code should use the useQuery hook instead of calling this method directly. The act of creating a watch is stateless and performs no immediate action.
```

--------------------------------

### GET /token_details

Source: https://context7_llms

Retrieve authentication token details including team ID. Especially useful after OAuth flow to obtain the team ID required for most endpoints.

```APIDOC
## GET /token_details

### Description
Returns the team ID for team tokens. Especially useful after receiving a team token from an OAuth flow since most endpoints require team ID.

### Method
GET

### Endpoint
/token_details

### Authentication
Bearer Token (obtained through Convex OAuth application)

### Response
#### Success Response (200)
- **team_id** (string) - The team ID associated with the authentication token

### Error Responses
- **401** - Unauthorized - Invalid or missing authentication token
- **403** - Forbidden - Insufficient permissions
```

--------------------------------

### Retrieving All Messages in a Channel Ordered by User using `by_channel_user` Index (JavaScript)

Source: https://docs.convex.dev/database/reading-data/indexes

This example shows how to fetch all messages belonging to a specified channel, with the results automatically ordered by the `user` field, then by `_creationTime`. It uses the `by_channel_user` index and an `eq` expression to filter by the `channel` field.

```javascript
const messages = await ctx.db
  .query("messages")
  .withIndex("by_channel_user", (q) => q.eq("channel", channel))
  .collect();
```

--------------------------------

### Initialize New Convex Project with WorkOS AuthKit using npm

Source: https://docs.convex.dev/auth/authkit

This command sequence quickly scaffolds a new Convex project, pre-configured with WorkOS AuthKit integration. It uses `npm create convex` to generate the project from a template, navigates into the new directory, and starts the development server, prompting for WorkOS account association.

```bash
npm create convex@latest -- -t react-vite-authkit
cd my-app  # or whatever you name the directory
npm run dev
```

--------------------------------

### Retrieve all LLM threads owned by a user with Convex Agent

Source: https://context7_llms

This example shows how to query and retrieve all LLM threads linked to a specific `userId`. It uses `ctx.runQuery` to access the agent's thread listing function, allowing for optional pagination of results.

```typescript
const threads = await ctx.runQuery(
  components.agent.threads.listThreadsByUserId,
  { userId, paginationOpts: args.paginationOpts },
);
```

--------------------------------

### ConvexReactClient Constructor

Source: https://context7_llms

Initialize a new ConvexReactClient instance with a Convex deployment address and optional configuration. This is the entry point for setting up Convex in your React application.

```APIDOC
## Constructor: ConvexReactClient

### Description
Creates a new instance of ConvexReactClient for use within React applications. This client loads reactive queries and executes mutations over a WebSocket connection.

### Signature
```typescript
new ConvexReactClient(address, options?)
```

### Parameters
- **address** (string) - Required - The URL of your Convex deployment, typically provided by an environment variable (e.g., `https://small-mouse-123.convex.cloud`)
- **options** (ConvexReactClientOptions) - Optional - Configuration options for the client. See ConvexReactClientOptions for full details

### Request Example
```typescript
const client = new ConvexReactClient(
  process.env.REACT_APP_CONVEX_URL,
  {
    // optional configuration
  }
);
```

### Returns
A new ConvexReactClient instance ready for use in React applications.
```

--------------------------------

### Simplified Text Action Generation in Convex Agent

Source: https://context7_llms

Provides a utility shorthand for Step 2 of the asynchronous response generation pattern. The `agent.asTextAction()` utility eliminates boilerplate code by automatically handling action setup, streaming parameters, and message generation with sensible defaults.

```TypeScript
// Equivalent to Step 2 above.
export const generateResponseAsync = agent.asTextAction();
```

--------------------------------

### Configure WorkOS AuthKit Development Environment Variables

Source: https://context7_llms

Set up environment variables for WorkOS AuthKit development configuration in a .env.local file. Includes test API key format (sk_test_...), client ID, secure cookie password (minimum 32 characters), and localhost redirect URI for local development.

```bash
WORKOS_CLIENT_ID="client_01XXXXXXXXXXXXXXXXXXXXXXXX"
WORKOS_API_KEY="sk_test_..."
WORKOS_COOKIE_PASSWORD="your_secure_password_here_must_be_at_least_32_characters_long"
NEXT_PUBLIC_WORKOS_REDIRECT_URI="http://localhost:3000/callback"
```

--------------------------------

### Back-Reference Query with Index

Source: https://stack.convex.dev/functional-relationships-helpers

Query a document that references the current document using an index on the foreign key. Example shows looking up an author profile from a user ID.

```typescript
const author = await db
  .query("authorProfiles")
  .withIndex("userId", q => q.eq("userId", user._id))
  .unique();
```

--------------------------------

### GET /client.url - URL Accessor

Source: https://context7_llms

Retrieves the address of the current Convex client. The returned address may be canonicalized and may not exactly match the address used during construction. This is useful when creating new client instances.

```APIDOC
## Accessor: url

### Description
Returns the address for the current client instance. The returned URL may be canonicalized and might differ from the original address provided during construction.

### Method
GET

### Endpoint
client.url

### Response
#### Success Response
- **url** (string) - The canonicalized address of the Convex deployment

### Response Example
```typescript
const address = client.url;
// Returns: "https://small-mouse-123.convex.cloud"
```
```

--------------------------------

### Configure Convex React Client with Auth0 Provider

Source: https://context7_llms

Initialize ConvexReactClient with environment variables and wrap the application with Auth0Provider and ConvexProviderWithAuth0. This enables Auth0 authentication integration with Convex backend. Requires VITE_CONVEX_URL, VITE_AUTH0_DOMAIN, and VITE_AUTH0_CLIENT_ID environment variables.

```typescript
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import "./index.css";
import { ConvexReactClient } from "convex/react";
import { ConvexProviderWithAuth0 } from "convex/react-auth0";
import { Auth0Provider } from "@auth0/auth0-react";

const convex = new ConvexReactClient(import.meta.env.VITE_CONVEX_URL as string);

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <Auth0Provider
      domain={import.meta.env.VITE_AUTH0_DOMAIN}
      clientId={import.meta.env.VITE_AUTH0_CLIENT_ID}
      authorizationParams={{
        redirect_uri: window.location.origin,
      }}
      useRefreshTokens={true}
      cacheLocation="localstorage"
    >
      <ConvexProviderWithAuth0 client={convex}>
        <App />
      </ConvexProviderWithAuth0>
    </Auth0Provider>
  </React.StrictMode>,
);
```

--------------------------------

### Get Auth Token from Auth0 for Convex Authentication

Source: https://context7_llms

Demonstrates retrieving an ID token from Auth0 session to use for authenticated Convex requests. Requires @auth0/nextjs-auth0 v4.3 or later.

```typescript
// You'll need v4.3 or later of @auth0/nextjs-auth0
import { getSession } from '@auth0/nextjs-auth0';

export async function getAuthToken() {
  const session = await getSession();
  const idToken = session.tokenSet.idToken;
  return idToken;
}
```

--------------------------------

### GET backendUrl

Source: https://docs.convex.dev/api/classes/browser.ConvexHttpClient

Obtain the ConvexHttpClient's URL to its backend including the API version. This method is deprecated in favor of the url method which returns the URL without the /api suffix.

```APIDOC
## GET backendUrl

### Description
Obtain the ConvexHttpClient's URL to its backend.

### Method
GET

### Returns
**string** - The URL to the Convex backend, including the client's API version.

### Response Example
```
"https://api.example.convex.cloud/api"
```

### Deprecation
Use url, which returns the url without /api at the end.
```

--------------------------------

### Arithmetic Operations

Source: https://docs.convex.dev/api/interfaces/server.FilterBuilder

This section covers arithmetic operations available in the filter builder, starting with addition.

```APIDOC
## add

### Description
Adds the left operand to the right operand.

### Method
N/A (Function)

### Endpoint
N/A (Function)

### Parameters
#### Path Parameters
None

#### Query Parameters
None

#### Request Body
None

### Request Example
```javascript
add(field1, 5)
```

### Response
#### Success Response (200)
N/A (Function returns an Expression)

#### Response Example
```json
{
  "expression": "add(field1, 5)"
}
```
```

--------------------------------

### Create Sign-Up Route in Next.js

Source: https://docs.convex.dev/auth/authkit

Route handler that generates and redirects to the WorkOS sign-up URL. Uses getSignUpUrl() to fetch the authorization endpoint for new user registration. Completes the authentication flow setup with sign-up capability.

```typescript
import { redirect } from 'next/navigation';
import { getSignUpUrl } from '@workos-inc/authkit-nextjs';

export async function GET() {
  const authorizationUrl = await getSignUpUrl();
  return redirect(authorizationUrl);
}
```

--------------------------------

### Configure Convex Node.js to use all external packages

Source: https://context7_llms

This `convex.json` configuration tells Convex to treat all dependencies declared in your `package.json` as external packages for Node.js actions. Convex will install these packages from npm the first time they are used, caching them for subsequent pushes.

```json
{
  "node": {
    "externalPackages": ["*"]
  }
}
```

--------------------------------

### GET /oauth/authorize/project

Source: https://context7_llms

Redirects the user to Convex's authorization page to grant your application access to a specific Convex project. This initiates the OAuth 2.0 Authorization Code Grant flow for project-scoped tokens.

```APIDOC
## GET /oauth/authorize/project

### Description
Redirects the user to Convex's authorization page to grant your application access to a specific Convex project. This initiates the OAuth 2.0 Authorization Code Grant flow for project-scoped tokens.

### Method
GET

### Endpoint
`https://dashboard.convex.dev/oauth/authorize/project`

### Parameters
#### Path Parameters
- **scope** (string) - Required - Must be "project".

#### Query Parameters
- **client_id** (string) - Required - Your application's client ID as assigned by Convex.
- **redirect_uri** (string) - Required - A URL on your application's domain. The user will be redirected back to this URL after authorizing.
- **response_type** (string) - Required - Must be "code".
- **state** (string) - Optional - An arbitrary string used by your application to maintain state.

### Request Example
`https://dashboard.convex.dev/oauth/authorize/project?client_id=YOUR_CLIENT_ID&redirect_uri=https%3A%2F%2Fyourapp.example.com%2Fcb&response_type=code&state=abc`

### Response
#### Success Response (302 Redirect)
Upon successful authorization, the user's browser is redirected to the `redirect_uri` with the authorization `code` and `state` parameters.

#### Response Example
`https://yourapp.example.com/cb?code=0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d&state=abc`
```

--------------------------------

### POST /teams/:team_id/create_project

Source: https://context7_llms

Create a new project on a team and provision a dev or prod deployment. Returns the newly created project details.

```APIDOC
## POST /teams/:team_id/create_project

### Description
Create a new project on a team and provision a dev or prod deployment.

### Method
POST

### Endpoint
/teams/:team_id/create_project

### Authentication
Bearer Token (obtained through Convex OAuth application)

### Path Parameters
- **team_id** (string) - Required - The ID of the team where the project will be created

### Response
#### Success Response (200)
- **project_id** (string) - The ID of the newly created project
- **deployment** (object) - The provisioned deployment details

### Error Responses
- **400** - Bad Request - Invalid team ID or request parameters
- **401** - Unauthorized - Invalid or missing authentication token
- **403** - Forbidden - Insufficient permissions for this team
```

--------------------------------

### Fetch and Mutate Data with Convex React Hooks

Source: https://context7_llms

This example illustrates the use of `useQuery` for fetching data and `useMutation` for performing data modifications within a React component. It imports `api` from the generated Convex API to reference backend functions, allowing for seamless interaction with Convex functions like `getCounter` and `incrementCounter`.

```tsx
import { useQuery, useMutation } from "convex/react";
import { api } from "../convex/_generated/api";

function App() {
  const counter = useQuery(api.getCounter.default);
  const increment = useMutation(api.incrementCounter.default);
  // Your component here!
}
```

--------------------------------

### Instantiate ConvexClient in Kotlin for Android

Source: https://context7_llms

This Kotlin code demonstrates the basic instantiation of the `ConvexClient`, requiring your Convex backend deployment URL. A single `ConvexClient` instance should be maintained throughout your application's lifetime to manage the connection to the Convex backend efficiently.

```Kotlin
package com.example.convexapp

import dev.convex.android.ConvexClient

val convex = ConvexClient("https://<your domain here>.convex.cloud")
```

--------------------------------

### StorageReader.getMetadata()

Source: https://context7_llms

Get metadata for a file by its storage ID. This function is deprecated and `db.system.get(Id<"_storage">)` should be used instead. Returns FileMetadata object if found or null if not found.

```APIDOC
## StorageReader.getMetadata()

### Description
Get metadata for a file. This function is deprecated, use `db.system.get(Id<"_storage">)` instead.

### Method
Async Function

### Signature
```typescript
getMetadata(storageId: GenericId<"_storage">): Promise<null | FileMetadata>
```

### Parameters
#### Required Parameters
- **storageId** (GenericId<"_storage">) - The Id<"_storage"> of the file.

### Returns
- **Promise<null | FileMetadata>** - A FileMetadata object if found or `null` if not found.

### Deprecation Notice
 **Deprecated** - This function is deprecated. Use `db.system.get(Id<"_storage">)` instead.

### Defined in
server/storage.ts:75
```

--------------------------------

### Create Convex Query Function for Tasks

Source: https://docs.convex.dev/quickstart/nextjs

Define a Convex query function that retrieves all tasks from the database. The exported query function creates an API endpoint named 'api.tasks.get' that can be called from client components to fetch task data.

```typescript
import { query } from "./_generated/server";

export const get = query({
  args: {},
  handler: async (ctx) => {
    return await ctx.db.query("tasks").collect();
  },
});
```

--------------------------------

### Development Environment Variables for Auth0

Source: https://docs.convex.dev/auth/auth0

Configure Auth0 credentials for local development using .env.local or .env file. Variables VITE_AUTH0_DOMAIN and VITE_AUTH0_CLIENT_ID should reference your Auth0 application settings. File format depends on build tool (Vite, Next.js, etc.).

```plaintext
VITE_AUTH0_DOMAIN="your-domain.us.auth0.com"
VITE_AUTH0_CLIENT_ID="yourclientid"
```

--------------------------------

### GET Threads by User ID

Source: https://context7_llms

Retrieves all threads owned by a specific user. Supports pagination options for retrieving results in batches.

```APIDOC
## GET Threads by User ID

### Description
Retrieves all threads owned by a specific user with pagination support.

### Method
Query

### Function
`components.agent.threads.listThreadsByUserId`

### Parameters
#### Query Parameters
- **userId** (string) - Required - The ID of the user
- **paginationOpts** (Object) - Optional - Pagination options

### Request Example
```javascript
const threads = await ctx.runQuery(
  components.agent.threads.listThreadsByUserId,
  { userId, paginationOpts: args.paginationOpts }
);
```

### Response
#### Success Response (200)
- **threads** (Array) - Array of thread objects
  - **threadId** (string) - Thread identifier
  - **userId** (string) - Associated user ID
  - **title** (string) - Thread title
  - **summary** (string) - Thread summary
  - **metadata** (Object) - Additional thread metadata

### Notes
- Returns paginated results
- Includes all thread metadata
- Useful for displaying user's conversation history
```

--------------------------------

### Run Android Application in IDE

Source: https://context7_llms

Instructions to launch the Android application from an Integrated Development Environment (IDE), typically Android Studio. This action compiles and deploys the app to a connected device or emulator.

```IDE Command
From the IDE menu choose "Run" > "Run 'app'"
```

--------------------------------

### Explicitly specify Convex Node.js external packages

Source: https://context7_llms

This `convex.json` configuration explicitly lists specific packages, such as `aws-sdk` and `sharp`, to be treated as external dependencies for Node.js actions. Convex will install only these specified packages from npm.

```json
{
  "node": {
    "externalPackages": ["aws-sdk", "sharp"]
  }
}
```

--------------------------------

### GET /client.watchQuery - Watch Query

Source: https://context7_llms

Construct a new Watch on a Convex query function to monitor reactive query results. Most application code should use the useQuery hook instead of calling this method directly.

```APIDOC
## Method: watchQuery

### Description
Constructs a new Watch on a Convex query function for monitoring reactive results. This is a lower-level method; most applications should use the useQuery hook instead. The act of creating a watch is stateless and does nothing until subscribed to.

### Method
GET

### Endpoint
client.watchQuery<Query>(query, ...argsAndOptions)

### Type Parameters
- **Query** - Must extend FunctionReference<"query"> - The query function type to watch

### Parameters
#### Request Parameters
- **query** (Query) - Required - A reference to the Convex query function
- **argsAndOptions** (variable) - Optional - Arguments and options for the query

### Response
#### Success Response
- **Watch** (Watch<FunctionReturnType<Query>>) - A Watch instance monitoring the query

### Response Example
```typescript
const watch = client.watchQuery(api.messages.list, { roomId: "123" });
// Returns a Watch instance that can be subscribed to
```
```

--------------------------------

### GET File Blob

Source: https://docs.convex.dev/api/interfaces/server.StorageActionWriter

Retrieve a Blob containing the file associated with the provided Id<"_storage">, or null if the file does not exist.

```APIDOC
## GET File Blob

### Description
Retrieve the actual file content as a Blob from Convex storage using its StorageId.

### Method
GET

### Endpoint
storage.get(storageId)

### Parameters
#### Path Parameters
- **storageId** (GenericId<"_storage">) - Required - The Id<"_storage"> of the file to retrieve

### Returns
**Promise<null | Blob>**
- A Blob containing the file content if found
- null if there is no file associated with the provided StorageId

### Response Example
```
Blob object with file content
```

### Notes
- Use this method to retrieve actual file content for processing or download
- Returns null if the file does not exist or has been deleted
```

--------------------------------

### Configure Convex Agent with Language Model and Tools

Source: https://context7_llms

Initializes a Convex agent with language model configuration, embedding model for vector search, custom tools (both Convex and AI SDK), and various handlers for usage tracking, context management, and request/response logging. The agent uses shared defaults and supports tool call step limiting.

```TypeScript
import { tool, stepCountIs } from "ai";
import { openai } from "@ai-sdk/openai";
import { z } from "zod/v3";
import { Agent, createTool, type Config } from "@convex-dev/agent";
import { components } from "./_generated/api";

const sharedDefaults = {
  languageModel: openai.chat("gpt-4o-mini"),
  textEmbeddingModel: openai.embedding("text-embedding-3-small"),
  contextOptions,
  storageOptions,
  usageHandler: async (ctx, args) => {
    const { usage, model, provider, agentName, threadId, userId } = args;
  },
  contextHandler: async (ctx, args) => {
    return [...customMessages, args.allMessages];
  },
  rawResponseHandler: async (ctx, args) => {
    const { request, response, agentName, threadId, userId } = args;
  },
  callSettings: { maxRetries: 3, temperature: 1.0 }
} satisfies Config;

const supportAgent = new Agent(components.agent, {
  instructions: "You are a helpful assistant.",
  tools: {
    myConvexTool: createTool({
      description: "My Convex tool",
      args: z.object({...}),
      handler: async (ctx, args): Promise<string> => {
        return "Hello, world!";
      }
    }),
    myTool: tool({ description, parameters, execute: () => {} })
  },
  stopWhen: stepCountIs(5),
  ...sharedDefaults
});
```

--------------------------------

### Query Data with useSuspenseQuery in TanStack

Source: https://context7_llms

Use useSuspenseQuery with convexQuery to fetch and render Convex data in TanStack Start. This hook simplifies server-side rendering of Convex queries by combining TanStack Query's Suspense support with Convex's real-time capabilities.

```javascript
const { data } = useSuspenseQuery(convexQuery(api.messages.list, {}));
```

--------------------------------

### Setup ConvexProvider for React Context

Source: https://context7_llms

Wrap your React application with ConvexProvider to make the Convex client available throughout your component tree via React Context. This enables all child components to access Convex hooks and functionality without prop drilling.

```TypeScript
import { ConvexProvider } from "convex/react";

<ConvexProvider client={convex}>
  <App />
</ConvexProvider>
```

--------------------------------

### Get specific log stream config via Convex Deployment API

Source: https://context7_llms

Fetches the configuration details for a particular log stream using its unique identifier. This allows inspection of how a specific log stream is set up within a Convex deployment.

```HTTP
GET 
/get_log_stream/:id
```

--------------------------------

### Define Database Index in Convex Schema

Source: https://docs.convex.dev/using/database-queries

Demonstrates how to define an index on a database table in the Convex schema file. This example creates a by_channel index on the messages table to optimize queries filtering by channel ID.

```typescript
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

// Define a messages table with an index.
export default defineSchema({
  messages: defineTable({
    channel: v.id("channels"),
    body: v.string(),
    user: v.id("users"),
  }).index("by\u005fchannel", ["channel"]),
});
```

--------------------------------

### Deploy to Production Convex Backend with Deploy Key

Source: https://context7_llms

Deploys code to the production Convex backend using the Convex CLI with a deploy key set as an environment variable. This command performs a full deployment to production and requires CONVEX_DEPLOY_KEY to be set from the Create deploy key API.

```bash
CONVEX_DEPLOY_KEY="YOUR_DEPLOY_KEY" npx convex deploy
```

--------------------------------

### GET Table Writer

Source: https://context7_llms

Scopes the database writer to a specific table, returning a BaseTableWriter instance for performing read and write operations on that table.

```APIDOC
## GET Table Writer

### Description
Scope the database writer to a specific table and return a table-specific writer interface.

### Method
GET

### Parameters
#### Type Parameters
- **TableName** (extends string) - Required - The name of the table to scope to.

#### Parameters
- **tableName** (TableName) - Required - The name of the table to access.

### Returns
- **BaseTableWriter<DataModel, TableName>** - A table-scoped writer interface for the specified table.

### Example
```typescript
const tableWriter = db.table("users");
```

### Defined in
server/database.ts:274
```

--------------------------------

### Get Client URL Address

Source: https://context7_llms

Retrieves the canonicalized address for the current client instance. Useful for creating new clients with the same endpoint. Returns the URL as a string that may differ from the original construction address.

```typescript
get url(): string
```

--------------------------------

### Query Convex Table with Index and Client-Side Filter

Source: https://docs.convex.dev/database/indexes/indexes-and-query-perf

This JavaScript example illustrates combining an indexed query with an additional client-side filter. It first uses the 'by_author' index to efficiently find all books by 'Isaac Asimov', then applies a `filter` to narrow down the results to the book titled 'Foundation'. The `.unique()` method is used to assert that only one result is expected.

```javascript
const foundation = await ctx.db
  .query("books")
  .withIndex("by_author", (q) => q.eq("author", "Isaac Asimov"))
  .filter((q) => q.eq(q.field("title"), "Foundation"))
  .unique();
```

--------------------------------

### GET validator Property

Source: https://context7_llms

Accesses the validator property of a TableDefinition instance. This property contains the DocumentType validator that validates documents stored in the table.

```APIDOC
## Property: validator

### Description
Returns the document validator for this table definition.

### Property
- **validator**: `DocumentType`

### Returns
The validator instance used to validate documents in this table.

### Response Example
```
const tableValidator = tableDefinition.validator;
// validator contains the Validator<any, any, any> for document validation
```

### Defined In
[server/schema.ts:199](https://github.com/get-convex/convex-js/blob/main/src/server/schema.ts#L199)
```

--------------------------------

### Use Untyped anyApi with Convex Client (TypeScript)

Source: https://context7_llms

This example demonstrates how to use the untyped `anyApi` object when your Convex function source code is not co-located with your client. It allows the `ConvexClient` to interact with Convex functions for subscriptions and mutations without relying on the generated `api` object, providing flexibility for monorepos or distributed projects.

```typescript
import { ConvexClient } from "convex/browser";
import { anyApi } from "convex/server";

const CONVEX_URL = "http://happy-otter-123";
const client = new ConvexClient(CONVEX_URL);
client.onUpdate(anyApi.messages.list, {}, (messages) =>
  console.log(messages.map((msg) => msg.body)),
);
setInterval(
  () =>
    client.mutation(anyApi.messages.send, {
      body: `hello at ${new Date()}`,
      author: "me",
    }),
  5000,
);
```

--------------------------------

### queryJournal - Get Query Journal

Source: https://context7_llms

Retrieve the current QueryJournal for a specific query function. Returns undefined if no result has been received yet for the query.

```APIDOC
## queryJournal()

### Description
Retrieve the current QueryJournal for a query function. The QueryJournal contains metadata and history about the query execution. Returns `undefined` if no result has been received for this query yet.

### Method
Function call

### Signature
```
queryJournal(name: string, args?: Record<string, Value>): undefined | QueryJournal
```

### Parameters
#### Required Parameters
- **name** (string) - The name of the query.

#### Optional Parameters
- **args** (Record<string, Value>) - The arguments object for the query.

### Returns
**undefined | QueryJournal** - The query's QueryJournal containing execution metadata, or `undefined` if no result has been received.

### Source
Defined in: browser/sync/client.ts:777
```

--------------------------------

### Create LLM thread with custom metadata using Convex Agent

Source: https://context7_llms

This example shows how to create an LLM thread and associate it with a specific user and provide additional descriptive metadata like title and summary. This helps organize threads in the Playground and can be used for contextual information.

```typescript
const userId = await getAuthUserId(ctx);
const threadId = await createThread(ctx, components.agent, {
  userId,
  title: "My thread",
  summary: "This is a summary of the thread",
});
```

--------------------------------

### Initialize WorkflowManager in convex/index.ts

Source: https://convex.dev/components/workflow

Create and export a WorkflowManager instance that points to the installed workflow component. This manager is used to define and manage all workflows in your application.

```typescript
// convex/index.ts
import { WorkflowManager } from "@convex-dev/workflow";
import { components } from "./\u005fgenerated/api";

export const workflow = new WorkflowManager(components.workflow);
```

--------------------------------

### Wrap React App with ConvexProvider

Source: https://context7_llms

Make the initialized `ConvexReactClient` available throughout your React component tree by wrapping your application's root component with `ConvexProvider`. This setup allows all child components to utilize Convex hooks for data interaction.

```javascript
reactDOMRoot.render(
  <React.StrictMode>
    <ConvexProvider client={convex}>
      <App />
    </ConvexProvider>
  </React.StrictMode>,
);
```

--------------------------------

### Implement Secure Access Control for Convex Mutations (TypeScript)

Source: https://context7_llms

This example showcases various methods for implementing access control in Convex mutation functions. It highlights common pitfalls like lacking checks entirely or relying on spoofable arguments (e.g., 'email'). The recommended approach involves using `ctx.auth.getUserIdentity()` to securely verify the user's identity before performing sensitive operations.

```typescript
//  -- no checks! anyone can update any team if they get the ID
export const updateTeam = mutation({
  args: {
    id: v.id("teams"),
    update: v.object({
      name: v.optional(v.string()),
      owner: v.optional(v.id("users")),
    }),
  },
  handler: async (ctx, { id, update }) => {
    await ctx.db.patch("teams", id, update);
  },
});
```

```typescript
//  -- checks access, but uses `email` which could be spoofed
export const updateTeam = mutation({
  args: {
    id: v.id("teams"),
    update: v.object({
      name: v.optional(v.string()),
      owner: v.optional(v.id("users")),
    }),
    email: v.string(),
  },
  handler: async (ctx, { id, update, email }) => {
    const teamMembers = /* load team members */
    if (!teamMembers.some((m) => m.email === email)) {
      throw new Error("Unauthorized");
    }
    await ctx.db.patch("teams", id, update);
  },
});
```

```typescript
//  -- checks access, and uses `ctx.auth`, which cannot be spoofed
export const updateTeam = mutation({
  args: {
    id: v.id("teams"),
    update: v.object({
      name: v.optional(v.string()),
      owner: v.optional(v.id("users")),
    }),
  },
  handler: async (ctx, { id, update }) => {
    const user = await ctx.auth.getUserIdentity();
    if (user === null) {
      throw new Error("Unauthorized");
    }
    const isTeamMember = /* check if user is a member of the team */
    if (!isTeamMember) {
      throw new Error("Unauthorized");
    }
    await ctx.db.patch("teams", id, update);
  },
});
```

--------------------------------

### Configure Test Entrypoint Export in package.json

Source: https://context7_llms

Configures the package.json exports field to expose the test helper as a subpath export. This allows consumers to import the test helper using @your/package/test, making it convenient to register the component in their test setup without accessing internal file paths.

```JSON
{
  "...": "...",
  "exports": {
    "...": "...",
    "./test": "./src/test.ts",
    "...": "..."
  }
}
```

--------------------------------

### Validate Convex Migration with Dry Run (CLI)

Source: https://www.convex.dev/components/migrations

This command-line interface (CLI) example demonstrates how to perform a dry run of a Convex migration. The `dryRun: true` option allows validation of a batch migration without making irreversible changes to the data, ensuring the migration logic is sound before full execution.

```bash
npx convex run migrations:runIt '{dryRun: true}'
```

--------------------------------

### Connect Node.js Script to Convex Backend

Source: https://context7_llms

Create a Node.js script (`script.js`) that initializes a `ConvexHttpClient` using the `CONVEX_URL` from `.env.local`. It then calls the `api.tasks.get` Convex query and logs the returned data to the console.

```javascript
import { ConvexHttpClient } from "convex/browser";
import { api } from "./convex/_generated/api.js";
import * as dotenv from "dotenv";
dotenv.config({ path: ".env.local" });

const client = new ConvexHttpClient(process.env["CONVEX_URL"]);

client.query(api.tasks.get).then(console.log);
```

--------------------------------

### Store Metadata for Human Agent Messages (TypeScript)

Source: https://context7_llms

This example shows how to attach additional metadata to a message saved from a human agent. It extends the `saveMessage` call with a `metadata` field, including `provider` and `providerMetadata` for detailed human agent information.

```typescript
await saveMessage(ctx, components.agent, {
  threadId,
  agentName: "Alex",
  message: { role: "assistant", content: "The human reply" },
  metadata: {
    provider: "human",
    providerMetadata: {
      human: {
        /* ... */
      }
    }
  }
});
```

--------------------------------

### Efficient Querying with a Compound Index (Convex)

Source: https://context7_llms

This JavaScript example demonstrates the power of a compound index. It uses the `by_author_title` index to directly query for a specific book by both author ('Isaac Asimov') and title ('Foundation'). This significantly reduces the scanned index range, making the query extremely efficient as it targets a single document.

```javascript
const foundation = await ctx.db
  .query("books")
  .withIndex("by_author_title", (q) =>
    q.eq("author", "Isaac Asimov").eq("title", "Foundation"),
  )
  .unique();
```

--------------------------------

### GET searchOtherThreads Configuration

Source: https://context7_llms

Enable searching across all threads belonging to a user by setting searchOtherThreads to true in context options. Uses hybrid text and vector search to find relevant messages across multiple conversations.

```APIDOC
## GET searchOtherThreads Configuration

### Description
Configure the agent to search across all threads belonging to a specified user by enabling the searchOtherThreads option. This enables multi-conversation context using hybrid text and vector search, useful for having multiple conversations that the Agent can reference.

### Method
GET

### Endpoint
contextOptions.searchOtherThreads

### Parameters
#### Query Parameters
- **searchOtherThreads** (boolean) - Optional - Set to true to search across all threads belonging to userId
- **userId** (string) - Required when searchOtherThreads is true - The user ID whose threads to search across

### Configuration Example
```javascript
const contextOptions = {
  searchOtherThreads: true,
  userId: "user_456"
};

const { messages } = await fetchContextWithPrompt(ctx, components.agent, {
  prompt: "What did we discuss before?",
  userId: "user_456",
  threadId: "thread_789",
  contextOptions: contextOptions
});
```

### Response
#### Success Response (200)
- **messages** (MessageDoc[]) - Array of context messages from all user's threads matching search criteria using hybrid text and vector search

#### Response Example
```json
{
  "messages": [
    {
      "_id": "msg_001",
      "threadId": "thread_789",
      "role": "user",
      "content": "What is the weather?"
    },
    {
      "_id": "msg_002",
      "threadId": "thread_456",
      "role": "user",
      "content": "Tell me about climate patterns."
    }
  ]
}
```
```

--------------------------------

### Convex HTTP and Subscription Clients in Bun

Source: https://docs.convex.dev/client/javascript/bun

Demonstrates the usage of ConvexHttpClient for point-in-time queries and ConvexClient for subscriptions within a Bun environment. It requires the Convex URL to be set as an environment variable.

```typescript
import { ConvexHttpClient, ConvexClient } from "convex/browser";
import { api } from "./convex/_generated/api.js";

// HTTP client
const httpClient = new ConvexHttpClient(process.env.CONVEX_URL);
httpClient.query(api.messages.list).then((messages) => {
  console.log(messages);
});

// Subscription client
const client = new ConvexClient(process.env.CONVEX_URL);
const unsubscribe = client.onUpdate(api.messages.list, {}, (messages) =>
  console.log(messages),
);
await Bun.sleep(1000);
client.mutate(api.messages.send, {}, { body: "hello!", author: "me" });
await Bun.sleep(1000);

```

--------------------------------

### Get Connection State

Source: https://docs.convex.dev/api/classes/browser.ConvexClient

Retrieve the current connection state between the client and Convex backend. This method provides information about the client's connectivity status without requiring callbacks or subscriptions.

```APIDOC
## GET Connection State

### Description
Retrieve the current ConnectionState between the client and the Convex backend.

### Method
Function call

### Signature
```
connectionState(): ConnectionState
```

### Parameters
None

### Returns
- **Type**: `ConnectionState`
- **Description**: The ConnectionState object representing the current connection status with the Convex backend

### Source
Defined in browser/simple_client.ts:553
```

--------------------------------

### TypeScript: Example Circular Import in `convex/validators.ts`

Source: https://context7_llms

Illustrates a file (`validators.ts`) importing from `functions.ts` while defining a validator (`myValidator`) which could be involved in a circular dependency. It uses `v.object` from `convex/values` to define the schema.

```ts
import { v } from "convex/values";
import { someUtility } from "./functions";

export const myValidator = v.object({
  name: v.string(),
});

// Uses someUtility somewhere...
```

--------------------------------

### Configure Convex App with Agent Component

Source: https://docs.convex.dev/agents/getting-started

Configures the Convex application to use the agent component by importing and using it in `convex.config.ts`. This step is necessary after installing the package and before generating component code.

```typescript
// convex/convex.config.ts
import { defineApp } from "convex/server";
import agent from "@convex-dev/agent/convex.config";

const app = defineApp();
app.use(agent);

export default app;
```

--------------------------------

### Manage User Sessions and Context with Convex customMutation

Source: https://stack.convex.dev/custom-functions

This example illustrates how to build a `sessionMutation` helper that authenticates a user based on a `sessionId` and enriches the Convex context (`ctx`) with `user`, `session`, and a wrapped `db` object for rule-based data access. It ensures that subsequent handlers automatically receive these validated session details in their `ctx`.

```javascript
import { mutation } from "./_generated/server";
import { customMutation } from "convex-helpers/server/customFunctions";

export const sessionMutation = customMutation(mutation, {
  args: { sessionId: v.id("sessions"), someArg: v.string() },
  input: async (ctx, { sessionId, someArg }) => {
    const user = await getUser(ctx);
    if (!user) throw new Error("Authentication required");
    const session = await ctx.db.get("sessions", sessionId);
    if (!session) throw new Error("Session not found");
    const db = wrapDatabaseWriter({ user }, ctx.db, rules);
    return { ctx: { db, user, session }, args: { sessionId, someArg } };
  }
});

export const checkout = sessionMutation({
  args: {
    // Note: you can specify this as an argument if you want,
    // if you match the type. Or you can omit it. You will get it either way.
    // sessionId: v.id("sessions"),
  },
  handler: async (ctx, args) => {
    const { user, session } = ctx;
    const cart = await ctx.db.get("carts", session.cartId);
    await purchase(ctx, user, cart, args.sessionId);
  }
});
```

--------------------------------

### Configure Clerk publishable key for development in .env.local

Source: https://docs.convex.dev/auth/clerk

This snippet demonstrates setting Clerk's publishable key for development in a `.env.local` file. The `pk_test_...` key is used by frontend applications to interact with Clerk in a development environment.

```dotenv
VITE_CLERK_PUBLISHABLE_KEY="pk_test_..."
```

--------------------------------

### Configure Convex App to Use Components in TypeScript

Source: https://docs.convex.dev/components/using

This TypeScript code demonstrates how to add components to your Convex application by updating `convex/convex.config.ts`. It shows how to import a component and use the `app.use()` method to install it, including creating multiple instances with different names for isolation.

```typescript
import { defineApp } from "convex/server";
import agent from "@convex-dev/agent/convex.config.js";

const app = defineApp();

app.use(agent);
app.use(agent, { name: "agent2" });
//... Add other components here

export default app;
```

--------------------------------

### Fetch and Display Convex Data in Next.js Component (JavaScript)

Source: https://docs.convex.dev/client/nextjs/pages-router/quickstart

Utilizes the `useQuery` hook from `convex/react` to fetch data from the `api.tasks.get` Convex function and display it within a React component. It handles loading states and renders the task text.

```javascript
import { useQuery } from "convex/react";
import { api } from "../convex/_generated/api";

export default function Home() {
  const tasks = useQuery(api.tasks.get);
  return (
    <main className="flex min-h-screen flex-col items-center p-24">
      {tasks?.map(({ _id, text }) => (
        <div key={_id}>{text}</div>
      ))}
    </main>
  );
}
```

--------------------------------

### Valid Convex Document Examples

Source: https://context7_llms

Demonstrates various valid document formats in Convex, including empty objects, simple key-value pairs, nested objects, and objects with multiple fields. Documents are JSON-like structures that form the basis of data storage in Convex tables.

```json
{}
{"name": "Jamie"}
{"name": {"first": "Ari", "second": "Cole"}, "age": 60}
```

--------------------------------

### Convex addCart Mutation with Race Condition Example

Source: https://stack.convex.dev/how-convex-works

A Convex mutation function that adds items to a shopping cart and decrements inventory stock. This example demonstrates a race condition where concurrent calls can allow overselling when inventory checks are performed before writes. The function queries the cart collection using a composite index on userToken and itemId, then updates both cart and inventory atomically in theory but suffers from race conditions without proper transaction handling.

```typescript
// convex/addCart.ts
import { v } from "convex/values";
import { mutation } from "./\_generated/server";

// Moves item to the given shopping cart and decrements quantity in stock.
export default mutation({
  args: { itemId: v.id("items") },
  handler: async ({ db }, args) => {
    // Check the item exists and has sufficient stock.
    const item = await db.get("items", args.itemId);
    if (item.remaining <= 0) {
      throw new Error(`Insufficient stock of ${item.name}`);
    }
    // <=== Alice observed `item.remaining === 1`.

    // Increment the item's count in cart.
    const cartItem = await db
      .query("carts")
      .withIndex("user\_item", (q) =>
        q.eq("userToken", userToken).eq("itemId", args.itemId)
      )
      .first();
    await db.patch("carts", cartItem.\_id, { count: cartItem.count + 1 });

    // Deduct stock for item.
    await db.patch("items", args.itemId, { remaining: item.remaining - 1 });

    // <=== Bob observed `item.remaining === 1`.
    // and sets `item.remaining` to `0`.
  }
});
```

--------------------------------

### Create Next.js App with Pages Router

Source: https://context7_llms

Initialize a new Next.js project using create-next-app with the Pages Router (--no-app flag) and JavaScript. This command scaffolds a basic Next.js application ready for Convex integration.

```bash
npx create-next-app@latest my-app --no-app --js
```

--------------------------------

### Define Root Application Component with Auth Providers (React)

Source: https://docs.convex.dev/client/tanstack/tanstack-start/clerk

This `RootComponent` serves as the main entry point for the application's UI. It wraps the application with `ClerkProvider` for authentication and `ConvexProviderWithClerk` for Convex backend integration, ensuring that authentication context is available throughout the app and the `Outlet` renders nested routes.

```tsx
function RootComponent() {
  const context = useRouteContext({ from: Route.id })
  return (
    <ClerkProvider>
      <ConvexProviderWithClerk client={context.convexClient} useAuth={useAuth}>
        <RootDocument>
          <Outlet />
        </RootDocument>
      </ConvexProviderWithClerk>
    </ClerkProvider>
  )
}
```

--------------------------------

### GET Continue Thread with Thread Object

Source: https://context7_llms

Continues a thread by retrieving a thread object using agent.continueThread() from within an action. Provides convenience methods for thread-specific operations without repeating parameters.

```APIDOC
## GET Continue Thread

### Description
Continues an existing thread by creating an agent-specific thread object. Available in actions only. Provides convenience methods that are thread-specific.

### Method
Action

### Function
`agent.continueThread(ctx, { threadId })`

### Parameters
#### Path Parameters
- **threadId** (string) - Required - The ID of the thread to continue

### Request Example
```javascript
const { thread } = await agent.continueThread(ctx, { threadId });
const result = await thread.generateText({ prompt });
```

### Response
#### Success Response
- **thread** (Thread) - Thread object with convenience methods

### Thread Object Methods
- `thread.getMetadata()` - Get userId, title, summary, etc.
- `thread.updateMetadata({ patch: { title, summary, userId } })` - Update thread metadata
- `thread.generateText({ prompt, ... })` - Generate text in thread
- `thread.streamText({ prompt, ... })` - Stream text in thread
- `thread.generateObject({ prompt, ... })` - Generate object in thread
- `thread.streamObject({ prompt, ... })` - Stream object in thread

### Notes
- Simplifies calling methods by not requiring threadId parameter each time
- Available in actions only
- All methods are thread-specific convenience wrappers
```

--------------------------------

### GET File Metadata

Source: https://docs.convex.dev/api/interfaces/server.StorageActionWriter

Retrieve metadata for a file stored in Convex storage using its StorageId. Returns a FileMetadata object if the file exists, or null if not found.

```APIDOC
## GET File Metadata

### Description
Retrieve metadata information for a file stored in Convex storage by its StorageId.

### Method
GET

### Endpoint
storage.getMetadata(storageId)

### Parameters
#### Path Parameters
- **storageId** (T | GenericId<"_storage">) - Required - The StorageId of the file. Type T extends { __tableName: any } ? never : T

### Returns
**Promise<null | FileMetadata>**
- A FileMetadata object if found
- null if the file does not exist

### Response Example
```
{
  "field1": "value1",
  "field2": "value2"
}
```

### Notes
- Inherited from StorageWriter interface
- Defined in server/storage.ts:85
```

--------------------------------

### Optimistic Concurrency Control - Transaction Initialization with Begin Timestamp

Source: https://stack.convex.dev/how-convex-works

Demonstrates the first step of Convex's optimistic concurrency control implementation where a transaction is assigned a begin timestamp (16 in the example). This timestamp creates a consistent snapshot of the database for all reads during transaction execution, remaining unchanged even during concurrent writes.

```typescript
import { v } from "convex/values";
import { mutation } from "./\_generated/server";

export default mutation({
  args: { itemId: v.id("items") },
  handler: async ({ db }, args) => {
    const item = await db.get("items", args.itemId);
  }
});
```

--------------------------------

### Route HTTP Request with Convex `lookup` (TypeScript)

Source: https://context7_llms

This example demonstrates how to use `http.lookup` to find a matching HTTP action for a given path and method in a Convex application. It shows a `http.route` definition and then calls `http.lookup` with a matching path, illustrating the expected return value for logging and metrics purposes. The function returns a tuple `[handler, method, routedPath]` or `null`.

```typescript
http.route({ pathPrefix: "/profile/", method: "GET", handler: getProfile});

http.lookup("/profile/abc", "GET") // returns [getProfile, "GET", "/profile/*"]
```

--------------------------------

### Get Max Observed Timestamp - TypeScript

Source: https://docs.convex.dev/api/classes/browser.BaseConvexClient

This method retrieves the maximum observed timestamp. It returns either a Long object or undefined.

```TypeScript
/**
 *  **getMaxObservedTimestamp**(): `undefined` | `Long`
 * @returns `undefined` | `Long`
 */
```

--------------------------------

### Configure Convex and TanStack React Query Client

Source: https://docs.convex.dev/client/tanstack/tanstack-query

This setup code initializes both the `ConvexReactClient` and `QueryClient`, and then connects them using `ConvexQueryClient`. It also wraps the React application with `ConvexProvider` and `QueryClientProvider` to enable both standard Convex React hooks and TanStack Query hooks, ensuring reactive data synchronization.

```tsx
import { ConvexQueryClient } from "@convex-dev/react-query";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ConvexProvider, ConvexReactClient } from "convex/react";
import ReactDOM from "react-dom/client";
import App from "./App";
import "./index.css";

const convex = new ConvexReactClient(import.meta.env.VITE_CONVEX_URL);
const convexQueryClient = new ConvexQueryClient(convex);
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryKeyHashFn: convexQueryClient.hashFn(),
      queryFn: convexQueryClient.queryFn(),
    },
  },
});
convexQueryClient.connect(queryClient);

ReactDOM.createRoot(document.getElementById("root")!).render(
  <ConvexProvider client={convex}>
    <QueryClientProvider client={queryClient}>
      <App />
    </QueryClientProvider>
  </ConvexProvider>
);
```

--------------------------------

### GET query - Fetch Query Result Once

Source: https://context7_llms

Fetch a query result once from the server. Most application code should subscribe to queries instead using the useQuery hook for real-time updates. Returns a promise that resolves with the query's result.

```APIDOC
## GET query

### Description
Fetch a query result once from the server. This method executes the query immediately and returns a single result. For real-time updates, use the useQuery hook instead.

### Method
GET

### Endpoint
query

### Parameters
#### Function Parameters
- **query** (Query) - Required - A FunctionReference for the public query to run. Must be a valid reference to a Convex query function.
- **args** (OptionalRestArgs) - Optional - An arguments object for the query. If omitted, the arguments will be {}.

### Type Parameters
- **Query** - Extends FunctionReference<"query">. Represents a reference to a query function.

### Returns
**Promise<FunctionReturnType<Query>>** - A promise that resolves with the query's result.

### Response
#### Success Response (200)
- **result** (FunctionReturnType) - The return value of the executed query function

### Defined in
react/client.ts

### Notes
- This fetches the query result once and does not subscribe to updates
- For reactive updates, use the useQuery hook instead
- Arguments must match the query function signature
- Use this for one-time data fetches or when you don't need real-time updates
```

--------------------------------

### Capture Stack Trace for a JavaScript Object

Source: https://context7_llms

This example shows how to use the static `Error.captureStackTrace()` method to add a `.stack` property to any plain JavaScript object. When accessed, this property will provide a stack trace similar to that of a new `Error()` instance.

```javascript
const myObject = {};
Error.captureStackTrace(myObject);
myObject.stack;  // Similar to `new Error().stack`
```

--------------------------------

### Rewrite CommonJS Import for Named Exports

Source: https://docs.convex.dev/functions/bundling

This example demonstrates how to correctly import from a CommonJS module in a Node.js environment when named exports are not directly supported. It shows the transformation from a direct named import to importing the default export and then destructuring the required property.

```javascript
//  old
import { Foo } from "some-module";

//  new
import SomeModule from "some-module";
const { Foo } = SomeModule;
```

--------------------------------

### QueryResult Interface Methods

Source: https://context7_llms

Methods for accessing query results and their associated journal information in Convex React applications. Use the data() method to retrieve query results and journal() to get the current QueryJournal.

```APIDOC
## QueryResult Interface

### Description
Provides access to query results and metadata in Convex React client applications.

### Method: data()

Retrieve the result of the query.

#### Returns
- `undefined | T` - The result of the query or `undefined` if not yet available

#### Usage
```javascript
const result = queryResult.data();
```

#### Defined in
[react/client.ts:182](https://github.com/get-convex/convex-js/blob/main/src/react/client.ts#L182)

### Method: journal()

Get the current QueryJournal for this query.

#### Returns
- `undefined | QueryJournal` - The QueryJournal if a result has been received, otherwise `undefined`

#### Usage
```javascript
const journal = queryResult.journal();
```

#### Defined in
[react/client.ts:194](https://github.com/get-convex/convex-js/blob/main/src/react/client.ts#L194)
```

--------------------------------

### Define Convex Query Function (JavaScript)

Source: https://docs.convex.dev/client/nextjs/pages-router/quickstart

Defines a server-side query function in Convex using JavaScript. This function retrieves all documents from the 'tasks' table and makes them available via the `api.tasks.get` endpoint.

```javascript
import { query } from "./_generated/server";

export const get = query({
  args: {},
  handler: async (ctx) => {
    return await ctx.db.query("tasks").collect();
  },
});
```

--------------------------------

### Define Convex Query Function (TypeScript)

Source: https://docs.convex.dev/quickstart/svelte

Creates a Convex query function in `src/convex/tasks.ts` to fetch tasks from the database. It maps over the collected tasks, adding an `assigner` field, and is exposed as `api.tasks.get`.

```typescript
import { query } from "./_generated/server";

export const get = query({
  args: {},
  handler: async (ctx) => {
    const tasks = await ctx.db.query("tasks").collect();
    return tasks.map((task) => ({ ...task, assigner: "tom" }));
  },
});
```

--------------------------------

### GET /get_log_stream/:id

Source: https://context7_llms

Retrieves the configuration for a specific log stream by its ID. Use this endpoint to fetch detailed information about a particular log stream in your deployment.

```APIDOC
## GET /get_log_stream/:id

### Description
Get the config for a specific log stream by id.

### Method
GET

### Endpoint
/get_log_stream/:id

### Path Parameters
- **id** (string) - Required - The unique identifier of the log stream

### Authorization
- Required: Authorization header with Convex deployment key or access token
- Format: `Authorization: Convex {token}`

### Response
#### Success Response (200)
- Returns the configuration object for the specified log stream

### Example Request
```
GET /get_log_stream/stream-123
Headers:
  Authorization: Convex ey...0=
```
```

--------------------------------

### useConvexAuth Hook

Source: https://context7_llms

Get the Convex authentication state within a React component. This hook relies on a `ConvexProviderWithAuth` component being present higher in the React component tree.

```APIDOC
## useConvexAuth Hook

### Description
Get the [ConvexAuthState](/api/modules/react.md#convexauthstate) within a React component.
This relies on a Convex auth integration provider being above in the React component tree.

### Hook Signature
`useConvexAuth(): Object`

### Returns
#### Authentication State Object
- **isLoading** (boolean) - Indicates if the authentication state is currently being loaded.
- **isAuthenticated** (boolean) - Indicates if the client is currently authenticated.

#### Response Example
```json
{
  "isLoading": false,
  "isAuthenticated": true
}
```
```

--------------------------------

### Execute Convex Functions via CLI

Source: https://context7_llms

Runs a public or internal Convex query, mutation, or action on your development deployment. Arguments are specified as a JSON object. You can use `--watch` to live update query results, `--push` to deploy local code before running, and `--prod` to target the production deployment.

```bash
npx convex run <functionName> [args]
```

```bash
npx convex run messages:send '{"body": "hello", "author": "me"}'
```

--------------------------------

### queryJournal - Get Query Journal

Source: https://docs.convex.dev/api/classes/browser.BaseConvexClient

Retrieves the current QueryJournal for a query function, which contains metadata and history about the query execution. Returns undefined if no result has been received for the query yet.

```APIDOC
## queryJournal

### Description
Retrieves the QueryJournal containing metadata and history for a query function.

### Method
Function

### Signature
```typescript
queryJournal(name: string, args?: Record<string, Value>): undefined | QueryJournal
```

### Parameters
- **name** (string) - Required - The name of the query function
- **args** (Record<string, Value>) - Optional - Arguments object for the query

### Returns
- `undefined | QueryJournal` - The query journal if available, or undefined if no result has been received yet

### Source
[browser/sync/client.ts:724](https://github.com/get-convex/convex-js/blob/main/src/browser/sync/client.ts#L724)
```

--------------------------------

### GET /api/json_schemas

Source: https://docs.convex.dev/streaming-export-api

Retrieves the JSON schemas for all tables, describing how documents are encoded. Includes '$description' tags for clarity and additional information like referenced tables for Id fields.

```APIDOC
## GET /api/json_schemas

### Description
The JSON Schemas endpoint lists tables, and for each table describes how documents will be encoded, given as [JSON Schema](https://json-schema.org/). This endpoint returns `$description` tags throughout the schema to describe unintuitive encodings and give extra information like the table referenced by `Id` fields.

### Method
GET

### Endpoint
/api/json_schemas

### Parameters
#### Path Parameters
- No path parameters.

#### Query Parameters
- **deltaSchema** (boolean) - Optional - If set, include metadata fields returned by document_deltas and list_snapshot (`_ts`, `_deleted`, and `_table`).
- **format** (string) - Optional - Output format for values. Valid values: `["json"]`.

#### Request Body
- No request body.

### Request Example
```json
{}
```

### Response
#### Success Response (200)
- Returns a JSON object where keys are table names and values are JSON Schema objects describing the table's document structure. The schema includes `$description` tags.

#### Response Example
```json
{
  "users": {
    "$id": "https://example.com/schemas/user.json",
    "title": "User",
    "type": "object",
    "properties": {
      "_id": {
        "type": "string",
        "$description": "Convex unique ID for the document."
      },
      "name": {
        "type": "string"
      },
      "email": {
        "type": "string",
        "format": "email"
      },
      "_creationTime": {
        "type": "number",
        "$description": "Timestamp of document creation."
      }
    },
    "required": ["_id", "name", "email", "_creationTime"]
  },
  "messages": {
    "$id": "https://example.com/schemas/message.json",
    "title": "Message",
    "type": "object",
    "properties": {
      "_id": {
        "type": "string"
      },
      "text": {
        "type": "string"
      },
      "authorId": {
        "type": "string",
        "$description": "Reference to the 'users' table."
      },
      "_creationTime": {
        "type": "number"
      }
    },
    "required": ["_id", "text", "authorId", "_creationTime"]
  }
}
```
```

--------------------------------

### Set up ConvexProvider in React Native layout

Source: https://context7_llms

Initialize a ConvexReactClient with your deployment URL and wrap your app's component tree with ConvexProvider to enable Convex hooks. This must be done at the root layout level.

```typescript
import { ConvexProvider, ConvexReactClient } from "convex/react";
import { Stack } from "expo-router";

const convex = new ConvexReactClient(process.env.EXPO_PUBLIC_CONVEX_URL!, {
  unsavedChangesWarning: false,
});

export default function RootLayout() {
  return (
    <ConvexProvider client={convex}>
      <Stack>
        <Stack.Screen name="index" />
      </Stack>
    </ConvexProvider>
  );
}
```

--------------------------------

### Initialize Convex RAG with an Embedding Model

Source: https://www.convex.dev/components/rag

This TypeScript snippet shows the basic setup for initializing the RAG component in a Convex file, typically an `example.ts`. It requires importing `RAG` and configuring it with an AI SDK embedding model (e.g., OpenAI's `text-embedding-3-small`) and its corresponding embedding dimension, which is crucial for vector-based semantic searches.

```typescript
// convex/example.ts
import { components } from "./_generated/api";
import { RAG } from "@convex-dev/rag";
// Any AI SDK model that supports embeddings will work.
import { openai } from "@ai-sdk/openai";

const rag = new RAG(components.rag, {
  textEmbeddingModel: openai.embedding("text-embedding-3-small"),
  embeddingDimension: 1536, // Needs to match your embedding model
});
```

--------------------------------

### GET indexes() Method

Source: https://context7_llms

Retrieves all indexes defined on the table. This is an experimental API intended for advanced use cases where you need to dynamically decide which index to use for queries. Returns an array of index descriptors with their field paths.

```APIDOC
## GET indexes()

### Description
Returns indexes defined on this table. Intended for advanced use cases of dynamically deciding which index to use for a query. This is an experimental API and may change or disappear in future versions.

### Method
GET

### Signature
```
indexes(): { indexDescriptor: string; fields: string[] }[]
```

### Parameters
None

### Returns
- **Type**: `{ indexDescriptor: string; fields: string[] }[]`
- **Description**: Array of index objects, each containing:
  - **indexDescriptor** (string) - Identifier for the index
  - **fields** (string[]) - Array of field paths included in the index

### Response Example
```json
[
  {
    "indexDescriptor": "by_userId",
    "fields": ["userId"]
  },
  {
    "indexDescriptor": "by_userId_createdAt",
    "fields": ["userId", "_creationTime"]
  }
]
```

### Notes
- **Status**: Experimental - may change or disappear
- **Use Case**: Advanced dynamic index selection for queries
- **Issue Reference**: [GitHub Issue #49](https://github.com/get-convex/convex-js/issues/49)

### Defined In
[server/schema.ts:222](https://github.com/get-convex/convex-js/blob/main/src/server/schema.ts#L222)
```

--------------------------------

### Implement Granular Access Control with Separate Convex Functions (TypeScript)

Source: https://context7_llms

This example demonstrates a best practice for access control: creating more granular Convex functions instead of a single broad update function. By separating 'setTeamOwner' and 'setTeamName', it allows for distinct and specific access checks based on user roles (e.g., team owner vs. team member), enhancing security and maintainability. Both functions securely use `ctx.auth.getUserIdentity()` for authorization.

```typescript
//  -- separate functions which have different access control
export const setTeamOwner = mutation({
  args: {
    id: v.id("teams"),
    owner: v.id("users"),
  },
  handler: async (ctx, { id, owner }) => {
    const user = await ctx.auth.getUserIdentity();
    if (user === null) {
      throw new Error("Unauthorized");
    }
    const isTeamOwner = /* check if user is the owner of the team */
    if (!isTeamOwner) {
      throw new Error("Unauthorized");
    }
    await ctx.db.patch("teams", id, { owner: owner });
  },
});
```

```typescript
export const setTeamName = mutation({
  args: {
    id: v.id("teams"),
    name: v.string(),
  },
  handler: async (ctx, { id, name }) => {
    const user = await ctx.auth.getUserIdentity();
    if (user === null) {
      throw new Error("Unauthorized");
    }
    const isTeamMember = /* check if user is a member of the team */
    if (!isTeamMember) {
      throw new Error("Unauthorized");
    }
    await ctx.db.patch("teams", id, { name: name });
  },
});
```

--------------------------------

### Deploy to Convex and GitHub Pages Using npm

Source: https://context7_llms

Command to deploy backend code to Convex production deployment and trigger frontend build process. The command sets environment variables for the frontend to connect to the production Convex deployment and then builds the frontend code.

```bash
npx convex deploy --cmd 'npm run build'
```

```bash
npx convex deploy --cmd-url-env-var-name CUSTOM_CONVEX_URL --cmd 'npm run build'
```

--------------------------------

### Restore Convex Deployment from a Backup ZIP via CLI

Source: https://context7_llms

Restore a Convex deployment from a previously downloaded backup ZIP file. This process retains `_id` and `_creationTime` fields to maintain references. Use `--replace` to overwrite existing data in tables mentioned in the ZIP file.

```shell
npx convex import <path>.zip
```

--------------------------------

### Example Legacy Console Log Event JSON

Source: https://docs.convex.dev/production/integrations/log-streams/legacy-event-schema

Sample JSON structure of a console log event from a Convex query function. Demonstrates the use of system fields (_topic, _timestamp, _functionType, _functionPath, _functionCached) and the message payload containing the logged output.

```json
{
  "_topic": "_console",
  "_timestamp": 1695066350531,
  "_functionType": "query",
  "_functionPath": "myDir/myFile",
  "_functionCached": true,
  "message": "[LOG] 'My log message'"
}
```

--------------------------------

### FunctionArgs Type Definition

Source: https://docs.convex.dev/api/modules/server

Given a FunctionReference, get the return type of the function. This is represented as an object mapping argument names to values.

```APIDOC
## Type: FunctionArgs

### Description
Given a [FunctionReference](/api/modules/server.md#functionreference), get the return type of the function.

This is represented as an object mapping argument names to values.

### Type Parameters
- **FuncRef** (extends `AnyFunctionReference`) -

### Type Definition
 FunctionArgs<`FuncRef`>: `FuncRef`\[`"_args"`\]
```

--------------------------------

### Building and Using an AI Agent with Convex

Source: https://docs.convex.dev/agents

This snippet demonstrates how to define an AI agent using the Agent component in Convex and how to use it within a Convex action. It covers agent initialization with a model, instructions, and tools, as well as creating and continuing conversation threads. Dependencies include '@convex-dev/agents' and '@ai-sdk/openai'.

```typescript
import { Agent } from "@convex-dev/agents";
import { openai } from "@ai-sdk/openai";
import { components } from "./_generated/api";
import { action } from "./_generated/server";

// Define an agent
const supportAgent = new Agent(components.agent, {
  name: "Support Agent",
  chat: openai.chat("gpt-4o-mini"),
  instructions: "You are a helpful assistant.",
  tools: { accountLookup, fileTicket, sendEmail },
});

// Use the agent from within a normal action:
export const createThread = action({
  args: { prompt: v.string() },
  handler: async (ctx, { prompt }) => {
    const { threadId, thread } = await supportAgent.createThread(ctx);
    const result = await thread.generateText({ prompt });
    return { threadId, text: result.text };
  },
});

// Pick up where you left off, with the same or a different agent:
export const continueThread = action({
  args: { prompt: v.string(), threadId: v.string() },
  handler: async (ctx, { prompt, threadId }) => {
    // This includes previous message history from the thread automatically.
    const { thread } = await anotherAgent.continueThread(ctx, { threadId });
    const result = await thread.generateText({ prompt });
    return result.text;
  },
});
```

--------------------------------

### Get Current Connection State

Source: https://context7_llms

Retrieve the current ConnectionState between the client and the Convex backend. This method provides synchronous access to the connection status without setting up subscriptions.

```typescript
connectionState(): ConnectionState
```

--------------------------------

### Define a basic paginated Convex query (TypeScript)

Source: https://context7_llms

This TypeScript example demonstrates how to create a basic paginated query function in Convex. It utilizes the `paginationOptsValidator` to ensure proper pagination arguments and calls `.paginate()` on a database query to retrieve a page of messages, ordered in descending order.

```ts
import { v } from "convex/values";
import { query, mutation } from "./_generated/server";
import { paginationOptsValidator } from "convex/server";

export const list = query({
  args: { paginationOpts: paginationOptsValidator },
  handler: async (ctx, args) => {
    const foo = await ctx.db
      .query("messages")
      .order("desc")
      .paginate(args.paginationOpts);
    return foo;
  },
});
```

--------------------------------

### Get Auth Token from Clerk for Convex Authentication

Source: https://context7_llms

Shows how to retrieve a JWT token from Clerk authentication to use with Convex server-side functions. The token is generated using the Clerk auth template configured for Convex.

```typescript
import { auth } from "@clerk/nextjs/server";

export async function getAuthToken() {
  return (await (await auth()).getToken({ template: "convex" })) ?? undefined;
}
```

--------------------------------

### Fetch Streaming Messages with React useUIMessages Hook

Source: https://context7_llms

This example demonstrates how to use the `useUIMessages` React hook to fetch messages that include streaming data. By passing `stream: true` in the options, the hook is configured to handle and provide real-time streamed messages from the Convex API.

```typescript
const { results, status, loadMore } = useUIMessages(
  api.chat.streaming.listMessages,
  { threadId },
  { initialNumItems: 10, stream: true },
);
```

--------------------------------

### Get Maximum Observed Timestamp

Source: https://context7_llms

Returns the maximum observed timestamp from the client's synchronization state. The timestamp is returned as a Long type or undefined if no timestamp has been observed.

```typescript
getMaxObservedTimestamp(): undefined | Long
```

--------------------------------

### Fetch Convex Management API with Bearer Token Authorization

Source: https://docs.convex.dev/management-api

Demonstrates how to authenticate and make a request to the Convex Management API using a Bearer token in the Authorization header. The example fetches a list of projects for a team. The response is returned in JSON format.

```javascript
const token = "ey...0=";
const response = await fetch(
  "https://api.convex.dev/v1/teams/41/list_projects",
  {
    headers: {
      Authorization: `Bearer ${token}`,
    },
  },
);
console.log(await response.json());
```

--------------------------------

### Optimize Convex Database Queries by Avoiding .filter

Source: https://context7_llms

This example illustrates how to refactor Convex database queries to improve efficiency. It shows an anti-pattern using `.filter` directly on a query, and then presents two recommended approaches: leveraging a database index with `.withIndex` for optimal performance, or performing the filtering in application code for readability when an index isn't suitable. These methods avoid the performance overhead of `.filter` on large datasets, which can lead to excessive bandwidth usage and re-runs.

```typescript
// 
const tomsMessages = ctx.db
  .query("messages")
  .filter((q) => q.eq(q.field("author"), "Tom"))
  .collect();

// 
// Option 1: Use an index
const tomsMessages = await ctx.db
  .query("messages")
  .withIndex("by_author", (q) => q.eq("author", "Tom"))
  .collect();

// Option 2: Filter in code
const allMessages = await ctx.db.query("messages").collect();
const tomsMessages = allMessages.filter((m) => m.author === "Tom");
```

--------------------------------

### Call Component Query/Mutation/Action in Convex

Source: https://context7_llms

Demonstrates how to call component functions from application code using ctx.runQuery. Component functions follow the same rules as regular Convex functions - queries call queries, mutations call mutations, and actions call actions. The example shows calling a component's getThread query from an internal action with proper argument passing.

```typescript
import { internalAction } from "./_generated/server";
import { components } from "./_generated/api";

export const myAction = internalAction({
  args: { threadId: v.string() },
  handler: async (ctx, args) => {
    // Call the component's API to get the thread status.
    const { status } = await ctx.runQuery(components.agent.threads.getThread, {
      threadId: args.threadId,
    });
    //...
  },
});
```

--------------------------------

### Deploy Convex Functions to Preview Deployment

Source: https://docs.convex.dev/using/cli

Create and deploy to preview deployments using a Preview Deploy Key. Automatically infers Git branch names for Vercel, Netlify, GitHub, and GitLab or uses --preview-create to customize deployment name. Supports running a function after deployment with --preview-run.

```bash
npx convex deploy --preview-create my-branch-name
```

```bash
npx convex deploy --cmd "npm run build"
```

```bash
npx convex deploy --cmd 'npm run build' --cmd-url-env-var-name CUSTOM_CONVEX_URL
```

```bash
npx convex deploy --preview-run myFunction
```

--------------------------------

### Calculating Rate Limit Status at a Specific Timestamp (JavaScript)

Source: https://convex.dev/components/rate-limiter

This example shows how to use the `calculateRateLimit` utility function to determine the rate limit status based on a given configuration, a previous value, and a specific timestamp. This allows for predictive analysis or offline calculations.

```javascript
import { calculateRateLimit } from "@convex-dev/rate-limiter";
const { config, value, ts } = calculateRateLimit(
  { value, ts },
  config,
  Date.now(),
  count || 0
);
```

--------------------------------

### Filter Creation Time with Nanosecond Precision

Source: https://docs.convex.dev/dashboard/deployments/data

Example of filtering documents by _creationTime using two conditions for exact time matching. The _creationTime field uses nanosecond granularity, requiring dual conditions to filter to a specific moment.

```text
creationTime >= $time
creationTime <= $time + 1 minute
```

--------------------------------

### Poll Convex Action Run Status

Source: https://convex.dev/components/retrier

This example shows how to retrieve the `RunId` from `retrier.run` and then continuously poll the `retrier.status` until the action completes. It demonstrates waiting for completion and logging the final result.

```typescript
export const kickoffExampleAction = action(async (ctx) => {
  const runId = await retrier.run(ctx, internal.index.exampleAction, { failureRate: 0.8 });
  while (true) {
    const status = await retrier.status(ctx, runId);
    if (status.type === "inProgress") {
      await new Promise((resolve) => setTimeout(resolve, 1000));
      continue;
    } else {
      console.log("Run completed with result:", status.result);
      break;
    }
  }
});
```

--------------------------------

### Mock Fetch Calls with Vitest Global Stub

Source: https://docs.convex.dev/testing/convex-test

Shows how to mock global fetch calls in Convex action tests using Vitest's vi.stubGlobal() and vi.fn() methods. The example stubs fetch to return a mocked response, tests the action with mocked data, and cleans up with vi.unstubAllGlobals().

```TypeScript
import { expect, test, vi } from "vitest";
import { api } from "./_generated/api";
import schema from "./schema";
import { convexTest } from "convex-test";

test("ai", async () => {
  const t = convexTest(schema, modules);

  vi.stubGlobal(
    "fetch",
    vi.fn(async () => ({ text: async () => "I am the overlord" }) as Response),
  );

  const reply = await t.action(api.messages.sendAIMessage, { prompt: "hello" });
  expect(reply).toEqual("I am the overlord");

  vi.unstubAllGlobals();
});

const modules = import.meta.glob("./**/*.ts");
```

--------------------------------

### List and Paginate R2 Object Metadata in Convex Queries

Source: https://www.convex.dev/components/cloudflare-r2

This Convex example demonstrates two queries: `list` for retrieving a limited set of R2 object metadata, and `page` for paginating through R2 object metadata. Both use the `R2` client to interact with R2 storage.

```typescript
// convex/example.ts
import { query } from "./_generated/server";
import { R2 } from "@convex-dev/r2";

const r2 = new R2(components.r2);

export const list = query({
  args: { limit: v.optional(v.number()), },
  handler: async (ctx, args) => {
    return r2.listMetadata(ctx, args.limit);
  },
});

export const page = query({
  args: { paginationOpts: paginationOptsValidator, },
  handler: async (ctx, args) => {
    return r2.pageMetadata(ctx, args.paginationOpts);
  },
});
```

--------------------------------

### Example Convex OpenAPI Specification YAML

Source: https://docs.convex.dev/client/open-api

Illustrates a partial structure of the `convex-spec.yaml` file generated by the `open-api-spec` command. It includes essential OpenAPI 3.0.3 metadata, such as the API title, version, server URL, and a general description, which is used by client generators.

```yaml
# convex-spec.yaml
openapi: 3.0.3
info:
  title: Convex App - OpenAPI 3.0
  version: 0.0.0
  servers:
    - url: "{hostUrl}"
  description: Convex App API
  ...
```

--------------------------------

### Initialize ConvexClient with WebSocket connection

Source: https://context7_llms

Creates a new ConvexClient instance and establishes a WebSocket connection to the specified Convex deployment address. The client immediately initiates the connection upon instantiation.

```typescript
const client = new ConvexClient("https://happy-otter-123.convex.cloud");
```

--------------------------------

### Cancel Scheduled Function

Source: https://context7_llms

Cancels a previously scheduled function if it has not started yet. If the scheduled function is already in progress, it will continue running but any new functions that it tries to schedule will be canceled.

```APIDOC
## POST /scheduler/cancel

### Description
Cancels a previously scheduled function if it has not started yet. If the scheduled function is already in progress, it will continue running but any new functions that it tries to schedule will be canceled.

### Method
POST

### Endpoint
/scheduler/cancel

### Parameters
#### Request Body
- **id** (GenericId<"_scheduled_functions">) - Required - The ID of the scheduled function to cancel.

### Request Example
```json
{
  "id": "some_generic_id_123"
}
```

### Response
#### Success Response (200)
Returns an empty response body on successful cancellation, indicating the operation was accepted.

#### Response Example
```json
{}
```
```

--------------------------------

### StorageWriter.getUrl (GenericId)

Source: https://context7_llms

Retrieves a URL to access a file in Convex storage using its `Id<"_storage">`. The returned URL can be used for direct HTTP GET requests, which will include a standard HTTP Digest header with a sha256 checksum.

```APIDOC
## getUrl

### Description
Get the URL for a file in storage by its `Id<"_storage">`. The GET response includes a standard HTTP Digest header with a sha256 checksum.

### Method
SDK Method

### Signature
`getUrl(storageId: GenericId<"_storage">): Promise<null | string>`

### Parameters
#### Method Parameters
- **storageId** (GenericId<"_storage">) - Required - The `Id<"_storage">` of the file to fetch from Convex storage.

### Returns
`Promise<null | string>`

A URL which fetches the file via an HTTP GET, or `null` if it no longer exists.

### Request Example
(Not applicable for SDK method)

### Response Example
```json
"https://your-convex-deployment.convex.cloud/storage/v1/files/example-file-id"
```

```json
null
```
```

--------------------------------

### Test Convex Posts API with Vitest and convex-test

Source: https://context7_llms

This snippet illustrates how to write unit tests for Convex queries and mutations in TypeScript using the `convex-test` library and `vitest`. It includes examples for testing a `posts.list` query to ensure it returns an empty array when no posts exist, and verifies the correct ordering of posts after several `posts.add` mutations.

```typescript
import { convexTest } from "convex-test";
import { describe, it, expect } from "vitest";
import { api, internal } from "./_generated/api";
import schema from "./schema";

describe("posts.list", () => {
  it("returns empty array when no posts exist", async () => {
    const t = convexTest(schema, modules);

    // Initially, there are no posts, so `list` returns an empty array
    const posts = await t.query(api.posts.list);
    expect(posts).toEqual([]);
  });

  it("returns all posts ordered by creation time when there are posts", async () => {
    const t = convexTest(schema, modules);

    // Create some posts
    await t.mutation(internal.posts.add, {
      title: "First Post",
      content: "This is the first post",
      author: "Alice"
    });
    await t.mutation(internal.posts.add, {
      title: "Second Post",
      content: "This is the second post",
      author: "Bob"
    });

    // `list` returns all posts ordered by creation time
    const posts = await t.query(api.posts.list);
    expect(posts).toHaveLength(2);
    expect(posts[0].title).toBe("Second Post");
    expect(posts[1].title).toBe("First Post");
  });
});

const modules = import.meta.glob("./**/*.ts");
```

--------------------------------

### BaseConvexClientOptions Interface

Source: https://docs.convex.dev/api/modules/browser

Configuration options for initializing base Convex client instances. Provides foundational settings for both HTTP and WebSocket-based clients.

```APIDOC
## BaseConvexClientOptions

### Description
Interface defining configuration options for BaseConvexClient initialization.

### Properties
Refer to the interface documentation at /api/interfaces/browser.BaseConvexClientOptions.md for complete property definitions.

### Usage
This interface serves as the base for:
- ConvexClientOptions - Extended with disabled and unsavedChangesWarning properties
- HTTP client configuration
- WebSocket client configuration

### Notes
- Used as foundation for client-specific options
- Extended by ConvexClientOptions type
```

--------------------------------

### Environment Variables Configuration for Next.js Convex Setup

Source: https://docs.convex.dev/auth/authkit

Environment variables required for WorkOS AuthKit and Convex integration in Next.js. Includes WorkOS credentials (client ID, API key, cookie password), OAuth redirect URI, and Convex deployment configuration. Must be added to .env.local file.

```plaintext
# WorkOS AuthKit Configuration
WORKOS_CLIENT_ID=client_your_client_id_here
WORKOS_API_KEY=sk_test_your_api_key_here
WORKOS_COOKIE_PASSWORD=your_secure_password_here_must_be_at_least_32_characters_long
NEXT_PUBLIC_WORKOS_REDIRECT_URI=http://localhost:3000/callback

# Convex Configuration (you don't have to fill these out, they're generated by Convex)
# Deployment used by `npx convex dev`
CONVEX_DEPLOY_KEY=your_convex_deploy_key_here
NEXT_PUBLIC_CONVEX_URL=https://your-convex-url.convex.cloud
```

--------------------------------

### Seed Vercel Preview Deployment with Sample Data

Source: https://docs.convex.dev/database/import-export/import

This script outlines how to seed a Vercel preview deployment with sample data from a `seed_data.zip` file committed in the repository root. It first deploys the Convex project, then conditionally imports data into the preview deployment using its Git commit reference as the preview name.

```bash
npx convex deploy --cmd 'npm run build' &&\
if [ "$VERCEL_ENV" == "preview" ]; then\
npx convex import --preview-name "$VERCEL_GIT_COMMIT_REF" seed_data.zip;\
fi
```

--------------------------------

### Set Up Convex Provider in Vue Application

Source: https://context7_llms

Initializes the Convex Vue plugin in the main Vue application entry point to make it available on every page. Uses Vite environment variables to configure the Convex URL and integrates with Vue's app instance.

```typescript
import { convexVue } from 'convex-vue'
import { createApp } from 'vue'
import App from './App.vue'

const app = createApp(App)

app.use(convexVue, {
  url: import.meta.env.VITE_CONVEX_URL,
})

app.mount('#app')
```

--------------------------------

### Configure GitHub Actions CI Workflow for Testing

Source: https://docs.convex.dev/testing/ci

This YAML configuration sets up a GitHub Actions workflow to run your Node.js project's tests. It checks out the code, sets up Node.js, installs dependencies with `npm ci`, and executes the test script using `npm run test`. The workflow is triggered on `pull_request` and `push` events.

```yaml
name: Run Tests

on: [pull_request, push]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
      - run: npm ci
      - run: npm run test
```

--------------------------------

### Token Bucket Rate Limiting for User Token Usage

Source: https://docs.convex.dev/agents/rate-limiting

Sets up a token bucket rate limiter for per-user token usage, allowing 1000 tokens per minute with a capacity of 10000. This prevents single users from consuming excessive token bandwidth.

```typescript
tokenUsage: { kind: "token bucket", period: MINUTE, rate: 1_000 }
```

--------------------------------

### GET /storage/{storageId} (Deprecated String ID)

Source: https://context7_llms

DEPRECATED: Retrieves a file from Convex storage as a Blob using a string `StorageId`. Returns `null` if the file does not exist. It is recommended to use `Id<"_storage">` instead.

```APIDOC
## GET /storage/{storageId}

### Description
DEPRECATED: Retrieves a file from Convex storage as a Blob using a string `StorageId`. Returns `null` if the file does not exist. It is recommended to use `Id<"_storage">` instead.

### Method
GET

### Endpoint
/storage/{storageId}

### Parameters
#### Path Parameters
- **storageId** (`string`) - Required - The `StorageId` (as a string) of the file to retrieve from Convex storage.

#### Request Body
(No request body required for this operation.)

### Request Example
{}

### Response
#### Success Response (200 OK)
- **file** (`Blob` | `null`) - The file content as a Blob, or `null` if not found.

#### Response Example
{
  "fileContent": "<binary_data_of_the_blob>"
}
```

--------------------------------

### Initialize ConvexHttpClient for Convex Cloud

Source: https://docs.convex.dev/api/modules/browser

Creates a ConvexHttpClient instance to establish a connection to Convex Cloud. The address parameter should be the Convex Cloud URL, typically loaded from an environment variable. This is the primary entry point for browser-based Convex access.

```typescript
import { ConvexHttpClient } from "convex/browser";
// typically loaded from an environment variable
const address = "https://small-mouse-123.convex.cloud";
const convex = new ConvexHttpClient(address);
```

--------------------------------

### Define a Basic Agent with OpenAI

Source: https://docs.convex.dev/agents/agent-usage

This snippet demonstrates how to define a basic Agent using the `@convex-dev/agent` library and the OpenAI language model. It initializes an Agent with a name and specifies the language model to be used. The 'components.agent' is likely a reference to a pre-configured agent component within the Convex setup.

```typescript
import { components } from "./_generated/api";
import { Agent } from "@convex-dev/agent";
import { openai } from "@ai-sdk/openai";

const agent = new Agent(components.agent, {
  name: "Basic Agent",
  languageModel: openai.chat("gpt-4o-mini"),
});
```

--------------------------------

### Get Current Connection State

Source: https://docs.convex.dev/api/classes/react.ConvexReactClient

Retrieve the current ConnectionState between the client and Convex backend. Returns a ConnectionState object representing the current connection status. Useful for monitoring client-server connectivity.

```typescript
connectionState(): ConnectionState
```

--------------------------------

### Run Convex Dev in Agent Mode (bun)

Source: https://docs.convex.dev/ai

This command initiates the Convex development server in agent mode using bun. It's designed for background coding agents to interact with Convex deployments, allowing them to generate code, iterate, and run tests. Requires full internet access for binary download.

```bash
bun i
CONVEX_AGENT_MODE=anonymous bun x convex dev --once
```

--------------------------------

### Define Data Class for Tasks in MainActivity

Source: https://docs.convex.dev/quickstart/android

Creates a Kotlin data class named 'Task' within the MainActivity to represent the structure of task data fetched from Convex. This class is annotated with @Serializable for data serialization.

```kotlin
@Serializable
data class Task(val text: String, val isCompleted: Boolean)
```

--------------------------------

### Initialize ConvexClient with Resource-Based Deployment URL

Source: https://context7_llms

Creates a ConvexClient instance using a deployment URL stored as an Android string resource. The URL is resolved at runtime from the build variant's configured value, enabling seamless switching between production and development deployments without code changes.

```kotlin
val convex = ConvexClient(context.getString(R.string.convex_url))
```

--------------------------------

### Configure Clerk publishable key for production in .env

Source: https://docs.convex.dev/auth/clerk

This snippet shows how to set Clerk's publishable key for production in a `.env` file. The `pk_live_...` key is used by frontend applications to interact with Clerk in a production environment.

```dotenv
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY="pk_live_..."
```

--------------------------------

### Get authentication token from Clerk in Next.js

Source: https://docs.convex.dev/client/nextjs/app-router/server-rendering

Provides the implementation of getAuthToken using Clerk's authentication service. Retrieves a JWT token using the 'convex' template from the authenticated session.

```TypeScript
import { auth } from "@clerk/nextjs/server";

export async function getAuthToken() {
  return (await (await auth()).getToken({ template: "convex" })) ?? undefined;
}
```

--------------------------------

### Run Rust application

Source: https://context7_llms

Compiles and executes the Rust application. This command will run the `main` function in `src/main.rs`, which connects to Convex and fetches data.

```bash
cargo run
```

--------------------------------

### Watch.localQueryResult

Source: https://context7_llms

Get the current result of a watched query from the local client cache. Returns the result only if already subscribed to the query and have received a result from the server or the query value has been set optimistically.

```APIDOC
## localQueryResult

### Description
Get the current result of a query from the local client cache. This will only return a result if already subscribed to the query and have received a result from the server or the query value has been set optimistically. Throws an error if the query encountered an error on the server.

### Method
Query Result Accessor

### Signature
```typescript
localQueryResult(): undefined | T
```

### Returns
- **(T | undefined)** - The current query result if available, or undefined if no result has been received yet.

### Throws
- **Error** - If the query encountered an error on the server.

### Notes
- Returns undefined if not yet subscribed or no result received
- Can return optimistically updated values
- Throws errors from server-side query execution
```

--------------------------------

### Configure Convex ESLint Plugin in .eslintrc.js

Source: https://docs.convex.dev/eslint

Add Convex plugin configuration to .eslintrc.js file with recommended rules and ignore patterns. This setup uses the deprecated ESLint configuration format.

```javascript
module.exports = {
  extends: [
    // Other configurations
    "plugin:@typescript-eslint/recommended",
    "plugin:@convex-dev/recommended",
  ],
  ignorePatterns: ["node_modules/", "dist/", "build/"],
};
```

--------------------------------

### Search for Context Messages using Convex Agent

Source: https://context7_llms

This example shows how to manually search for messages using `agent.fetchContextMessages`. It allows specifying `threadId`, `searchText`, `targetMessageId`, `userId`, and `contextOptions` to find relevant messages, including text and vector search capabilities. This is useful for custom context inclusion or re-generating responses.

```typescript
import type { MessageDoc } from "@convex-dev/agent";

const messages: MessageDoc[] = await agent.fetchContextMessages(ctx, {
  threadId,
  searchText: prompt, // Optional unless you want text/vector search.
  targetMessageId: promptMessageId, // Optionally target the search.
  userId, // Optional, unless `searchOtherThreads` is true.
  contextOptions, // Optional, defaults are used if not provided.
});
```

--------------------------------

### ConvexHttpClient Initialization

Source: https://docs.convex.dev/api/modules/browser

Initialize a ConvexHttpClient instance to establish a connection to the Convex Cloud backend. This is the primary entry point for browser-based applications to interact with Convex services.

```APIDOC
## ConvexHttpClient Initialization

### Description
Create and initialize a ConvexHttpClient instance to connect to your Convex Cloud deployment.

### Usage
```typescript
import { ConvexHttpClient } from "convex/browser";

const address = "https://small-mouse-123.convex.cloud";
const convex = new ConvexHttpClient(address);
```

### Parameters
- **address** (string) - Required - The URL of your Convex Cloud deployment

### Returns
- **ConvexHttpClient** - A client instance for making queries and mutations to Convex

### Notes
- The address is typically loaded from an environment variable
- For React applications, use the react module instead
- Supports both HTTP and WebSocket-based connections
```

--------------------------------

### Configure TanStack Router for Convex and React Query Integration

Source: https://docs.convex.dev/client/tanstack/tanstack-start/clerk

This code snippet demonstrates how to modify `app/router.tsx` to set up the TanStack router with Convex and React Query. It initializes `ConvexReactClient` and `ConvexQueryClient`, configures `QueryClient` to leverage Convex's query key hashing and query functions, and extends the router's context to include necessary Convex clients. Finally, it wraps the application with `ConvexProvider`.

```typescript
import { createRouter as createTanStackRouter } from '@tanstack/react-router'
import { routeTree } from './routeTree.gen'
import { DefaultCatchBoundary } from './components/DefaultCatchBoundary'
import { NotFound } from './components/NotFound'
import { routerWithQueryClient } from '@tanstack/react-router-with-query'
import { ConvexProvider, ConvexReactClient } from 'convex/react'
import { ConvexQueryClient } from '@convex-dev/react-query'
import { QueryClient } from '@tanstack/react-query'

export function createRouter() {
  const CONVEX_URL = (import.meta as any).env.VITE_CONVEX_URL!
  if (!CONVEX_URL) {
    throw new Error('missing VITE_CONVEX_URL envar')
  }
  const convex = new ConvexReactClient(CONVEX_URL, {
    unsavedChangesWarning: false,
  })
  const convexQueryClient = new ConvexQueryClient(convex)

  const queryClient: QueryClient = new QueryClient({
    defaultOptions: {
      queries: {
        queryKeyHashFn: convexQueryClient.hashFn(),
        queryFn: convexQueryClient.queryFn(),
      },
    },
  })
  convexQueryClient.connect(queryClient)

  const router = routerWithQueryClient(
    createTanStackRouter({
      routeTree,
      defaultPreload: 'intent',
      defaultErrorComponent: DefaultCatchBoundary,
      defaultNotFoundComponent: () => <NotFound />,
      context: { queryClient, convexClient: convex, convexQueryClient },
      scrollRestoration: true,
      Wrap: ({ children }) => (
        <ConvexProvider client={convexQueryClient.convexClient}>
          {children}
        </ConvexProvider>
      ),
    }),
    queryClient,
  )

  return router
}

declare module '@tanstack/react-router' {
  interface Register {
    router: ReturnType<typeof createRouter>
  }
}
```

--------------------------------

### Retrieve Document by ID in Convex

Source: https://docs.convex.dev/database/document-ids

Shows how to fetch a single document from the database using its unique ID with the get method. This is an efficient operation for accessing specific documents by their ID.

```typescript
const retrievedUser = await ctx.db.get("users", userId);
```

--------------------------------

### Initialize Clerk Middleware in Next.js

Source: https://docs.convex.dev/auth/clerk

Middleware configuration for Next.js that grants access to user authentication state throughout the application. The clerkMiddleware() helper processes authentication for all routes except Next.js internals and static files.

```TypeScript
import { clerkMiddleware } from '@clerk/nextjs/server';

export default clerkMiddleware();

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\\.(?:html|css|js|woff|woff2|ttf|otf|eot|svg|png|jpg|jpeg|gif|webp|ico|json)$)[^?]*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
};
```

--------------------------------

### Initialize ConvexReactClient in JavaScript

Source: https://context7_llms

Instantiate `ConvexReactClient` with your backend deployment URL. This client manages the connection to your Convex backend and is essential for all Convex React hooks, enabling communication between your frontend and backend.

```javascript
import { ConvexProvider, ConvexReactClient } from "convex/react";

const convex = new ConvexReactClient("https://<your domain here>.convex.cloud");
```

--------------------------------

### Integrate Convex client in HTML script tag

Source: https://context7_llms

This HTML snippet demonstrates how to include the Convex browser bundle via a script tag and initialize a `ConvexClient`. It then subscribes to real-time updates from the `api.tasks.get` query, logging task texts to the console whenever the `tasks` table changes.

```html
<!doctype html>
<script src="https://unpkg.com/convex@1.3.1/dist/browser.bundle.js"></script>
<script>
  const CONVEX_URL = "CONVEX_URL_GOES_HERE";
  const client = new convex.ConvexClient(CONVEX_URL);
  client.onUpdate("tasks:get", {}, (tasks) =>
    console.log(tasks.map((task) => task.text)),
  );
</script>
```

--------------------------------

### Wrap App with AuthProviderX and ConvexProviderWithAuth

Source: https://docs.convex.dev/auth/advanced/custom-auth

Client-side React component setup that wraps the application root with the custom identity provider and Convex's ConvexProviderWithAuth component to enable authentication integration.

```javascript
import { AuthProviderXReactProvider } from "providerX";
import { ConvexProviderWithAuth } from "convex/react";

root.render(
  <AuthProviderXReactProvider>
    <ConvexProviderWithAuth>
      {/* Your application components */}
    </ConvexProviderWithAuth>
  </AuthProviderXReactProvider>,
);
```

--------------------------------

### Call Convex Mutation with Arguments in Swift

Source: https://docs.convex.dev/client/swift

Demonstrates how to invoke a Convex backend mutation using the `ConvexClient.mutation` method in Swift. This example passes a dictionary of arguments, specifically a 'color', and awaits a boolean return value indicating the success of the operation. The method is asynchronous and requires `await`.

```swift
let isColorAdded: Bool = try await convex.mutation("colors:put", with: ["color": newColor])
```

--------------------------------

### Deploy to Preview Deployment with Custom Name

Source: https://docs.convex.dev/cli

Create a new preview deployment with a custom name using the CONVEX_DEPLOY_KEY Preview Deploy Key. The command infers Git branch names from Vercel, Netlify, GitHub, and GitLab environments, or uses --preview-create to specify a custom deployment name.

```bash
npx convex deploy --preview-create my-branch-name
```

--------------------------------

### Setup Convex Client Provider with Auth0 in Next.js

Source: https://docs.convex.dev/client/nextjs

Configures a ConvexClientProvider component that wraps the application with Auth0 authentication. This provider maintains a single ConvexReactClient instance and integrates Auth0Provider for authentication, enabling client-side data fetching and mutations with authenticated user context.

```TypeScript
"use client";
import { Auth0Provider } from "@auth0/auth0-react";
import { ConvexReactClient } from "convex/react";
import { ConvexProviderWithAuth0 } from "convex/react-auth0";
import { ReactNode } from "react";

const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL!);

export function ConvexClientProvider({ children }: { children: ReactNode }) {
  return (
    <Auth0Provider
      domain={process.env.NEXT_PUBLIC_AUTH0_DOMAIN!}
      clientId={process.env.NEXT_PUBLIC_AUTH0_CLIENT_ID!}
      redirectUri={typeof window !== "undefined" ? window.location.origin : ""}
    >
      <ConvexProviderWithAuth0 client={convex}>
        {children}
      </ConvexProviderWithAuth0>
    </Auth0Provider>
  );
}
```

--------------------------------

### Resetting a Specific Rate Limit (JavaScript)

Source: https://convex.dev/components/rate-limiter

This example shows how to reset a rate limit for a given key, effectively clearing any accumulated consumption. This is typically used after a successful action, such as a successful login clearing a 'failedLogins' rate limit.

```javascript
await rateLimiter.reset(ctx, "failedLogins", { key: userId });
```

--------------------------------

### Create Task Mutation with TypeScript

Source: https://context7_llms

Basic mutation example that inserts a new task into the database with validated string argument. The mutation accepts a text parameter, writes it to the tasks table, and returns the newly created task ID. Uses Convex validators for argument type checking.

```typescript
import { mutation } from "./_generated/server";
import { v } from "convex/values";

// Create a new task with the given text
export const createTask = mutation({
  args: { text: v.string() },
  handler: async (ctx, args) => {
    const newTaskId = await ctx.db.insert("tasks", { text: args.text });
    return newTaskId;
  },
});
```

--------------------------------

### Validate Convex Function Arguments in TypeScript

Source: https://docs.convex.dev/understanding/best-practices

This snippet demonstrates the difference between an unvalidated and a properly validated Convex `mutation` function. The first example shows a function where `id` and `update` parameters are not validated, making it vulnerable to incorrect types or malicious data. The second example provides a secure implementation using `v.id` and `v.object` to enforce strict type checking for the `id` (must be a valid 'movies' ID) and `update` (must contain only 'title' and 'director' strings) arguments, ensuring data integrity and security.

```typescript
//  -- `id` and `update` are not validated, so a client could pass
//       any Convex value (the type at runtime could mismatch the
//       TypeScript type). In particular, `update` could contain
//       fields other than `title` and `director`.
export const updateMovie = mutation({
  handler: async (
    ctx,
    {
      id,
      update,
    }: {
      id: Id<"movies">;
      update: Pick<Doc<"movies">, "title" | "director">;
    },
  ) => {
    await ctx.db.patch("movies", id, update);
  },
});
```

```typescript
//  -- This can only be called with an ID from the movies table,
//       and an `update` object with only the `title`/`director` fields
export const updateMovie = mutation({
  args: {
    id: v.id("movies"),
    update: v.object({
      title: v.string(),
      director: v.string(),
    }),
  },
  handler: async (ctx, { id, update }) => {
    await ctx.db.patch("movies", id, update);
  },
});
```

--------------------------------

### Paginate Data in React with usePaginatedQuery and Custom Arguments

Source: https://context7_llms

This example extends the `usePaginatedQuery` hook to pass additional arguments to the underlying Convex query function. It allows for filtering or customizing the fetched data while maintaining pagination functionality within a React component.

```typescript
import { usePaginatedQuery } from "convex/react";
import { api } from "../convex/_generated/api";

export function App() {
  const { results, status, loadMore } = usePaginatedQuery(
    api.messages.listWithExtraArg,
    { author: "Alex" },
    { initialNumItems: 5 },
  );
  return (
    <div>
      {results?.map(({ _id, body }) => <div key={_id}>{body}</div>)}
      <button onClick={() => loadMore(5)} disabled={status !== "CanLoadMore"}>
        Load More
      </button>
    </div>
  );
}
```

--------------------------------

### GET /oauth/authorize/team

Source: https://context7_llms

Redirects the user to Convex's authorization page to grant your application access to their Convex team. This initiates the OAuth 2.0 Authorization Code Grant flow for team-scoped tokens.

```APIDOC
## GET /oauth/authorize/team

### Description
Redirects the user to Convex's authorization page to grant your application access to their Convex team. This initiates the OAuth 2.0 Authorization Code Grant flow for team-scoped tokens.

### Method
GET

### Endpoint
`https://dashboard.convex.dev/oauth/authorize/team`

### Parameters
#### Path Parameters
- **scope** (string) - Required - Must be "team".

#### Query Parameters
- **client_id** (string) - Required - Your application's client ID as assigned by Convex.
- **redirect_uri** (string) - Required - A URL on your application's domain. The user will be redirected back to this URL after authorizing.
- **response_type** (string) - Required - Must be "code".
- **state** (string) - Optional - An arbitrary string used by your application to maintain state.

### Request Example
`https://dashboard.convex.dev/oauth/authorize/team?client_id=YOUR_CLIENT_ID&redirect_uri=https%3A%2F%2Fyourapp.example.com%2Fcb&response_type=code&state=xyz`

### Response
#### Success Response (302 Redirect)
Upon successful authorization, the user's browser is redirected to the `redirect_uri` with the authorization `code` and `state` parameters.

#### Response Example
`https://yourapp.example.com/cb?code=895c59eb98504a5bbaa7ad2e49cf4817&state=xyz`
```

--------------------------------

### Generate text message in an LLM thread with Convex Agent

Source: https://context7_llms

This action handler demonstrates how to use an initialized agent to generate a text reply within an existing thread. It takes a prompt and thread ID, then calls `agent.generateText` to get a response from the language model, returning the generated text.

```typescript
const agent = new Agent(components.agent, { languageModel, instructions });

export const generateReplyToPrompt = action({
  args: { prompt: v.string(), threadId: v.string() },
  handler: async (ctx, { prompt, threadId }) => {
    // await authorizeThreadAccess(ctx, threadId);
    const result = await agent.generateText(ctx, { threadId }, { prompt });
    return result.text;
  },
});
```

--------------------------------

### Initialize Android App and Display Tasks UI

Source: https://context7_llms

This Kotlin code snippet updates the `onCreate` method of `MainActivity.kt` to set the activity's content using Jetpack Compose. It enables edge-to-edge display and then renders the `Tasks` Composable, passing an initialized `ConvexClient` with the deployment URL. This connects the Android UI to the Convex backend.

```kotlin
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        setContent {
            ConvexQuickstartTheme {
                Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding ->
                    Tasks(
                        client = ConvexClient($YOUR_CONVEX_URL),
                        modifier = Modifier.padding(innerPadding)
                    )
                }
            }
        }
    }
```

--------------------------------

### Run Convex Dev in Agent Mode (npm)

Source: https://docs.convex.dev/ai

This command initiates the Convex development server in agent mode using npm. It's designed for background coding agents to interact with Convex deployments, allowing them to generate code, iterate, and run tests. Requires full internet access for binary download.

```bash
npm i
CONVEX_AGENT_MODE=anonymous npx convex dev --once
```

--------------------------------

### Get Current Authentication Claims

Source: https://context7_llms

Retrieves the current JWT authentication token and its decoded claims. Returns an object containing the token string and decoded claims record, or undefined if no authentication is set.

```typescript
getCurrentAuthClaims(): undefined | { token: string; decoded: Record<string, any> }
```

--------------------------------

### Querying Thread Messages with Convex (TypeScript)

Source: https://docs.convex.dev/agents/files

This example shows how to retrieve messages from a specific thread using a Convex query. It takes the thread ID and pagination options to fetch message history.

```typescript
// in a query
const messages = await agent.listMessages(ctx, { threadId, paginationOpts });
```

--------------------------------

### Initialize Convex Clients in Node.js with ES Modules

Source: https://context7_llms

This code snippet demonstrates how to initialize `ConvexHttpClient` for point-in-time queries and `ConvexClient` for real-time subscriptions in a Node.js environment using ES module import syntax. It requires the `convex/browser` package and the generated `api.js` file, common in projects with `"type": "module"` in `package.json`.

```javascript
import { ConvexHttpClient, ConvexClient } from "convex/browser";
import { api } from "./convex/_generated/api.js";

// HTTP client
const httpClient = new ConvexHttpClient(CONVEX_URL_GOES_HERE);
httpClient.query(api.messages.list).then(console.log);

// Subscription client
const client = new ConvexClient(CONVEX_URL_GOES_HERE);
client.onUpdate(api.messages.list, {}, (messages) => console.log(messages));
```

--------------------------------

### ComponentDefinition Type

Source: https://docs.convex.dev/api/modules/server

Defines the structure for the default export of a convex.config.ts file in a component definition directory. Provides methods for installing components and tracking exported functionality.

```APIDOC
## ComponentDefinition Type

### Description
An object type that should be the default export of a convex.config.ts file in a component definition directory.

### Type Definition
```typescript
type ComponentDefinition<Exports extends ComponentExports = any> = {
  use: (definition: Definition, options?: { name?: string }) => InstalledComponent<Definition>
  __exports: Exports
}
```

### Type Parameters
- **Exports** - Extends `ComponentExports`, defaults to `any` - Type of exports provided by component

### Properties

#### use (method)
- **Type**: `(definition: Definition, options?: { name?: string }) => InstalledComponent<Definition>`
- **Description**: Installs a component with the given definition in this component definition
- **Parameters**:
  - `definition` (Definition) - Required - Component definition to install
  - `options` (object) - Optional - Installation options
    - `name` (string) - Optional - Name for the installed component

#### __exports (property)
- **Type**: `Exports`
- **Description**: Internal type-only property tracking exports provided
- **Status**: Deprecated - Type-only property, do not use

### Notes
- Part of components feature (beta)
- API is unstable and may change in subsequent releases
- Editor tooling expects ComponentDefinition, runtime receives ImportedComponentDefinition

### Defined in
`server/components/index.ts:84`
```

--------------------------------

### Using React Hook to Check Rate Limit Status (JavaScript)

Source: https://convex.dev/components/rate-limiter

This React component example shows how to use the `useRateLimit` hook to check the rate limit status in client-side code. It demonstrates how to integrate with the server API for `getRateLimit` and `getServerTime` and how to perform checks at specific times.

```javascript
function App() {
  const { status: { ok, retryAt }, check } = useRateLimit(api.example.getRateLimit, {
    // [recommended] Allows the hook to sync the browser and server clocks
    getServerTimeMutation: getServerTime,
    // [optional] The number of tokens to wait on
    count: 1
  });
  // If you want to check at specific times and get the concrete value:
  const { value, ts, config, ok, retryAt } = check(Date.now(), count);
}
```

--------------------------------

### Setup React Hook API for Client Rate Limiting

Source: https://www.convex.dev/components/rate-limiter

Create server-side API functions for React hooks to check rate limits from the browser. Supports optional key functions for both server-determined and client-provided keys with validation.

```typescript
export const { getRateLimit, getServerTime } = rateLimiter.hookAPI(
  "sendMessage",
  {
    key: async (ctx) => await getUserId(ctx)
  }
);
```

--------------------------------

### Manually Register Local Component with Schema and Modules

Source: https://docs.convex.dev/components/using

Shows how to manually register a component by passing its schema and module files to the test instance using Vite's import.meta.glob for dynamic module loading. This approach is useful when the component doesn't provide a convenient helper function or requires custom registration logic.

```typescript
/// <reference types="vite/client" />
import { test } from "vitest";
import { convexTest } from "convex-test";
import schema from "./path/to/component/schema.ts";
const modules = import.meta.glob("./path/to/component/**/*.ts");

test("Test something with a local component", async () => {
  const t = convexTest();
  t.registerComponent("componentName", schema, modules);

  await t.run(async (ctx) => {
    await ctx.runQuery(components.componentName.someQuery, {
      arg: "value",
    });
  });
});
```

--------------------------------

### Configure and Override Convex Migration Batch Size (TypeScript)

Source: https://www.convex.dev/components/migrations

These TypeScript examples show how to define a Convex migration with a specified `batchSize` and how to override it for a single invocation. Setting `batchSize` helps manage transaction limits for large documents or reduce OCC conflicts. Overriding it for `runOne` provides granular control for specific scenarios.

```typescript
export const clearField = migrations.define({
  table: "myTable",
  batchSize: 10,
  migrateOne: () => ({ optionalField: undefined }),
});
```

```typescript
await migrations.runOne(ctx, internal.migrations.clearField, { batchSize: 1, });
```

--------------------------------

### Configure Sharded Counter in Convex Config

Source: https://www.convex.dev/components/sharded-counter

Register the sharded-counter component in your Convex configuration file. Create a convex.config.ts file in your convex/ folder and use the defineApp function to install the component.

```typescript
// convex/convex.config.ts
import { defineApp } from "convex/server";
import shardedCounter from "@convex-dev/sharded-counter/convex.config.js";
const app = defineApp();
app.use(shardedCounter);
export default app;
```

--------------------------------

### Configure Auth0 Backend with Environment Variables

Source: https://docs.convex.dev/auth/auth0

Set up auth.config.ts to use environment variables for Auth0 domain and client ID. Allows different Auth0 tenants for development and production deployments. Requires running npx convex dev or npx convex deploy after configuration changes.

```TypeScript
import { AuthConfig } from "convex/server";

export default {
  providers: [
    {
      domain: process.env.AUTH0_DOMAIN!,
      applicationID: process.env.AUTH0_CLIENT_ID!,
    },
  ],
} satisfies AuthConfig;
```

--------------------------------

### BaseConvexClient Constructor - TypeScript

Source: https://docs.convex.dev/api/classes/browser.BaseConvexClient

The constructor initializes a new BaseConvexClient instance, setting up the client with the Convex deployment address, a transition handler, and optional configurations. The address parameter is the URL of your Convex deployment, and onTransition is a callback for handling query result changes. Options allow for further client customization.

```TypeScript
/**
 *  **new BaseConvexClient**(`address`, `onTransition`, `options?`)
 * @param `address` The url of your Convex deployment, often provided by an environment variable. E.g. `https://small-mouse-123.convex.cloud`.
 * @param `onTransition` A callback receiving an array of query tokens corresponding to query results that have changed -- additional handlers can be added via `addOnTransitionHandler`.
 * @param `options?` See [BaseConvexClientOptions](/api/interfaces/browser.BaseConvexClientOptions.md) for a full description.
 */
```

--------------------------------

### Execute Python Script

Source: https://context7_llms

This command runs the `main.py` script using the Python interpreter from the virtual environment. It executes the Convex client code to fetch and display tasks, demonstrating the interaction between the Python application and the Convex backend.

```bash
venv/bin/python -m main
```

--------------------------------

### Generate Convex OpenAPI Specification via CLI

Source: https://docs.convex.dev/client/open-api

Executes the `open-api-spec` command from the installed `convex-helpers` package to automatically generate an `convex-spec.yaml` file. This YAML file describes your Convex deployment's API based on your defined functions, forming the basis for type-safe client generation.

```bash
npx convex-helpers open-api-spec
```

--------------------------------

### Define First Convex Agent with Language Model

Source: https://context7_llms

Initialize an Agent instance with the agent component, specify a name, language model (OpenAI GPT-4o-mini), system instructions, tool definitions, and maximum execution steps. This configuration enables the agent to process prompts and execute tools up to the specified limit.

```typescript
import { components } from "./_generated/api";
import { Agent } from "@convex-dev/agent";
import { openai } from "@ai-sdk/openai";

const agent = new Agent(components.agent, {
  name: "My Agent",
  languageModel: openai.chat("gpt-4o-mini"),
  instructions: "You are a weather forecaster.",
  tools: { getWeather, getGeocoding },
  maxSteps: 3,
});
```

--------------------------------

### GET /getMessagesByAuthor

Source: https://docs.convex.dev/functions/http-actions

An endpoint designed to retrieve messages, likely filtered by an author. While the exact implementation details for parameters are not provided, it's inferred to use a query parameter for filtering.

```APIDOC
## GET /getMessagesByAuthor

### Description
Retrieves a list of messages, potentially filtered by a specific author. This endpoint demonstrates how to handle GET requests for data retrieval.

### Method
GET

### Endpoint
/getMessagesByAuthor

### Parameters
#### Path Parameters
- No path parameters.

#### Query Parameters
- **author** (string) - Optional - The name of the author to filter messages by. If omitted, all messages might be returned.

#### Request Body
- No request body.

### Request Example
N/A

### Response
#### Success Response (200)
- **messages** (array of objects) - A list of message objects, each containing `id`, `author`, and `body`.

#### Response Example
```json
[
  {
    "id": "123",
    "author": "User 123",
    "body": "Hello world"
  },
  {
    "id": "456",
    "author": "User 123",
    "body": "Another message"
  }
]
```
```

--------------------------------

### Define Convex Database Schema (TypeScript)

Source: https://docs.convex.dev/quickstart/react

Defines the schema for the `tasks` table in your Convex database using TypeScript. This specifies the types for `text` (string) and `isCompleted` (boolean) fields, enabling type checking and runtime enforcement.

```typescript
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  tasks: defineTable({
    text: v.string(),
    isCompleted: v.boolean(),
  }),
});
```

--------------------------------

### Call Component API from an Internal Action in TypeScript

Source: https://docs.convex.dev/components/using

This TypeScript example demonstrates how to directly invoke a component's query API from within a Convex internal action. It shows using `ctx.runQuery` to securely fetch data from a component's sandboxed environment, maintaining reactivity and Convex's function rules.

```typescript
import { internalAction } from "./_generated/server";
import { components } from "./_generated/api";

export const myAction = internalAction({
  args: { threadId: v.string() },
  handler: async (ctx, args) => {
    // Call the component's API to get the thread status.
    const { status } = await ctx.runQuery(components.agent.threads.getThread, {
      threadId: args.threadId,
    });
    //...
  }
});
```

--------------------------------

### Token Bucket Rate Limiting for Global Token Usage

Source: https://docs.convex.dev/agents/rate-limiting

Configures a token bucket rate limiter for global token usage, allowing 100,000 tokens per minute. This ensures overall API limits are not exceeded, even during multi-step requests.

```typescript
globalTokenUsage: { kind: "token bucket", period: MINUTE, rate: 100_000 },
```

--------------------------------

### Define and Use Agent with Convex and OpenAI

Source: https://context7_llms

Creates a support agent using Convex Agent component with GPT-4o-mini model, defines tools for business logic, and demonstrates creating a new thread with initial prompt. Shows how to use agents within Convex actions alongside other business logic, with automatic message history persistence.

```typescript
import { Agent } from "@convex-dev/agents";
import { openai } from "@ai-sdk/openai";
import { components } from "./_generated/api";
import { action } from "./_generated/server";

// Define an agent
const supportAgent = new Agent(components.agent, {
  name: "Support Agent",
  chat: openai.chat("gpt-4o-mini"),
  instructions: "You are a helpful assistant.",
  tools: { accountLookup, fileTicket, sendEmail },
});

// Use the agent from within a normal action:
export const createThread = action({
  args: { prompt: v.string() },
  handler: async (ctx, { prompt }) => {
    const { threadId, thread } = await supportAgent.createThread(ctx);
    const result = await thread.generateText({ prompt });
    return { threadId, text: result.text };
  },
});
```

--------------------------------

### Define Convex Project Schema with `defineSchema` in TypeScript

Source: https://docs.convex.dev/api/modules/server

This example demonstrates how to use the `defineSchema` function to define and export the schema for a Convex project. The function takes an object representing the table definitions, typically residing in a `schema.ts` file.

```typescript
export default defineSchema({
  ...
});
```

--------------------------------

### Server Action calling Convex mutation in Next.js

Source: https://docs.convex.dev/client/nextjs/app-router/server-rendering

Demonstrates an inline Server Action that fetches Convex data using fetchQuery and performs mutations with fetchMutation. The example shows a form that creates tasks while revalidating the page path. Requires importing api from @/convex/_generated/api and using the 'use server' directive.

```TypeScript
import { api } from "@/convex/_generated/api";
import { fetchMutation, fetchQuery } from "convex/nextjs";
import { revalidatePath } from "next/cache";

export default async function PureServerPage() {
  const tasks = await fetchQuery(api.tasks.list, { list: "default" });
  async function createTask(formData: FormData) {
    "use server";

    await fetchMutation(api.tasks.create, {
      text: formData.get("text") as string,
    });
    revalidatePath("/example");
  }
  return <form action={createTask}>...</form>;
}
```

--------------------------------

### Integrate Convex Migrations into Production Deployment Workflow (Bash)

Source: https://www.convex.dev/components/migrations

This CLI command illustrates how to incorporate Convex migration execution into a production deployment pipeline. It chains the `npx convex deploy` command with `npx convex run convex/migrations.ts:runAll --prod`, ensuring that all defined migrations are run after a successful build and deployment. This guarantees that your database schema is updated correctly as part of your application's release process.

```bash
npx convex deploy --cmd 'npm run build' && npx convex run convex/migrations.ts:runAll --prod
```

--------------------------------

### Fixed Window Rate Limiting for Messages

Source: https://docs.convex.dev/agents/rate-limiting

Configures a fixed window rate limiter for messages, allowing 1 message every 5 seconds per user with a burst capacity of 2. This prevents spam and rapid-fire requests.

```typescript
// export const rateLimiter = new RateLimiter(components.rateLimiter, {
sendMessage: { kind: "fixed window", period: 5 * SECOND, rate: 1, capacity: 2 }
```

--------------------------------

### Filter Documents with AND Operator - TypeScript/JavaScript

Source: https://context7_llms

Combines multiple filter conditions using the and() operator to find documents matching all conditions. The example finds users named 'Alex' who are at least 18 years old by combining equality and comparison filters.

```typescript
// Get all users named "Alex" whose age is at least 18.
const adultAlexes = await ctx.db
  .query("users")
  .filter((q) =>
    q.and(q.eq(q.field("name"), "Alex"), q.gte(q.field("age"), 18))
  )
  .collect();
```

--------------------------------

### Viewing Convex Data from the Command Line (Shell)

Source: https://context7_llms

This snippet provides a command-line instruction to display the contents of a specific table in your Convex project. It utilizes the `npx convex data` command, which is part of the Convex CLI. This is a convenient way to inspect your data directly from your terminal.

```shell
npx convex data [table]
```

--------------------------------

### Throwing an Error on Rate Limit Exceedance (JavaScript)

Source: https://convex.dev/components/rate-limiter

Instead of returning an `ok` status, this example shows how to configure the `limit` function to automatically throw a `ConvexError` when the rate limit is hit. The error includes `RateLimitError` data with details like `kind`, `name`, and `retryAfter`.

```javascript
await rateLimiter.limit(ctx, "failedLogins", { key: userId, throws: true });
```

--------------------------------

### Define Convex Action Using Custom Environment with fetch

Source: https://docs.convex.dev/functions/actions

Demonstrates defining a Convex action that runs in Convex's default custom JavaScript environment, which supports fetch natively. This approach is faster than Node.js runtime as it avoids cold starts and can be defined in the same file as other Convex functions.

```TypeScript
import { action } from "./\_generated/server";

export const doSomething = action({
  args: {},
  handler: async () => {
    const data = await fetch("https://api.thirdpartyservice.com");
    // do something with data
  },
});
```

--------------------------------

### Follow Document References with get in Convex

Source: https://docs.convex.dev/database/document-ids

Demonstrates following a reference from one document to another by using the embedded ID to fetch the related document. This retrieves the document that is referenced by the ID field.

```typescript
const user = await ctx.db.get("books", book.ownerId);
```

--------------------------------

### Initialize ConvexHttpClient in Browser

Source: https://context7_llms

Creates a ConvexHttpClient instance to connect to Convex Cloud from browser-based applications. Requires a Convex cloud address typically loaded from environment variables. This client enables querying and mutation operations from the frontend.

```typescript
import { ConvexHttpClient } from "convex/browser";
// typically loaded from an environment variable
const address = "https://small-mouse-123.convex.cloud";
const convex = new ConvexHttpClient(address);
```

--------------------------------

### Get Current Auth Claims - TypeScript

Source: https://docs.convex.dev/api/classes/browser.BaseConvexClient

Retrieves the current JSON Web Token (JWT) authentication token and its decoded claims. The method returns an object containing the token and decoded claims, or undefined if no token is available.

```TypeScript
/**
 *  **getCurrentAuthClaims**(): `undefined` | { `token`: `string` ; `decoded`: `Record`<`string`, `any`> }
 * @returns Get the current JWT auth token and decoded claims.
 */
```

--------------------------------

### Query Result Data Structure

Source: https://docs.convex.dev/understanding

Example JSON response from a Convex query function showing the structure of returned task objects. Demonstrates the data format that clients receive and how Convex maintains consistency when this data is updated through mutations.

```json
[
  { "_id": "e4g", "title": "Grocery shopping", "complete": false },
  { "_id": "u9v", "title": "Plant new flowers", "complete": false }
]
```

--------------------------------

### Paginated Query with Additional Arguments in TypeScript

Source: https://docs.convex.dev/database/pagination

Extends the basic paginated query to accept additional arguments beyond `paginationOpts`. This example demonstrates filtering messages by author while maintaining pagination functionality using cursor-based pagination.

```typescript
export const listWithExtraArg = query({
  args: { paginationOpts: paginationOptsValidator, author: v.string() },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("messages")
      .filter((q) => q.eq(q.field("author"), args.author))
      .order("desc")
      .paginate(args.paginationOpts);
  },
});
```

--------------------------------

### Token Bucket Rate Limiting for Global Messages

Source: https://docs.convex.dev/agents/rate-limiting

Implements a token bucket rate limiter for global message sending, allowing up to 1000 messages per minute globally. This helps stay within API limits by continuously accruing tokens.

```typescript
globalSendMessage: { kind: "token bucket", period: MINUTE, rate: 1_000 },
```

--------------------------------

### Run Bun Script (Shell)

Source: https://context7_llms

Executes the `index.ts` script using the Bun runtime. This command runs the client-side code that connects to Convex and logs the fetched data.

```shell
bun index.ts
```

--------------------------------

### GenericDatabaseReader Interface

Source: https://context7_llms

The GenericDatabaseReader is the main interface for reading from the Convex database within query functions. It provides access to database documents and system tables with two primary entry points: get() for single document retrieval and query() for building complex queries.

```APIDOC
## Interface GenericDatabaseReader

### Description
An interface to read from the database within Convex query functions. Extends BaseDatabaseReader and provides typed access to your data model.

### Type Parameters
- **DataModel** - extends GenericDataModel. Your application's data model definition.

### Hierarchy
BaseDatabaseReader<DataModel>  GenericDatabaseReader  GenericDatabaseWriter

### Properties
#### system
- **Type**: BaseDatabaseReader<SystemDataModel>
- **Description**: An interface to read from the system tables within Convex query functions.
- **Entry Points**:
  - get(): Fetch a single document by its GenericId
  - query(): Start building a query

### Methods
#### get<TableName>(table, id)
- **Description**: Fetch a single document from the database by its GenericId.
- **Parameters**:
  - table (NonUnion<TableName>) - The name of the table to fetch from
  - id (GenericId<TableName>) - The GenericId of the document
- **Returns**: Promise<null | DocumentByName<DataModel, TableName>>
- **Inherited from**: BaseDatabaseReader

#### query<TableName>(table)
- **Description**: Start building a query on a specific table.
- **Parameters**:
  - table (NonUnion<TableName>) - The table name to query
- **Returns**: Query builder for constructing complex queries

### Notes
- If using code generation, use the typed DatabaseReader from convex/_generated/server.d.ts
- Entry points: get() and query()
- Defined in: server/database.ts:128
```

--------------------------------

### Define Convex Database Schema

Source: https://context7_llms

Creates a schema definition for a Convex database using defineSchema and defineTable. This example shows a messages table with user references and string body content. Schemas are optional but provide type safety and data validation for database documents.

```typescript
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

// @snippet start schema
export default defineSchema({
  messages: defineTable({
    author: v.id("users"),
    body: v.string(),
  }),
});
```

--------------------------------

### Direct Integration of ConvexProviderWithClerk in React/TSX

Source: https://context7_llms

This snippet illustrates the direct integration of `ConvexProviderWithClerk` within a React component's render method. It sets up the Convex client and provides authentication context using a `useAuth` hook. While functional, later examples demonstrate a more decoupled approach where `ConvexClientProvider` is used, often wrapped by `ClerkProvider` in a root layout.

```tsx
       <ConvexProviderWithClerk client={convex} useAuth={useAuth}>
         {children}
       </ConvexProviderWithClerk>
     )
   }
```

--------------------------------

### ConvexClient with Untyped API: Real-time Updates in JavaScript

Source: https://docs.convex.dev/client/javascript

Illustrates using ConvexClient with an untyped API object ('anyApi') when the Convex function source code is not in the same project. This example subscribes to messages and periodically sends new messages.

```typescript
import { ConvexClient } from "convex/browser";
import { anyApi } from "convex/server";

const CONVEX_URL = "http://happy-otter-123";
const client = new ConvexClient(CONVEX_URL);
client.onUpdate(anyApi.messages.list, {}, (messages) =>
  console.log(messages.map((msg) => msg.body)),
);
setInterval(
  () =>
    client.mutation(anyApi.messages.send, {
      body: `hello at ${new Date()}`,
      author: "me",
    }),
  5000,
);
```

--------------------------------

### Install Convex Android Client and Kotlin Serialization

Source: https://docs.convex.dev/client/android

Add the Convex Android client library and Kotlinx serialization dependency to your app's build.gradle[.kts] file. Ensure the Kotlin serialization plugin is also applied. Sync Gradle after making these changes.

```kotlin
plugins {
    // ... existing plugins
    kotlin("plugin.serialization") version "1.9.0"
}

dependencies {
    // ... existing dependencies
    implementation("dev.convex:android-convexmobile:0.4.1@aar") {
        isTransitive = true
    }
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.3")
}
```

--------------------------------

### Run Node.js Script to Fetch Data

Source: https://context7_llms

Execute the `script.js` file using Node.js. This will run the client-side code that queries the Convex backend and prints the fetched task list to the terminal.

```bash
node script.js
```

--------------------------------

### Export Convex Data via Command Line

Source: https://docs.convex.dev/database/import-export/export

Exports Convex database data to a specified local directory using the npx command line tool. The command downloads all data as files to the specified path. Requires Convex CLI to be installed and configured.

```bash
npx convex export --path ~/Downloads
```

--------------------------------

### Register Multiple LaunchDarkly Routes in Convex HTTP

Source: https://www.convex.dev/components/launchdarkly

Configure HTTP routes for multiple LaunchDarkly component instances in your Convex HTTP handler. Each component gets a dedicated webhook path to receive LaunchDarkly integration events.

```typescript
// convex/http.ts
import { httpRouter } from "convex/server";
import { registerRoutes } from "@convex-dev/launchdarkly";
import { components } from "./_generated/api";

const http = httpRouter();
registerRoutes(components.first, http, "/ld/first");
registerRoutes(components.second, http, "/ld/second");

export default http;
```

--------------------------------

### Get and List Convex File Metadata with Queries (TypeScript)

Source: https://context7_llms

This TypeScript snippet demonstrates how to retrieve file metadata within Convex queries. It shows fetching metadata for a specific storage ID using `ctx.db.system.get("_storage", storageId)` and listing all file metadata by calling `ctx.db.system.query("_storage").collect()`.

```typescript
import { v } from "convex/values";
import { query } from "./_generated/server";

export const getMetadata = query({
  args: {
    storageId: v.id("_storage"),
  },
  handler: async (ctx, args) => {
    return await ctx.db.system.get("_storage", args.storageId);
  },
});

export const listAllFiles = query({
  args: {},
  handler: async (ctx) => {
    // You can use .paginate() as well
    return await ctx.db.system.query("_storage").collect();
  },
});
```

--------------------------------

### Create LLM Tool for Direct Generation (JavaScript)

Source: https://context7_llms

This code defines a Convex `createTool` function that allows an agent to ask a question to an LLM directly, without creating a separate thread. It takes a message, generates text using a system prompt and the current generation's messages, and returns the LLM's response. This is suitable for simple, stateless LLM queries.

```javascript
const llmTool = createTool({
  description: "Ask a question to some LLM",
  args: z.object({
    message: z.string().describe("The message to ask the LLM")
  }),
  handler: async (ctx, args): Promise<string> => {
    const result = await generateText({
      system: "You are a helpful assistant.",
      // Pass through all messages from the current generation
      prompt: [...options.messages, { role: "user", content: args.message }],
      model: myLanguageModel,
    });
    return result.text;
  },
});
```

--------------------------------

### Create and Initialize Thread with Prompt

Source: https://stack.convex.dev/ai-agents

Start a new conversation thread by calling createThread on the agent, which generates a unique threadId and thread object. Then use the thread to generate an initial text response from the provided prompt.

```TypeScript
export const createThread = action({
  args: { prompt: v.string() },
  handler: async (ctx, { prompt }) => {
    const { threadId, thread } = await supportAgent.createThread(ctx, {});
    const result = await thread.generateText({ prompt });
    return { threadId, text: result.text };
  }
});
```

--------------------------------

### Get Client URL - TypeScript

Source: https://docs.convex.dev/api/classes/browser.BaseConvexClient

This accessor retrieves the client's address (URL), useful for creating new client instances. It may return a canonicalized version of the original address. The address returned is a string representing the Convex deployment URL.

```TypeScript
/**
 *  `get` **url**(): `string`
 * @returns The address for this client, useful for creating a new client.
 * Not guaranteed to match the address with which this client was constructed: it may be canonicalized.
 */
```

--------------------------------

### Get Messages By Counterparty

Source: https://www.convex.dev/components/twilio

Retrieve all messages to and from a particular phone number in a single query. This method provides a conversation view between your app and a specific counterparty phone number.

```TypeScript
export const getMessagesByCounterparty = query({
  args: { from: v.string() },
  handler: async (ctx, args) => {
    return await twilio.getMessagesByCounterparty(ctx, args);
  },
});
```

--------------------------------

### Call Convex API (Python)

Source: https://docs.convex.dev/http-api

This Python example shows how to interact with the Convex API using the `requests` library. It defines the API endpoint URL, request headers, and the JSON body containing the function path, arguments, and desired format for the POST request.

```python
import requests

url = "https://acoustic-panther-728.convex.cloud/api/query"
headers = {"accept": "application/json"}
body = {"path": "messages:list", "args": {}, "format": "json"}

response = requests.post(url, headers=headers, json=body)
```

--------------------------------

### GET /storage/metadata/{storageId}

Source: https://docs.convex.dev/api/interfaces/server.StorageWriter

Retrieves metadata for a file stored in Convex storage using its unique identifier. If the file is found, it returns a 'FileMetadata' object; otherwise, it returns 'null'.

```APIDOC
## GET /storage/metadata/{storageId}

### Description
Retrieves metadata for a file stored in Convex storage by its `storageId`. Returns a `FileMetadata` object if the file is found, otherwise returns `null`.

### Method
GET

### Endpoint
/storage/metadata/{storageId}

### Parameters
#### Path Parameters
- **storageId** (string) - Required - The unique ID of the file (equivalent to Convex's `StorageId`).

### Request Example
N/A (GET request, parameters in path/query)

### Response
#### Success Response (200)
- **FileMetadata** (object | null) - Metadata object for the file, or `null` if not found. Specific fields of `FileMetadata` are not detailed here but typically include `id`, `name`, `size`, `contentType`, and `creationTime`.

#### Response Example
```json
{
  "id": "storageId_12345",
  "name": "document.pdf",
  "size": 102400,
  "contentType": "application/pdf",
  "creationTime": "2023-10-27T10:00:00Z"
}
```
OR
```json
null
```
```

--------------------------------

### Base Client Configuration

Source: https://docs.convex.dev/api/modules/browser

Core configuration options for Convex client initialization. Provides common settings inherited by all Convex client implementations.

```APIDOC
## BaseConvexClientOptions

### Description
Base configuration interface for all Convex client types.

### Purpose
Provides common configuration options shared across ConvexClient, ConvexHttpClient, and other client implementations.

### Usage
Extended by specific client option types like ConvexClientOptions to provide platform-specific configurations.

### Related Classes
- **ConvexClient** - WebSocket-based client using BaseConvexClientOptions
- **ConvexHttpClient** - HTTP-based client using BaseConvexClientOptions
- **ConvexClientOptions** - Extended configuration for React clients
```

--------------------------------

### Split text into chunks using LangChain RecursiveCharacterTextSplitter

Source: https://stack.convex.dev/pinecone-and-embeddings

Demonstrates how to break up source data into bite-sized chunks for embedding models using LangChain's RecursiveCharacterTextSplitter. This helps limit data passed to embedding models and makes embeddings more targeted. The example splits page content into chunks with configurable size and includes metadata about line numbers.

```javascript
import { RecursiveCharacterTextSplitter } from "langchain/text_splitter";

const textSplitter = new RecursiveCharacterTextSplitter({
  chunkSize: ChunkSize,
});
const splitTexts = await textSplitter.createDocuments([pageContent]);
const chunks = splitTexts.map((chunk) => ({
  text: chunk.pageContent,
  lines: chunk.metadata.loc.lines,
}));
```

--------------------------------

### Save Single Message Manually with Embedding (Server Action)

Source: https://docs.convex.dev/agents/messages

This example shows how to save a single assistant message manually, including providing an `embedding` object. This is necessary when not using the Agent class and a text embedding model is not configured by default.

```javascript
import { saveMessage } from "@convex-dev/agent";

const { messageId } = await saveMessage(ctx, components.agent, {
  threadId,
  userId,
  message: { role: "assistant", content: result },
  metadata: [{ reasoning, usage, ... }] // See MessageWithMetadata type
  agentName: "my-agent",
  embedding: { vector: [0.1, 0.2, ...], model: "text-embedding-3-small" },
});

```

--------------------------------

### Initialize Convex React Client with Vite Environment Variable

Source: https://docs.convex.dev/client/react/deployment-urls

Initializes the Convex React client using a deployment URL obtained from Vite's environment variables. It requires the `convex/react` package and relies on `import.meta.env.VITE_CONVEX_URL` for the deployment URL.

```javascript
import { ConvexProvider, ConvexReactClient } from "convex/react";

const deploymentURL = import.meta.env.VITE_CONVEX_URL;

const convex = new ConvexReactClient(deploymentURL);
```

--------------------------------

### Set Clerk API Keys in Environment Variables

Source: https://docs.convex.dev/auth/clerk

Environment configuration file for Next.js application that stores Clerk authentication credentials. The publishable key is safe to expose in client code (prefixed with NEXT_PUBLIC_), while the secret key must remain server-side only.

```Bash
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=YOUR_PUBLISHABLE_KEY
CLERK_SECRET_KEY=YOUR_SECRET_KEY
```

--------------------------------

### Defining Rate Limits with Different Strategies (JavaScript)

Source: https://convex.dev/components/rate-limiter

This snippet demonstrates how to initialize the `rateLimiter` by defining various rate limits. It showcases both 'token bucket' and 'fixed window' strategies, including options for rate, period, capacity, and sharding to increase throughput without compromising correctness.

```javascript
rateLimiter.define({
  failedLogins: { kind: "token bucket", rate: 10, period: HOUR },
  llmTokens: { kind: "token bucket", rate: 40000, period: MINUTE, shards: 10 },
  llmRequests: { kind: "fixed window", rate: 1000, period: MINUTE, shards: 10 }
});
```

--------------------------------

### Example Legacy Function Execution Record Log JSON

Source: https://docs.convex.dev/production/integrations/log-streams/legacy-event-schema

Sample JSON structure of a function execution record log from an HTTP action that failed. Shows system fields, execution status, error reason, and performance metrics including execution time. The reason field contains the error message only when status equals failure.

```json
{
  "_topic": "_execution_record",
  "_timestamp": 1695066350531,
  "_functionType": "httpAction",
  "_functionPath": "POST /sendImage",
  "status": "failure",
  "reason": "Unexpected Error: Some error message\n\n  at ....",
  "executionTimeMs": 73
}
```

--------------------------------

### GET /api/json_schemas

Source: https://context7_llms

Retrieves JSON Schemas for all tables in your Convex deployment. The endpoint describes how documents are encoded and includes metadata about table references and special field encodings. Use optional query parameters to include delta metadata or specify output format.

```APIDOC
## GET /api/json_schemas

### Description
Lists all tables in the Convex deployment and describes how documents will be encoded, given as JSON Schema. Returns `$description` tags throughout the schema to describe unintuitive encodings and provide extra information like table references for `Id` fields.

### Method
GET

### Endpoint
/api/json_schemas

### Authentication
- **Authorization** (header) - Required - Format: `Convex <access_key>` where access_key is from "Deploy key" on Convex dashboard

### Query Parameters
- **deltaSchema** (boolean) - Optional - If set to true, include metadata fields returned by document_deltas and list_snapshot (`_ts`, `_deleted`, and `_table`)
- **format** (string) - Optional - Output format for values. Valid values: `json`

### Request Example
```
GET /api/json_schemas?deltaSchema=false&format=json
Authorization: Convex your_access_key_here
```

### Response
#### Success Response (200)
- **tables** (array of objects) - Array of table schemas
  - **name** (string) - Table name
  - **schema** (object) - JSON Schema describing document structure
  - **$description** (string) - Description of table encoding and field references
- **_ts** (number) - Timestamp (included if deltaSchema=true)
- **_deleted** (boolean) - Deletion flag (included if deltaSchema=true)
- **_table** (string) - Table reference (included if deltaSchema=true)

#### Response Example
```json
{
  "tables": [
    {
      "name": "users",
      "schema": {
        "type": "object",
        "properties": {
          "_id": {
            "type": "string",
            "$description": "Unique document identifier"
          },
          "name": {
            "type": "string"
          },
          "email": {
            "type": "string"
          }
        }
      }
    }
  ]
}
```

### Notes
- Requires Professional plan for streaming export support
- Currently a beta feature - provide feedback on Discord
- Authorization uses deployment admin access via Deploy key
- Refer to streaming export documentation for additional details
```

--------------------------------

### Fetch and Display Data with useQuery Hook

Source: https://context7_llms

Use the useQuery hook in pages/index.js to fetch tasks from the Convex backend API. Map over the returned tasks array to render each task's text in the UI, with real-time reactivity from the Convex client.

```javascript
import { useQuery } from "convex/react";
import { api } from "../convex/_generated/api";

export default function Home() {
  const tasks = useQuery(api.tasks.get);
  return (
    <main className="flex min-h-screen flex-col items-center p-24">
      {tasks?.map(({ _id, text }) => (
        <div key={_id}>{text}</div>
      ))}
    </main>
  );
}
```

--------------------------------

### Optimize Convex Queries with Pagination in TypeScript

Source: https://docs.convex.dev/understanding/best-practices

This example illustrates how to handle potentially large result sets by using pagination in Convex. The '' code fetches all watched movies for a user, which can be inefficient. The '' code demonstrates a more scalable approach using `paginate()` with an index and ordering to retrieve data in smaller, manageable chunks, ideal for displaying large lists.

```ts
//  -- potentially unbounded
const watchedMovies = await ctx.db
  .query("watchedMovies")
  .withIndex("by_user", (q) => q.eq("user", "Tom"))
  .collect();
```

```ts
//  -- using pagination, showing recently watched movies first
const watchedMovies = await ctx.db
  .query("watchedMovies")
  .withIndex("by_user", (q) => q.eq("user", "Tom"))
  .order("desc")
  .paginate(paginationOptions);
```

--------------------------------

### Custom Optimistic Message Update with Arguments (React)

Source: https://docs.convex.dev/agents/messages

This example demonstrates a more customized optimistic update where `optimisticallySendMessage` is used within a custom update function. This allows for dynamic argument mapping for the `threadId` and `prompt` based on the mutation's arguments.

```javascript
import { optimisticallySendMessage } from "@convex-dev/agent/react";

const sendMessage = useMutation(
  api.chatStreaming.streamStoryAsynchronously,
).withOptimisticUpdate(
  (store, args) => {
    optimisticallySendMessage(api.chatStreaming.listThreadMessages)(store, {
      threadId:
      prompt: /* change your args into the user prompt. */,
    })
  }
);

```

--------------------------------

### Initialize RateLimiter with Multiple Strategies in TypeScript

Source: https://context7_llms

Creates a new RateLimiter instance with four rate limiting rules: fixed window for per-user message sending, token bucket for global message limits, and token bucket strategies for per-user and global token usage tracking. This configuration prevents spam, controls API quota consumption, and manages LLM token bandwidth allocation.

```typescript
import { MINUTE, RateLimiter, SECOND } from "@convex-dev/rate-limiter";
import { components } from "./_generated/api";

export const rateLimiter = new RateLimiter(components.rateLimiter, {
  sendMessage: {
    kind: "fixed window",
    period: 5 * SECOND,
    rate: 1,
    capacity: 2,
  },
  globalSendMessage: { kind: "token bucket", period: MINUTE, rate: 1_000 },
  tokenUsagePerUser: {
    kind: "token bucket",
    period: MINUTE,
    rate: 2000,
    capacity: 10000,
  },
  globalTokenUsage: { kind: "token bucket", period: MINUTE, rate: 100_000 },
});
```

--------------------------------

### Initialize ConvexReactClient with Convex Cloud Address

Source: https://context7_llms

Create a new ConvexReactClient instance by providing your Convex deployment URL. This client enables communication between React applications and your Convex backend. The address is typically loaded from environment variables for security and portability.

```TypeScript
import { ConvexReactClient } from "convex/react";

// typically loaded from an environment variable
const address = "https://small-mouse-123.convex.cloud"
const convex = new ConvexReactClient(address);
```

--------------------------------

### Implement Checkbox Counter Mutation and Query

Source: https://www.convex.dev/components/sharded-counter

Example mutation that increments a checkbox counter when a checkbox is checked, and a query that retrieves the current count. Demonstrates atomic operations and real-time counter updates in Convex.

```typescript
export const checkBox = mutation({
  args: { i: v.number() },
  handler: async (ctx, args) => {
    const checkbox = await ctx.db
      .query("checkboxes")
      .withIndex("i", (q) => q.eq("i", args.i))
      .unique();
    if (!checkbox.isChecked) {
      await ctx.db.patch(checkbox._id, { isChecked: true });
      // Here we increment the number of checkboxes.
      await numCheckboxes.inc(ctx);
    }
  }
});
export const getCount = query({
  args: {},
  handler: async (ctx, _args) => {
    return await numCheckboxes.count(ctx);
  }
});
```

--------------------------------

### Define Cron Jobs with Multiple Scheduling Methods in TypeScript

Source: https://context7_llms

This example demonstrates how to define cron jobs in a convex/crons.ts file using the Convex cronJobs API. It shows three scheduling approaches: interval-based execution (every minute), monthly scheduling with UTC time specification, and traditional cron syntax. Each cron job requires a unique identifier, schedule configuration, function reference, and optional arguments to pass to the scheduled function.

```typescript
import { cronJobs } from "convex/server";
import { internal } from "./_generated/api";

const crons = cronJobs();

crons.interval(
  "clear messages table",
  { minutes: 1 }, // every minute
  internal.messages.clearAll,
);

crons.monthly(
  "payment reminder",
  { day: 1, hourUTC: 16, minuteUTC: 0 }, // Every month on the first day at 8:00am PST
  internal.payments.sendPaymentEmail,
  { email: "my_email@gmail.com" }, // argument to sendPaymentEmail
);

// An alternative way to create the same schedule as above with cron syntax
crons.cron(
  "payment reminder duplicate",
  "0 16 1 * *",
  internal.payments.sendPaymentEmail,
  { email: "my_email@gmail.com" }, // argument to sendPaymentEmail
);

export default crons;
```

--------------------------------

### Query All Documents with db.query in TypeScript

Source: https://docs.convex.dev/database/reading-data

Retrieves all documents from a specified table using the db.query method. The example shows a basic query on the tasks table that collects all results. The collect() method executes the query and returns an array of documents.

```typescript
import { query } from "./_generated/server";

export const listTasks = query({
  args: {},
  handler: async (ctx) => {
    const tasks = await ctx.db.query("tasks").collect();
    // do something with `tasks`
  },
});
```

--------------------------------

### Seed Development Deployment from Full Backup or Single Table

Source: https://docs.convex.dev/database/import-export/import

These commands demonstrate two methods for seeding a development Convex deployment. The first uses a full backup ZIP file, while the second imports data into a specific table from a JSONLines or CSV file. Both are useful for populating a dev environment with sample data.

```bash
# full backup - exported from prod or another dev deployment.
npx convex import seed_data.zip
```

```bash
# Import single table from jsonl/csv
npx convex import --table <table name> data.jsonl
```

--------------------------------

### Execute a Convex Function Handle with `runMutation` or Scheduler

Source: https://docs.convex.dev/components/authoring

After obtaining a function handle as a string, this TypeScript example shows how to cast it back to a `FunctionHandle<"mutation">` and execute it. It illustrates both immediate execution using `ctx.runMutation` and scheduled asynchronous execution using `ctx.scheduler.runAfter`, maintaining argument and return value validation.

```typescript
const handle = handleString as FunctionHandle<"mutation">;

const result = await ctx.runMutation(handle, args);
// or run it asynchronously via the scheduler:
await ctx.scheduler.runAfter(0, handle, args);
```

--------------------------------

### Authenticated and Unauthenticated Helper Components

Source: https://docs.convex.dev/auth/auth0

Use Authenticated, Unauthenticated, and AuthLoading helper components as convenient wrappers around useConvexAuth hook. These components render their children conditionally based on authentication state without manual state checking.

```TypeScript
import { Authenticated, Unauthenticated, AuthLoading } from "convex/react";

function App() {
  return (
    <>
      <Authenticated>Logged in</Authenticated>
      <Unauthenticated>Logged out</Unauthenticated>
      <AuthLoading>Still loading</AuthLoading>
    </>
  );
}
```

--------------------------------

### Initialize ConvexHttpClient for Browser Applications

Source: https://docs.convex.dev/api/modules/browser

This code snippet illustrates how to create and initialize a `ConvexHttpClient` instance to connect to the Convex Cloud from a browser. It imports the client from `convex/browser` and configures it with a Convex deployment address, which is typically stored in an environment variable. This client is designed for applications that do not utilize React.

```javascript
import { ConvexHttpClient } from "convex/browser";

// typically loaded from an environment variable
const address = "https://small-mouse-123.convex.cloud";
const convex = new ConvexHttpClient(address);
```

--------------------------------

### Insert Data with Database Context in Convex TypeScript

Source: https://docs.convex.dev/functions/mutation-functions

Example mutation showing how to use ctx.db.insert() to write data to the database. Uses async/await pattern since database operations return promises. Takes a text argument and inserts it into the tasks table.

```typescript
import { mutation } from "./\u005fgenerated/server";
import { v } from "convex/values";

export const addItem = mutation({
  args: { text: v.string() },
  handler: async (ctx, args) => {
    await ctx.db.insert("tasks", { text: args.text });
  },
});
```

--------------------------------

### List Environment Variables via Fetch API

Source: https://docs.convex.dev/deployment-platform-api

This JavaScript snippet demonstrates how to fetch a list of environment variables for a Convex deployment. It requires a valid Convex deployment token in the Authorization header. The response is expected to be in JSON format.

```javascript
const token = "ey...0=";
const response = await fetch(
  "https://happy-otter-123.convex.cloud/api/v1/list_environment_variables"
  {
    headers: {
      Authorization: `Convex ${token}`,
    },
  },
);
console.log(await response.json());
```

--------------------------------

### Get Single Message by SID

Source: https://www.convex.dev/components/twilio

Retrieve a specific message using its Twilio message SID. This query accepts a string SID argument and returns the matching message from the database.

```TypeScript
export const getMessageBySid = query({
  args: { sid: v.string() },
  handler: async (ctx, args) => {
    return await twilio.getMessageBySid(ctx, args);
  },
});
```

--------------------------------

### Optimistically Insert Item into Convex Paginated Query using `insertAtPosition`

Source: https://context7_llms

This example demonstrates how to use the `insertAtPosition` helper within a Convex `useMutation().withOptimisticUpdate` block. It allows for the optimistic insertion of a new item (e.g., a task) into a locally paginated query, ensuring it is placed according to the specified `sortOrder` and `sortKeyFromItem`. For this to work correctly, the server-side query must utilize the same sorting logic.

```typescript
const createTask = useMutation(api.tasks.create)
  .withOptimisticUpdate((localStore, mutationArgs) => {
  insertAtPosition({
    paginatedQuery: api.tasks.listByPriority,
    argsToMatch: { listId: mutationArgs.listId },
    sortOrder: "asc",
    sortKeyFromItem: (item) => [item.priority, item._creationTime],
    localQueryStore: localStore,
    item: {
      _id: crypto.randomUUID() as Id<"tasks">,
      _creationTime: Date.now(),
      title: mutationArgs.title,
      completed: false,
      priority: mutationArgs.priority,
    },
  });
});
```

--------------------------------

### List all log streams via Convex Deployment API

Source: https://context7_llms

Retrieves a list of configurations for all existing log streams within a Convex deployment. This provides a comprehensive view of all logging destinations and their settings.

```HTTP
GET 
/list_log_streams
```

--------------------------------

### GET /api/document_deltas

Source: https://context7_llms

The document_deltas endpoint walks the change log of documents to find new, updated, and deleted documents in the order of their mutations. Use this endpoint for incremental synchronization by providing a cursor from a previous snapshot or delta query.

```APIDOC
## GET /api/document_deltas

### Description
Walks the change log of documents to find new, updated, and deleted documents in the order of their mutations. Deletions are represented as JSON objects with fields `_id`, `_ts`, and `_deleted: true`.

### Method
GET

### Endpoint
/api/document_deltas

### Parameters
#### Query Parameters
- **cursor** (int) - Required - Database timestamp after which to continue streaming document deltas. Initial value is the `snapshot` field returned from list_snapshot.
- **tableName** (string) - Optional - If provided, filters the document deltas to a table. If omitted, provides deltas across all tables.
- **format** (string) - Optional - Output format for values. Valid values: `json`

### Response
#### Success Response (200)
- **values** (List[ConvexValue]) - List of convex values in the requested format. Each value includes extra fields for `_ts` and `_table`. Deletions include a field `_deleted`.
- **hasMore** (boolean) - True if there are more pages to the snapshot.
- **cursor** (int) - A value that represents the database timestamp at the end of the page. Pass to subsequent calls to document_deltas.

### Response Example
{
  "values": [
    {
      "_id": "document_id",
      "_ts": 1234567890,
      "_table": "table_name",
      "field": "value"
    },
    {
      "_id": "deleted_document_id",
      "_ts": 1234567891,
      "_table": "table_name",
      "_deleted": true
    }
  ],
  "hasMore": false,
  "cursor": 1234567891
}

### Usage Example (Pseudocode)
```
def delta_sync(delta_cursor):
    delta_values = []
    while True:
        result = api.document_deltas(cursor)
        delta_values.extend(result.values)
        cursor = result.cursor
        if !hasMore:
            break
    return (delta_values, delta_cursor)

(snapshot_values, delta_cursor) = list_full_snapshot()
(delta_values, delta_cursor) = delta_sync(delta_cursor)
# Save delta_cursor for the next sync
```
```

--------------------------------

### View all Convex CLI commands

Source: https://docs.convex.dev/using/cli

Displays a comprehensive list of available Convex CLI commands and their usage details directly in the terminal.

```bash
npx convex
```

--------------------------------

### Save and Return Stream Deltas with Convex Agent streamText

Source: https://context7_llms

This example shows how to configure the Convex agent's `streamText` function to save stream deltas immediately by passing `{ saveStreamDeltas: { returnImmediately: true } }` in the options. This allows the function to return a result that can be iterated over live or converted into an HTTP response suitable for UI message streaming.

```typescript
const result = await agent.streamText(
  ctx,
  { threadId },
  { prompt },
  { saveStreamDeltas: { returnImmediately: true } },
);

return result.toUIMessageStreamResponse();
```

--------------------------------

### Define Rate Limit Rules with Fixed Window and Token Bucket

Source: https://convex.dev/components/rate-limiter

Configure rate limit rules using either fixed window or token bucket algorithms. Fixed window limits actions per period globally, while token bucket allows per-user limits with burst capacity. This example shows both patterns for signup and messaging scenarios.

```typescript
import { RateLimiter, MINUTE, HOUR } from "@convex-dev/rate-limiter";
import { components } from "./_generated/api";

const rateLimiter = new RateLimiter(components.rateLimiter, {
  // One global / singleton rate limit, using a "fixed window" algorithm.
  freeTrialSignUp: {
    kind: "fixed window",
    rate: 100,
    period: HOUR
  },
  // A per-user limit, allowing one every ~6 seconds.
  // Allows up to 3 in quick succession if they haven't sent many recently.
  sendMessage: {
    kind: "token bucket",
    rate: 10,
    period: MINUTE,
    capacity: 3
  }
});
```

--------------------------------

### Generate and Store Files in Action

Source: https://context7_llms

Demonstrates a complete workflow for generating files from external APIs and storing them in Convex. Fetches an image, stores it using storage.store(), receives a storage ID, and persists the ID in the database via an internal mutation.

```typescript
import { action, internalMutation, query } from "./_generated/server";
import { internal } from "./_generated/api";
import { v } from "convex/values";
import { Id } from "./_generated/dataModel";

export const generateAndStore = action({
  args: { prompt: v.string() },
  handler: async (ctx, args) => {
    // Not shown: generate imageUrl from `prompt`
    const imageUrl = "https://....";

    // Download the image
    const response = await fetch(imageUrl);
    const image = await response.blob();

    // Store the image in Convex
    const storageId: Id<"_storage"> = await ctx.storage.store(image);

    // Write `storageId` to a document
    await ctx.runMutation(internal.images.storeResult, {
      storageId,
      prompt: args.prompt,
    });
  },
});

export const storeResult = internalMutation({
  args: {
    storageId: v.id("_storage"),
    prompt: v.string(),
  },
  handler: async (ctx, args) => {
    const { storageId, prompt } = args;
    await ctx.db.insert("images", { storageId, prompt });
  },
});
```

--------------------------------

### Call Convex Function via POST HTTP Endpoint

Source: https://context7_llms

This snippet demonstrates how to execute an arbitrary Convex function by sending an HTTP POST request to the `/api/run/{functionIdentifier}` endpoint. It includes examples in Shell (curl), NodeJS (fetch), and Python (requests), showing how to pass arguments and specify the output format in a JSON request body.

```Shell
curl https://acoustic-panther-728.convex.cloud/api/run/messages/list \
   -d '{"args": {}, "format": "json"}' \
   -H "Content-Type: application/json"
```

```NodeJS
const url = "https://acoustic-panther-728.convex.cloud/api/run/messages/list";
const request = { args: {}, format: "json" };

const response = fetch(url, {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify(request),
});
```

```Python
import requests

url = "https://acoustic-panther-728.convex.cloud/api/run/messages/list"
headers = {"accept": "application/json"}
body = {"args": {}, "format": "json"}

response = requests.get(url, headers=headers, body=json)
```

--------------------------------

### Configure NPM scripts for Convex testing with Vitest

Source: https://docs.convex.dev/testing/convex-test

Add these scripts to your `package.json` file to easily run Vitest tests. These scripts provide options for standard testing, single-run testing, debugging, and generating code coverage reports for your Convex application.

```json
"scripts": {
  "test": "vitest",
  "test:once": "vitest run",
  "test:debug": "vitest --inspect-brk --no-file-parallelism",
  "test:coverage": "vitest run --coverage --coverage.reporter=text"
}
```

--------------------------------

### Subscribe to real-time query results with Publisher in Swift

Source: https://context7_llms

Subscribes to a Convex query using the subscribe method which returns a Combine Publisher. The example demonstrates consuming query results in a SwiftUI View using @State and the .task modifier, with automatic UI updates when backend data changes.

```swift
struct ColorList: View {
  @State private var colors: [String] = []

  var body: some View {
    List {
      ForEach(colors, id: \.self) { color in
        Text(color)
      }
    }.task {
      let latestColors = convex.subscribe(to: "colors:get", yielding: [String].self)
        .replaceError(with: [])
        .values
      for await colors in latestColors {
        self.colors = colors
      }
    }
  }
}
```

--------------------------------

### Implement Clerk Middleware in Next.js App Router

Source: https://context7_llms

This TypeScript file defines Clerk's middleware for a Next.js application, enabling access to user authentication state across routes. It uses `clerkMiddleware()` to process incoming requests and applies a matcher to include API routes while skipping static files. This setup is fundamental for protecting routes and managing user sessions with Clerk.

```typescript
import { clerkMiddleware } from '@clerk/nextjs/server'

export default clerkMiddleware()

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
}
```

--------------------------------

### Test Migration with Vitest and convexTest

Source: https://www.convex.dev/components/migrations

Test a Convex migration using Vitest and the convexTest utility. This registers the migrations component, inserts sample data, runs the migration to completion, and asserts the migration results. Demonstrates complete migration testing workflow including data setup, execution, and verification.

```TypeScript
import { test } from "vitest";
import { convexTest } from "convex-test";
import component from "@convex-dev/migrations/test";
import { runToCompletion } from "@convex-dev/migrations";
import { components, internal } from "./\_generated/api";
import schema from "./schema";

test("test setDefaultValue migration", async () => {
  const t = convexTest(schema);
  // Register the component in the test instance
  component.register(t);
  await t.run(async (ctx) => {
    // Add sample data to migrate
    await ctx.db.insert("myTable", { optionalField: undefined });
    // Run the migration to completion
    const migrationToTest = internal.example.setDefaultValue;
    await runToCompletion(ctx, components.migrations, migrationToTest);
    // Assert that the migration was successful by checking the data
    const docs = await ctx.db.query("myTable").collect();
    expect(docs.every((doc) => doc.optionalField !== undefined)).toBe(true);
  });
});
```

--------------------------------

### Cancel Workpool Job by ID

Source: https://www.convex.dev/components/workpool

Convex mutation to cancel a specific Workpool job using its ID. This prevents the job from starting or being retried, but does not stop work already in progress.

```typescript
export const cancelWork = mutation({
  args: { id: vWorkIdValidator },
  handler: async (ctx, args) => {
    // You can cancel the work, if it hasn't finished yet.
    await pool.cancel(ctx, args.id);
  }
});
```

--------------------------------

### Create Composable UI to Display Tasks with Convex

Source: https://context7_llms

This Kotlin Composable function `Tasks` displays a list of `Task` objects fetched from Convex using a `LazyColumn`. It subscribes to the `tasks:get` query from a `ConvexClient` and updates the UI reactively. The `LaunchedEffect` ensures data fetching occurs when the composable enters the composition.

```kotlin
    @Composable
    fun Tasks(client: ConvexClient, modifier: Modifier = Modifier) {
        var tasks: List<Task> by remember { mutableStateOf(listOf()) }
        LaunchedEffect(key1 = "launch") {
            client.subscribe<List<Task>>("tasks:get").collect { result ->
                result.onSuccess { remoteTasks ->
                    tasks = remoteTasks
                }
            }
        }
        LazyColumn(
            modifier = modifier
        ) {
            items(tasks) { task ->
                Text(text = "Text: ${task.text}, Completed?: ${task.isCompleted}")
            }
        }
    }
```

--------------------------------

### QUERY /messages.getMessagesWithImageUrl

Source: https://www.convex.dev/components/cloudflare-r2

Retrieves all messages from the database and enriches them with pre-signed URLs for their associated images stored in R2. The URLs are valid for 1 day. This is an example of fetching data and transforming it using R2's `getUrl` function.

```APIDOC
## QUERY /messages.getMessagesWithImageUrl

### Description
Retrieves all messages from the database and enriches them with pre-signed URLs for their associated images stored in R2. The URLs are valid for 1 day. This is an example of fetching data and transforming it using R2's `getUrl` function.

### Method
QUERY

### Endpoint
/messages.getMessagesWithImageUrl

### Parameters
#### Path Parameters
- No path parameters.

#### Query Parameters
- No query parameters.

#### Request Body
- No request body. The query takes no arguments.

### Request Example
{}

### Response
#### Success Response (200)
- **array** (array of objects) - An array of message objects, each augmented with an `imageUrl` field.
  - **_id** (id) - The unique ID of the message.
  - **_creationTime** (number) - The creation timestamp of the message.
  - **imageKey** (string) - The R2 object key for the message's image.
  - **imageUrl** (string) - A pre-signed URL to access the image, valid for 1 day.

#### Response Example
```json
[
  {
    "_id": "123",
    "_creationTime": 1678886400000,
    "text": "Hello from Convex!",
    "imageKey": "my-image.jpg",
    "imageUrl": "https://example.com/r2/my-image.jpg?Expires=..."
  }
]
```
```

--------------------------------

### Convex Integration with Separate Script File and Types

Source: https://docs.convex.dev/client/javascript/script-tag

This example shows how to manage Convex integration in a separate JavaScript file (`script.js`) referenced from an HTML file. It leverages JSDoc type annotations for TypeScript autocompletion in VS Code and includes functionality to display messages and send new messages via mutations.

```html
<!doctype html>
<form>
  <input placeholder="type here" />
</form>
<div class="messages"></div>

<script src="https://unpkg.com/convex@1.3.1/dist/browser.bundle.js"></script>
<!--VS Code TypeScript autocompletion doesn't work in HTML files so use a file-->
<script src="./script.js"></script>
```

```javascript
const CONVEX_URL = "CONVEX_URL_GOES_HERE";

// These JSDoc type annotations help VS Code find types.
/** @type {import("convex/browser")["ConvexClient"]} */
const ConvexClient = convex.ConvexClient;
const client = new ConvexClient(CONVEX_URL);

/** @type {import("./convex/_generated/api")["api"]} */
const api = convex.anyApi;

client.onUpdate(api.messages.list, {}, (messages) => {
  console.log(messages);
  const container = document.querySelector(".messages");
  container.innerHTML = "";
  for (const message of messages.reverse()) {
    const li = document.createElement("li");
    li.textContent = `${message.author}: ${message.body}`;
    container.appendChild(li);
  }
});

document.querySelector("form").addEventListener("submit", (e) => {
  e.preventDefault();
  const inp = e.target.querySelector("input");
  client.mutation(api.messages.send, {
    body: inp.value,
    author: "me",
  });
  inp.value = "";
});
```

--------------------------------

### Filter Convex documents using comparison operators (TypeScript)

Source: https://docs.convex.dev/database/reading-data/filters

Illustrates how to query for documents based on numerical comparisons in Convex. This example uses `q.gte` from `FilterBuilder` to retrieve all users from the `users` table whose age is 18 or higher.

```TypeScript
const adults = await ctx.db
  .query("users")
  .filter((q) => q.gte(q.field("age"), 18))
  .collect();
```

--------------------------------

### Live-updating Convex Query with TanStack useQuery

Source: https://context7_llms

Demonstrates how to subscribe to a live-updating Convex query using TanStack Query's useQuery hook with the convexQuery helper. Returns data, loading state, and error handling for real-time data synchronization.

```typescript
import { useQuery } from "@tanstack/react-query";
import { convexQuery } from "@convex-dev/react-query";
import { api } from "../convex/_generated/api";

export function App() {
  const { data, isPending, error } = useQuery(
    convexQuery(api.functions.myQuery, { id: 123 }),
  );
  return isPending ? "Loading..." : data;
}
```

--------------------------------

### Define Convex Schema with Array Field

Source: https://context7_llms

Defines a Convex table schema for posts with a body string field and tags array field containing strings. This schema structure is used as the basis for the filtering examples that follow.

```javascript
export default defineSchema({
  posts: defineTable({
    body: v.string(),
    tags: v.array(v.string()),
  }),
});
```

--------------------------------

### Use asyncMap from convex-helpers - JavaScript

Source: https://stack.convex.dev/functional-relationships-helpers

Demonstrates importing and using the asyncMap utility from convex-helpers library for fetching multiple documents in parallel. Shows both getAll and getManyVia equivalent patterns.

```javascript
import { asyncMap } from "convex-helpers";

// getAll equivalent
const users = await asyncMap(userIds, doc => db.get(doc));
// or even
const users = await asyncMap(userIds, db.get);

// getManyVia equivalent
const categories = await asyncMap(
  await getManyFrom(db, "postCategories", "postId", post._id),
  (link) => db.get(link.categoryId)
);
```

--------------------------------

### Initialize ConvexClient with deployment URL in Swift

Source: https://docs.convex.dev/client/swift

Creates a single instance of ConvexClient by providing your Convex backend deployment URL. This client maintains the connection to your backend and should be stored as a global constant for the lifetime of the application. The actual connection is established lazily when the first method is called on the client.

```swift
import ConvexMobile

let convex = ConvexClient(deploymentUrl: "https://<your domain here>.convex.cloud")
```

--------------------------------

### Hook API Setup for Rate Limit Checking in Convex

Source: https://context7_llms

Exposes the getRateLimit function via the rate limiter's hookAPI to enable client-side rate limit status checks. Associates rate limits with authenticated users using getAuthUserId and targets the 'sendMessage' rate limit rule. Returns both getRateLimit and getServerTime for use in React components.

```typescript
export const { getRateLimit, getServerTime } = rateLimiter.hookAPI<DataModel>(
  "sendMessage",
  { key: (ctx) => getAuthUserId(ctx) },
);
```

--------------------------------

### Convex Query Handler - listMessages (Anti-pattern)

Source: https://docs.convex.dev/understanding/best-practices

An anti-pattern example showing a Convex query that uses ctx.runQuery to call another query handler. This pattern is inefficient because it creates unnecessary sequential calls and should instead use direct function imports from the model layer.

```typescript
export const listMessages = query({
  args: {
    conversationId: v.id("conversations"),
  },
  handler: async (ctx, { conversationId }) => {
    const user = await ctx.runQuery(api.users.getCurrentUser);
    const conversation = await ctx.db.get("conversations", conversationId);
    if (conversation === null || !conversation.members.includes(user._id)) {
      throw new Error("Unauthorized");
    }
    const messages = /* query ctx.db to load the messages */
    return messages;
  },
});
```

--------------------------------

### Create Task Mutation in Convex TypeScript

Source: https://docs.convex.dev/functions/mutation-functions

Basic mutation example that accepts a text argument and inserts a new task into the database. Returns the newly created task ID. Demonstrates named arguments, database insertion using ctx.db.insert(), and returning a value to the client.

```typescript
import { mutation } from "./\u005fgenerated/server";
import { v } from "convex/values";

// Create a new task with the given text
export const createTask = mutation({
  args: { text: v.string() },
  handler: async (ctx, args) => {
    const newTaskId = await ctx.db.insert("tasks", { text: args.text });
    return newTaskId;
  },
});
```

--------------------------------

### Execute Agent Action with Thread Generation

Source: https://context7_llms

Create a Convex action that initializes a thread, generates a prompt based on input parameters, and calls agent.generateText to process the prompt through the LLM. Returns the generated text response after LLM processing.

```typescript
import { action } from "./_generated/server";
import { v } from "convex/values";

export const helloWorld = action({
  args: { city: v.string() },
  handler: async (ctx, { city }) => {
    const threadId = await createThread(ctx, components.agent);
    const prompt = `What is the weather in ${city}?`;
    const result = await agent.generateText(ctx, { threadId }, { prompt });
    return result.text;
  },
});
```

--------------------------------

### Insert Document and Get Auto-Generated ID in Convex

Source: https://docs.convex.dev/database/document-ids

Demonstrates inserting a new document into the Convex database and receiving its automatically generated globally unique ID. The ID is returned from the insert operation and can be used for future document operations.

```typescript
const userId = await ctx.db.insert("users", { name: "Michael Jordan" });
```

--------------------------------

### General Convex Data Import via CLI

Source: https://context7_llms

Initiate a general data import into your Convex deployment from a local file. This command typically prompts for additional information or uses default settings for the import process.

```shell
npx convex import
```

--------------------------------

### Call a component function from another Convex application function (TypeScript)

Source: https://docs.convex.dev/components/authoring

This example illustrates how to execute a function defined in a Convex component (e.g., `myComponent.hello.world`) from within a function of the main application. It imports `components` from `_generated/api` and uses `ctx.runQuery` to invoke the component's query, demonstrating inter-component communication.

```typescript
import { components } from "./_generated/api";
import { query } from "./_generated/server";

export default query({
  handler: async (ctx) => {
    return await ctx.runQuery(components.myComponent.hello.world);
  }
});
```

--------------------------------

### Query First Document in Convex Database

Source: https://docs.convex.dev/database/indexes/indexes-and-query-perf

Retrieves the first document inserted into a Convex database table. This is an extremely fast operation as it only requires accessing a single document without scanning the entire table. Useful for getting the oldest entry or a quick sample.

```JavaScript
const firstBook = await ctx.db.query("books").first();
```

--------------------------------

### Navigate to Convex App Folder (Terminal)

Source: https://docs.convex.dev/chef

After downloading and unzipping your Convex app from Chef, use this command in your terminal to navigate into the app's directory. It is recommended to rename the folder to your app's name for convenience before executing this command.

```bash
cd ~/<app folder>
```

--------------------------------

### Initialize Convex React Client with Next.js Environment Variable

Source: https://context7_llms

Creates a ConvexReactClient instance using the NEXT_PUBLIC_CONVEX_URL environment variable. Next.js requires public environment variables to be prefixed with NEXT_PUBLIC_ and accessed via process.env. This initialization connects the Convex client to your backend deployment.

```typescript
import { ConvexProvider, ConvexReactClient } from "convex/react";

const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL);
```

--------------------------------

### Server-side Document Transformation with Pre-computed Content and Concurrency Check

Source: https://www.convex.dev/components/prosemirror-sync

This example illustrates a server-side document transformation using `prosemirrorSync.transform` where slower operations, like AI content generation, are performed beforehand. It fetches the document and its version using `prosemirrorSync.getDoc`, then passes a custom transformation function. The function demonstrates how to directly use `ProseMirror.Transform` and includes a check for concurrent modifications to the document version (`v !== version`). It inserts pre-generated content at the beginning of the document.

```typescript
import { Transform } from "@tiptap/pm/transform";
// An example of doing slower AI operations beforehand:
const schema = getSchema(extensions);
const { doc, version } = await prosemirrorSync.getDoc(ctx, id, schema);
const content = await generateAIContent(doc);
await prosemirrorSync.transform(ctx, id, schema, (doc, v) => {
  if (v !== version) {
    // Decide what to do if the document changes.
  }
  // An example of using Transform directly.
  const tr = new Transform(doc);
  tr.insert(0, schema.text(content));
  return tr;
});
```

--------------------------------

### Server Module - Query Interface

Source: https://context7_llms

The Query interface provides methods for building and executing database queries. It allows filtering, sorting, and pagination of documents from Convex tables.

```APIDOC
## Query<TableInfo>

### Description
Interface for building and executing queries against Convex database tables. Supports filtering, sorting, and pagination of documents.

### Module
server

### Properties
- **filter** (function) - Optional - Apply filter conditions to query results
- **order** (function) - Optional - Order results by specified field
- **paginate** (function) - Optional - Paginate query results

### Usage Example
```typescript
import { query } from 'convex/server';

export const getUsers = query({
  handler: async (ctx) => {
    return await ctx.db.query('users')
      .filter(q => q.eq(q.field('status'), 'active'))
      .order('asc')
      .collect();
  }
});
```

### Related Interfaces
- OrderedQuery<TableInfo> - For ordered query results
- PaginationOptions - Configuration for pagination
- QueryInitializer<TableInfo> - Query initialization
```

--------------------------------

### Mount Re-exported Counter API in App in TypeScript

Source: https://docs.convex.dev/components/authoring

Demonstrates how to mount exported API functions from a component into an application's own Convex API. The counter module's add and get functions are imported and instantiated with custom authentication logic that checks user IDs and enforces write permission requirements.

```typescript
// In the app's convex/counter.ts
import { makeCounterAPI } from "@convex-dev/counter";
import { components } from "./_generated/server.js";

export const { add, get } = makeCounterAPI(components.counter, {
  auth: async (ctx, operation) => {
    const userId = await getAuthUserId(ctx);
    // Check if the user has permission to perform the operation
    if (operation === "write" && !userId) {
      throw new Error("User not authenticated");
    }
    return userId;
  },
});
```

--------------------------------

### Export Convex Deployment Data to File via CLI

Source: https://docs.convex.dev/database/backup-restore

Download a backup of your Convex deployment data as a ZIP file using the command line. This generates a snapshot containing all documents from all tables in JSONL format, with optional file storage metadata. The resulting ZIP file is named with format snapshot_{ts}.zip where ts is a UNIX timestamp in nanoseconds.

```bash
npx convex export --path ~/Downloads
```

--------------------------------

### Migrate Document Subset Using Index

Source: https://www.convex.dev/components/migrations

Use customRange with an index to migrate only a filtered subset of documents, avoiding full table processing. This example uses the by_requiredField index to find documents with empty required fields and applies a patch through shorthand syntax.

```typescript
export const validateRequiredField = migrations.define({
  table: "myTable",
  customRange: (query) => query.withIndex("by_requiredField", (q) => q.eq("requiredField", "")),
  migrateOne: async (_ctx, doc) => {
    console.log("Needs fixup: " + doc._id);
    // Shorthand for patching
    return { requiredField: "" };
  }
});
```

--------------------------------

### Sending File Reference in a Convex Message (TypeScript)

Source: https://docs.convex.dev/agents/files

This example shows how to send a message containing a file or image reference to a Convex agent. It retrieves file parts, constructs a message with either file or image content, and associates metadata including the `fileId` for tracking.

```typescript
// in your mutation
const { filePart, imagePart } = await getFile(ctx, components.agent, fileId);
const { messageId } = await fileAgent.saveMessage(ctx, {
  threadId,
  message: {
    role: "user",
    content: [
      imagePart ?? filePart, // if it's an image, prefer that kind.
      { type: "text", text: "What is this image?" },
    ],
  },
  metadata: { fileIds: [fileId] }, // IMPORTANT: this tracks the file usage.
});
```

--------------------------------

### Get Messages Sent From a Phone Number

Source: https://www.convex.dev/components/twilio

Query all messages sent from a specific phone number. This method filters messages by the source 'from' field and returns matching message records.

```TypeScript
export const getMessagesFrom = query({
  args: { from: v.string() },
  handler: async (ctx, args) => {
    return await twilio.getMessagesFrom(ctx, args);
  },
});
```

--------------------------------

### Chaining LLM Tool Calls for Weather and Fashion Advice (TypeScript)

Source: https://docs.convex.dev/agents/workflows

This TypeScript Convex action demonstrates a simple agentic workflow that chains two LLM tool calls. It first uses a `weatherAgent` to get a weather forecast for a given location, then a `fashionAgent` to provide fashion advice based on that weather, all within a single thread. Messages are automatically saved, and clients receive updates via subscriptions, eliminating the need for a direct return value.

```typescript
export const getAdvice = action({
  args: { location: v.string(), threadId: v.string() },
  handler: async (ctx, { location, threadId }) => {
    // This uses tool calls to get the weather forecast.
    await weatherAgent.generateText(
      ctx,
      { threadId },
      { prompt: `What is the weather in ${location}?` },
    );
    // This includes previous message history from the thread automatically and
    // uses tool calls to get user-specific fashion advice.
    await fashionAgent.generateText(
      ctx,
      { threadId },
      { prompt: `What should I wear based on the weather?` },
    );
    // We don't need to return anything, since the messages are saved
    // automatically and clients will get the response via subscriptions.
  },
});
```

--------------------------------

### Get Messages Sent To a Phone Number

Source: https://www.convex.dev/components/twilio

Query all messages sent to a specific phone number. This method filters messages by the destination 'to' field and returns matching message records.

```TypeScript
export const getMessagesTo = query({
  args: { to: v.string() },
  handler: async (ctx, args) => {
    return await twilio.getMessagesTo(ctx, args);
  },
});
```

--------------------------------

### Filtering Messages in a Channel Not Sent by a Specific User (JavaScript)

Source: https://docs.convex.dev/database/reading-data/indexes

This example shows how to combine index-based filtering with an in-memory `filter` method. It first uses the `by_channel` index to retrieve all messages in a specific channel and then applies a `filter` condition to exclude messages where the `user` field matches `myUserId`.

```javascript
const messages = await ctx.db
  .query("messages")
  .withIndex("by_channel", (q) => q.eq("channel", channel))
  .filter((q) => q.neq(q.field("user"), myUserId))
  .collect();
```

--------------------------------

### Define Convex Server-Side Query and Mutation Functions

Source: https://docs.convex.dev/api/modules/server

These examples illustrate how to create server-side functions in Convex using the `query` and `mutation` wrappers. Query functions are read-only and receive a `GenericDatabaseReader`, while mutation functions allow for database writes and receive a `GenericDatabaseWriter`. Both are typically imported from the generated `_generated/server` file.

```javascript
import { query } from "./_generated/server";

export default query({
  handler: async ({ db }, { arg1, arg2 }) => {
    // Your (read-only) code here!
  },
});
```

```javascript
import { mutation } from "./_generated/server";

export default mutation({
  handler: async ({ db }, { arg1, arg2 }) => {
    // Your mutation code here!
  },
});
```

--------------------------------

### Get client-backend connection state in Convex TypeScript

Source: https://context7_llms

The `connectionState` function returns the current `ConnectionState` between the client and the Convex backend. This function is essential for monitoring the network status and ensuring that the client is properly synchronized with the server. It provides real-time information about the connection's health.

```typescript
connectionState();
// Returns: ConnectionState
```

--------------------------------

### Get authentication token from Auth0 in Next.js

Source: https://docs.convex.dev/client/nextjs/app-router/server-rendering

Provides the implementation of getAuthToken using Auth0's authentication service (version 4.3 or later). Extracts the ID token from the Auth0 session tokenSet.

```TypeScript
import { getSession } from '@auth0/nextjs-auth0';

export async function getAuthToken() {
  const session = await getSession();
  const idToken = session.tokenSet.idToken;
  return idToken;
}
```

--------------------------------

### Create ConvexReactClient Instance

Source: https://docs.convex.dev/client/react

Initialize a ConvexReactClient instance by importing it from 'convex/react' and providing your Convex backend deployment URL. This client manages the connection to your backend and is essential for all subsequent Convex operations.

```TypeScript
import { ConvexProvider, ConvexReactClient } from "convex/react";

const convex = new ConvexReactClient("https://<your domain here>.convex.cloud");
```

--------------------------------

### Basic Convex Query Filter with Limited Functionality

Source: https://stack.convex.dev/complex-filters-in-convex

Demonstrates the standard Convex query filter syntax using the query builder API. This example shows filtering posts by channel using the eq() method, which represents the basic capabilities of Convex's built-in filter functionality.

```typescript
export const messages = query({
  args: { channel: v.string() },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("posts")
      .filter((q) => q.eq(q.field("channel"), args.channel))
      .collect();
  },
});
```

--------------------------------

### Configure Message Storage Options for Text Generation

Source: https://context7_llms

Demonstrates how to control which messages are persisted to the database when generating text. Supports options to save all messages, none, or only prompt and output messages for flexible message management.

```javascript
const result = await thread.generateText({ messages }, {
  storageOptions: {
    saveMessages: "all" | "none" | "promptAndOutput",
  },
});
```

--------------------------------

### Retrieve JWT Token from Auth0 Provider

Source: https://context7_llms

Fetches the JWT token (id_token) from Auth0 authentication provider using the useAuth0 hook. Makes an asynchronous call to get the access token silently with detailed response metadata included.

```javascript
import { useAuth0 } from "@auth0/auth0-react";

const { getAccessTokenSilently } = useAuth0();
const response = await getAccessTokenSilently({
  detailedResponse: true,
});
const token = response.id_token;
console.log(token);
```

--------------------------------

### Define a Basic TableAggregate for a Convex Table

Source: https://www.convex.dev/components/aggregate

Illustrates the basic setup of a `TableAggregate` for a generic Convex table. It defines a `sortKey` to allow queries across time ranges and a `sumValue` for use in sum calculations, demonstrating how to bridge table data to the aggregate structure.

```typescript
import { components } from "./_generated/api";
import { DataModel } from "./_generated/dataModel";
import { mutation as rawMutation } from "./_generated/server";
import { TableAggregate } from "@convex-dev/aggregate";

const aggregate = new TableAggregate<{
  Key: number;
  DataModel: DataModel;
  TableName: "mytable";
}>(components.aggregate, {
  sortKey: (doc) => doc._creationTime, // Allows querying across time ranges.
  sumValue: (doc) => doc.value, // The value to be used in `.sum` calculations.
});
```

--------------------------------

### Optimistically insert item at top of paginated Convex query (TypeScript)

Source: https://context7_llms

This example demonstrates how to use `insertAtTop` within a Convex `useMutation`'s `withOptimisticUpdate` callback. It inserts a new task item into a paginated list of tasks, ensuring it appears at the very top of the list immediately, before the actual mutation completes. The `argsToMatch` parameter helps identify which paginated query instance to update.

```typescript
const createTask = useMutation(api.tasks.create)
  .withOptimisticUpdate((localStore, mutationArgs) => {
  insertAtTop({
    paginatedQuery: api.tasks.list,
    argsToMatch: { listId: mutationArgs.listId },
    localQueryStore: localStore,
    item: { _id: crypto.randomUUID() as Id<"tasks">, title: mutationArgs.title, completed: false },
  });
});
```

--------------------------------

### Get First Convex Query Result (TypeScript)

Source: https://context7_llms

This function executes the query and attempts to retrieve only the very first result. It returns a Promise that resolves to either the first document found or `null` if the query yields no results. This is useful when you expect at most one result or only care about the initial item.

```TypeScript
first(): Promise<null | DocumentByInfo<TableInfo>>
```

--------------------------------

### Configure `require-argument-validators` ESLint Rule (JavaScript)

Source: https://docs.convex.dev/eslint

This configuration example demonstrates how to set up the `@convex-dev/require-args-validator` ESLint rule within `eslint.config.js`. It shows how to enable the `ignoreUnusedArguments` option, which allows functions without explicit argument validators if their handler doesn't consume any arguments.

```javascript
// eslint.config.js

export default defineConfig([
  // Your other rules

  {
    files: ["**/convex/**/*.ts"],
    rules: {
      "@convex-dev/require-args-validator": [
        "error",
        {
          ignoreUnusedArguments: true,
        },
      ],
    },
  },
]);
```

--------------------------------

### Filter Convex documents by exact equality (TypeScript)

Source: https://docs.convex.dev/database/reading-data/filters

Demonstrates how to query for documents in a Convex database where a specific field matches an exact value. This example uses `q.eq` from `FilterBuilder` to find all users named "Alex" in the `users` table.

```TypeScript
const usersNamedAlex = await ctx.db
  .query("users")
  .filter((q) => q.eq(q.field("name"), "Alex"))
  .collect();
```

--------------------------------

### POST /deployments/:deployment_name/create_custom_domain

Source: https://context7_llms

Configure a custom domain for a deployment. Enables routing traffic from a custom domain to your Convex deployment.

```APIDOC
## POST /deployments/:deployment_name/create_custom_domain

### Description
Create custom domain for a deployment.

### Method
POST

### Endpoint
/deployments/:deployment_name/create_custom_domain

### Authentication
Bearer Token (obtained through Convex OAuth application)

### Path Parameters
- **deployment_name** (string) - Required - The name of the deployment

### Request Body
- **domain** (string) - Required - The custom domain to configure

### Response
#### Success Response (200)
- **custom_domain** (object) - Custom domain configuration details
  - **domain** (string) - The configured domain
  - **status** (string) - Configuration status
  - **created_at** (string) - ISO 8601 timestamp

### Error Responses
- **400** - Bad Request - Invalid domain or deployment name
- **401** - Unauthorized - Invalid or missing authentication token
- **404** - Not Found - Deployment does not exist
```

--------------------------------

### Configure Monthly Cron Job for Invoice Generation

Source: https://context7_llms

Sets up a monthly cron job that triggers invoice generation on the 2nd day of each month at 00:00 UTC. This allows a one-day buffer after the billing period ends before generating invoices, ensuring all usage data for the previous month is captured.

```TypeScript
import { cronJobs } from "convex/server";
import { internal } from "./_generated/api";

const crons = cronJobs();

crons.monthly(
  "generateInvoices",
  { day: 2, hourUTC: 0, minuteUTC: 0 },
  internal.usage.generateInvoices,
  {}
);

export default crons;
```

--------------------------------

### Check Workflow Status Using WorkflowId

Source: https://convex.dev/components/workflow

Start a workflow and retrieve its status using the returned WorkflowId. The workflow.status() method returns the current execution state which can be monitored at any time after workflow initiation.

```typescript
export const kickoffWorkflow = action({
  handler: async (ctx) => {
    const workflowId = await workflow.start(
      ctx,
      internal.example.exampleWorkflow,
      { name: "James" },
    );
    await new Promise((resolve) => setTimeout(resolve, 1000));
    const status = await workflow.status(ctx, workflowId);
    console.log("Workflow status after 1s", status);
  },
});
```

--------------------------------

### Enqueue Actions to Workpool in Mutation

Source: https://www.convex.dev/components/workpool

Enqueue actions to a workpool from a mutation handler to throttle execution. This example shows separating email verification work from data scraping work by enqueueing them to different pools with different parallelism limits.

```typescript
export const userSignUp = mutation({
  args: {...},
  handler: async (ctx, args) => {
    const userId = await ctx.db.insert("users", args);
    await emailPool.enqueueAction(ctx, internal.auth.sendEmailVerification, {
      userId,
    });
  },
});

export const downloadLatestWeather = mutation({
  handler: async (ctx, args) => {
    for (const city of allCities) {
      await scrapePool.enqueueAction(ctx, internal.weather.scrape, {
        city
      });
    }
  },
});
```

--------------------------------

### Perform Basic Aggregation Operations with Convex Aggregate

Source: https://www.convex.dev/components/aggregate

These TypeScript examples demonstrate fundamental aggregation operations using the Convex Aggregate component. They cover counting total items, counting with specific bounds, calculating percentiles, computing overall averages, and finding the index (ranking) of a value, all with efficient O(log n) lookups.

```typescript
// Count the total number of scores
aggregate.count(ctx);
// Count scores greater than 65
aggregate.count(ctx, { bounds: { lower: { key: 65, inclusive: false } } });
// Find the 95th percentile score
aggregate.at(ctx, Math.floor(aggregate.count(ctx) * 0.95));
// Find the overall average score
aggregate.sum(ctx) / aggregate.count(ctx);
// Find the ranking for a score of 65
aggregate.indexOf(ctx, 65);
```

--------------------------------

### React Query: Display Tasks with useSuspenseQuery

Source: https://context7_llms

Renders a list of tasks in a React component using Convex and React Query integration. The `useSuspenseQuery` hook executes the `api.tasks.get` query on the server initially, then updates live in the browser. Requires React Router for route setup and maps task data to display text.

```typescript
import { convexQuery } from "@convex-dev/react-query";
import { useSuspenseQuery } from "@tanstack/react-query";
import { createFileRoute } from "@tanstack/react-router";
import { api } from "../../convex/_generated/api";

export const Route = createFileRoute("/")({ component: Home });

function Home() {
  const { data } = useSuspenseQuery(convexQuery(api.tasks.get, {}));

  return (
    <div>
      {data.map(({ _id, text }) => (
        <div key={_id}>{text}</div>
      ))}
    </div>
  );
}
```

--------------------------------

### Test Chained Convex Scheduled Functions with Vitest

Source: https://docs.convex.dev/testing/convex-test

This example illustrates how to test a sequence of recursively scheduled Convex functions, such as a chain of mutations or actions. It utilizes `t.finishAllScheduledFunctions()` in conjunction with `vi.runAllTimers` to repeatedly advance time and ensure all dependent scheduled operations are completed. The test then asserts the resulting state after all functions have finished.

```typescript
import { convexTest } from "convex-test";
import { expect, test, vi } from "vitest";
import { api } from "./_generated/api";
import schema from "./schema";

test("mutation scheduling action scheduling action", async () => {
  // Enable fake timers
  vi.useFakeTimers();

  const t = convexTest(schema, modules);

  // Call a function that schedules a mutation or action
  await t.mutation(api.scheduler.mutationSchedulingActionSchedulingAction);

  // Wait for all scheduled functions, repeatedly
  // advancing time and waiting for currently in-progress
  // functions to finish
  await t.finishAllScheduledFunctions(vi.runAllTimers);

  // Assert the resulting state after all scheduled functions finished
  const createdTask = await t.run(async (ctx) => {
    return await ctx.db.query("tasks").first();
  });
  expect(createdTask).toMatchObject({ author: "AI" });

  // Reset to normal `setTimeout` etc. implementation
  vi.useRealTimers();
});

const modules = import.meta.glob("./**/*.ts");
```

--------------------------------

### Fetch Convex Query Data in Next.js API Route

Source: https://context7_llms

Creates a Next.js API route handler that queries Convex data using the fetchQuery function. This example retrieves click counter data and returns it as JSON. The fetchQuery function allows loading and editing Convex data in API endpoints, useful when dependencies aren't supported by Convex's default runtime.

```typescript
import type { NextApiRequest, NextApiResponse } from "next";
import { fetchQuery } from "convex/nextjs";
import { api } from "../../convex/_generated/api";

export const count = async function handler(
  _req: NextApiRequest,
  res: NextApiResponse,
) {
  const clicks = await fetchQuery(api.counter.get, { counterName: "clicks" });
  res.status(200).json({ clicks });
};
```

--------------------------------

### Generate Image with OpenAI DALL-E and Save to Thread

Source: https://context7_llms

Execute a CLI command to run the generateImage function which takes a prompt, generates an image using OpenAI's DALL-E 2 model, and saves the generated image to a conversation thread for retrieval and display.

```bash
npx convex run files:generateImage:replyWithImage '{prompt: "make a picture of a cat" }'
```

--------------------------------

### Configure TypeScript Compiler for Convex Project

Source: https://docs.convex.dev/production/project-configuration

Override the default `tsc` binary by setting `typescriptCompiler` to `tsgo` in your `convex.json` to leverage the TypeScript 7 native preview. This requires `@typescript/native-preview` to be installed in your project and a Convex NPM package version of 1.31.1 or later. Using `tsgo` can offer improved typechecking performance.

```json
{
  "$schema": "https://raw.githubusercontent.com/get-convex/convex-backend/refs/heads/main/npm-packages/convex/schemas/convex.schema.json",
  "typescriptCompiler": "tsgo"
}
```

--------------------------------

### Define a Convex Action with Typed Arguments

Source: https://docs.convex.dev/functions/actions

This example shows how to define a Convex action that accepts and validates input arguments using `convex/values`. The `args` object specifies the expected types, allowing the handler function to access these arguments safely and perform operations based on the provided data.

```TypeScript
import { action } from "./_generated/server";
import { v } from "convex/values";

export const doSomething = action({
  args: { a: v.number(), b: v.number() },
  handler: (_, args) => {
    // do something with `args.a` and `args.b`
    // optionally return a value
    return "success";
  },
});
```

--------------------------------

### Set Clerk Development Publishable Key in .env.local (Environment Variable)

Source: https://docs.convex.dev/auth/clerk

This environment variable configuration sets `VITE_CLERK_PUBLISHABLE_KEY` in `.env.local` for development environments. This key, formatted as `pk_test_...`, is used by Clerk's frontend SDK to initialize authentication, enabling development-specific configurations.

```Environment Variable
VITE_CLERK_PUBLISHABLE_KEY="pk_test_..."
```

--------------------------------

### Define Basic Convex Agent with OpenAI

Source: https://context7_llms

This snippet demonstrates how to define a basic AI agent in Convex using the `@convex-dev/agent` library. It initializes an `Agent` instance with a static name and integrates an OpenAI language model (`gpt-4o-mini`) via `@ai-sdk/openai`. The agent can then be used for various LLM operations.

```typescript
import { components } from "./_generated/api";
import { Agent } from "@convex-dev/agent";
import { openai } from "@ai-sdk/openai";

const agent = new Agent(components.agent, {
  name: "Basic Agent",
  languageModel: openai.chat("gpt-4o-mini")
});
```

--------------------------------

### Example R2 Object Metadata Document Structure

Source: https://www.convex.dev/components/cloudflare-r2

This JSON snippet illustrates the structure of the metadata returned by `r2.getMetadata`. It includes `ContentType` (MIME type), `ContentLength` (size in bytes), and `LastModified` (timestamp).

```json
{
  "ContentType": "image/jpeg",
  "ContentLength": 125338,
  "LastModified": "2024-03-20T12:34:56Z"
}
```

--------------------------------

### Send to a Dynamically Created Event by ID in Convex

Source: https://convex.dev/components/workflow

This example illustrates how to send a signal or data to an event that was dynamically created. By providing the `eventId`, the `sendEvent` function targets the specific dynamic event.

```typescript
await workflow.sendEvent(ctx, { id: eventId });
```

--------------------------------

### Call an Internal Mutation from a Convex Action

Source: https://docs.convex.dev/functions/actions

This example demonstrates how to write data to the database from a Convex action by invoking an internal mutation using `ctx.runMutation`. Using an internal mutation prevents direct client calls, providing a secure way to modify data. Actions and mutations can coexist within the same file.

```TypeScript
import { v } from "convex/values";
import { action } from "./_generated/server";
import { internal } from "./_generated/api";

export const doSomething = action({
  args: { a: v.number() },
  handler: async (ctx, args) => {
    const data = await ctx.runMutation(internal.myMutations.writeData, { a: args.a });
    // do something else, optionally use `data`
  },
});
```

--------------------------------

### Simplify Internal Function Calls in Convex Workflows (TypeScript)

Source: https://www.convex.dev/components/workflow

This example demonstrates a technique to reduce verbosity when calling internal Convex functions within a workflow. By aliasing a common prefix, such as `internal.steps`, to a shorter variable, workflow definitions become more concise and readable. This is particularly useful when working with many helper functions defined in a shared module.

```typescript
const s = internal.steps;
export const myWorkflow = workflow.define({
  args: { prompt: v.string() },
  handler: async (step, args): Promise<any> => {
    const result = await step.runAction(s.myAction, args);
    return result;
  }
});
```

--------------------------------

### Initialize and test Convex component with convex-test

Source: https://docs.convex.dev/components/authoring

Sets up a Convex test instance with schema and modules, then demonstrates basic component testing by inserting data into a component table. This pattern should be used for testing local component functionality with the convex-test library.

```typescript
import { test } from "vitest";
import { convexTest } from "convex-test";
import schema from "./schema.ts";
const modules = import.meta.glob("./**/*.ts");

export function initConvexTest() {
  const t = convexTest(schema, modules);
  return t;
}

test("Test something with a local component", async () => {
  const t = initConvexTest();
  // Test like you would normally.
  await t.run(async (ctx) => {
    await ctx.db.insert("myComponentTable", { name: "test" });
  });
});
```

--------------------------------

### Basic Reactive Query in React with Convex and TanStack Query

Source: https://docs.convex.dev/client/tanstack/tanstack-query

This example demonstrates how to integrate a Convex query function into a React component using TanStack Query's `useQuery` hook with `convexQuery`. It fetches live-updating data from `api.functions.myQuery` and conditionally renders 'Loading...' while the data is being fetched, showcasing a simple reactive data subscription pattern.

```tsx
import { useQuery } from "@tanstack/react-query";
import { convexQuery } from "@convex-dev/react-query";
import { api } from "../convex/_generated/api";

export function App() {
  const { data, isPending, error } = useQuery(
    convexQuery(api.functions.myQuery, { id: 123 })
  );
  return isPending ? "Loading..." : data;
}
```

--------------------------------

### Delete Embeddings from Vector Index

Source: https://docs.convex.dev/agents/context

Removes a batch of embeddings from the vector index based on their IDs. This is necessary when embeddings need to be cleared, for example, if the vector dimension changes and old embeddings are no longer compatible.

```typescript
await ctx.runMutation(components.agent.vector.index.deleteBatch, {
  ids: [embeddingId1, embeddingId2],
});
```

--------------------------------

### Initialize Python Virtual Environment

Source: https://context7_llms

This command creates a new Python virtual environment named 'venv' inside the 'my-app' directory. A virtual environment isolates project dependencies, preventing conflicts with other Python projects.

```bash
python3 -m venv my-app/venv
```

--------------------------------

### Airbyte Streaming Import Request Body Example

Source: https://docs.convex.dev/streaming-import-api

This JSON structure represents the expected payload for the `import_airbyte_records` endpoint. It defines table schemas, including primary keys and JSON schemas, and provides a list of messages containing data to be inserted or updated.

```json
{
   "tables": {
      "<stream_name>": {
         "primaryKey": [["<field1>"], ["<field2>", "<nested_field>"]],
         "jsonSchema": // see https://json-schema.org/ for examples
      }
   },
   "messages": [{
      "tableName": "<table_name>",
      "data": {} // JSON object conforming to the `json_schema` for that stream
   }]
}
```

--------------------------------

### Server Module - Storage Interface

Source: https://context7_llms

StorageReader, StorageWriter, and StorageActionWriter interfaces provide file storage operations including reading, writing, and managing files in Convex storage.

```APIDOC
## StorageReader

### Description
Interface for reading files from Convex storage. Provides methods to retrieve and access stored files.

### Module
server

### Methods
- **getUrl** (storageId) - Get public URL for stored file
- **getMetadata** (storageId) - Retrieve file metadata

---

## StorageWriter

### Description
Interface for writing files to Convex storage. Used in mutations to store new files.

### Module
server

### Methods
- **store** (file) - Store file and return storage ID
- **delete** (storageId) - Delete stored file

---

## StorageActionWriter

### Description
Interface for writing files to storage in action functions. Extends StorageWriter with action-specific capabilities.

### Module
server

### Methods
- **store** (file) - Store file from action context
- **generateUploadUrl** () - Generate URL for client uploads

### Usage Example
```typescript
export const uploadFile = action({
  handler: async (ctx, file) => {
    const storageId = await ctx.storage.store(file);
    return await ctx.db.insert('files', {
      storageId,
      uploadedAt: Date.now()
    });
  }
});
```
```

--------------------------------

### Filter Documents with OR Operator - TypeScript/JavaScript

Source: https://context7_llms

Combines multiple filter conditions using the or() operator to find documents matching any of the conditions. The example finds all users named either 'Alex' or 'Emma' by combining two equality filters with logical OR.

```typescript
// Get all users named "Alex" or "Emma".
const usersNamedAlexOrEmma = await ctx.db
  .query("users")
  .filter((q) =>
    q.or(q.eq(q.field("name"), "Alex"), q.eq(q.field("name"), "Emma"))
  )
  .collect();
```

--------------------------------

### Wrap Convex Component Calls with a Client-Side TypeScript Function

Source: https://docs.convex.dev/components/authoring

This code provides an example of creating a simple client-side function (`callMyFunction`) to wrap calls to a Convex component's mutation. It illustrates how to leverage `Pick` to define specialized `MutationCtx` and `ActionCtx` types, enabling flexibility in context usage. This pattern allows for pre-processing, adding shared utilities, or other environment-specific logic before invoking the component's function.

```typescript
import type {
  GenericActionCtx,
  GenericDataModel,
  GenericMutationCtx
} from "convex/server";
import type { ComponentApi } from "../component/_generated/component.js";

export async function callMyFunction(
  ctx: MutationCtx | ActionCtx,
  component: ComponentApi,
  args: ...
) {
  // You can create function handles, add shared utilities,
  // or do any processing that needs to run in the app's environment.
  const functionHandle = await createFunctionHandle(args.someFn);
  const someArg = process.env.SOME_ARG;
  await ctx.runMutation(component.call.fn, {
    ...args,
    someArg,
    functionHandle
  });
}

// Useful types for functions that only need certain capabilities.
type MutationCtx = Pick<GenericMutationCtx<GenericDataModel>, "runMutation">;
type ActionCtx = Pick<
  GenericActionCtx<GenericDataModel>,
  "runQuery" | "runMutation" | "runAction"
>;
```

--------------------------------

### Perform Manual Pagination Outside React with Convex ConvexHttpClient

Source: https://docs.convex.dev/database/pagination

This example demonstrates how to perform manual pagination in a non-React environment (e.g., a server-side script or CLI) using `ConvexHttpClient`. It iteratively calls a paginated Convex query function, managing the `continueCursor` and `isDone` flags to collect all pages of results into a single array. Dependencies include `convex/browser`, your Convex API types, and `dotenv` for environment configuration.

```typescript
import { ConvexHttpClient } from "convex/browser";
import { api } from "../convex/_generated/api";
import * as dotenv from "dotenv";

dotenv.config();

const client = new ConvexHttpClient(process.env.VITE_CONVEX_URL!);

/**
 * Logs an array containing all messages from the paginated query "listMessages"
 * by combining pages of results into a single array.
 */
async function getAllMessages() {
  let continueCursor = null;
  let isDone = false;
  let page;

  const results = [];

  while (!isDone) {
    ({ continueCursor, isDone, page } = await client.query(api.messages.list, {
      paginationOpts: { numItems: 5, cursor: continueCursor },
    }));
    console.log("got", page.length);
    results.push(...page);
  }

  console.log(results);
}

getAllMessages();
```

--------------------------------

### Convex: Batching Database Operations in Actions

Source: https://docs.convex.dev/functions/actions

This example illustrates an anti-pattern of making multiple separate `ctx.runQuery` or `ctx.runMutation` calls within a Convex action. This approach can lead to inconsistent data reads due to separate transactions and introduces unnecessary overhead from multiple function calls. The recommended solution is to create a single internal query or mutation that performs all necessary database operations in one consistent transaction, thereby improving both performance and data integrity.

```javascript
//  const foo = await ctx.runQuery(...)
const bar = await ctx.runQuery(...)
//  const fooAndBar = await ctx.runQuery(...)
```

--------------------------------

### Configure Vite Build Output and Base Path in vite.config.mts

Source: https://context7_llms

Set up Vite configuration to specify the production build output directory and the base URL path for serving the application. The outDir field directs Vite to place the build in the 'docs' folder, which GitHub Pages supports. The base field specifies the URL path where your app will be served.

```typescript
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  build: {
    outDir: "docs"
  },
  base: "/some-repo-name/"
});
```

--------------------------------

### Implement Single Flighting with useSingleFlight Hook (React/TypeScript)

Source: https://stack.convex.dev/throttling-requests-by-single-flighting

This example illustrates how to use the `useSingleFlight` helper hook to control the execution of an asynchronous function, such as a Convex mutation. `useSingleFlight` ensures that the provided function, `updatePresence` in this case, runs at most once concurrently. If multiple calls occur while one is in progress, it will re-run the function with the most recent arguments after the current execution finishes.

```typescript
const updatePresence = useMutation(api.presence.update);
const tryUpdate = useSingleFlight(updatePresence);
return (
  <div onMouseMove={e =>
    tryUpdate({
      x: e.clientX,
      y: e.clientY,
    })
  }>...</div>
);
```

--------------------------------

### Initialize Rate Limiter with Multiple Strategies

Source: https://www.convex.dev/components/rate-limiter

Set up a rate limiter instance with multiple named rate limit configurations using token bucket and fixed window strategies. Supports sharding to increase throughput. The token bucket strategy allows token accumulation up to capacity, while fixed window grants tokens all at once per period.

```typescript
const rateLimiter = new RateLimiter(ctx, {
  signUp: { kind: "token bucket", rate: 10, period: MINUTE, capacity: 3 },
  failedLogins: { kind: "token bucket", rate: 10, period: HOUR },
  llmTokens: { kind: "token bucket", rate: 40000, period: MINUTE, shards: 10 },
  llmRequests: { kind: "fixed window", rate: 1000, period: MINUTE, shards: 10 }
});
```

--------------------------------

### Trigger Data Mutation with Arguments and Return Type (Kotlin)

Source: https://docs.convex.dev/client/android

Shows how to trigger a backend mutation function using the Convex client. This example demonstrates passing arguments to the mutation and specifying the expected return type, which is an Int representing the number of records deleted. Mutations can also be configured to not return a value.

```kotlin
val recordsDeleted = convex.mutation<@ConvexNum Int>(
  "messages:cleanup",
  args = mapOf("keepLatest" to 100)
)
```

--------------------------------

### Convex Deployment Command for Netlify

Source: https://docs.convex.dev/production/hosting/netlify

This command is used to override the Netlify build process. It initiates a Convex deployment and subsequently runs the frontend build command. The `CONVEX_DEPLOY_KEY` environment variable, set in Netlify, is crucial for authentication.

```bash
npx convex deploy --cmd 'npm run build'
```

--------------------------------

### Configure Vitest environments for Convex and frontend (TypeScript)

Source: https://docs.convex.dev/testing/convex-test

Configure `vitest.config.ts` to specify different test environments based on file paths. This setup uses `edge-runtime` for tests within the `convex/` directory and `jsdom` for all other tests, which is ideal for projects with both Convex functions and a React frontend. It also inlines `convex-test` dependencies.

```typescript
import { defineConfig } from "vitest/config";

export default defineConfig({
  test: {
    environmentMatchGlobs: [
      // all tests in convex/ will run in edge-runtime
      ["convex/**", "edge-runtime"],
      // all other tests use jsdom
      ["**", "jsdom"]
    ],
    server: { deps: { inline: ["convex-test"] } }
  }
});
```

```typescript
import { defineConfig } from "vitest/config";

export default defineConfig({
  test: {
    environment: "edge-runtime",
    server: { deps: { inline: ["convex-test"] } }
  }
});
```

--------------------------------

### Create References to Convex Functions for Client-Side Invocation

Source: https://docs.convex.dev/api/modules/server

These snippets demonstrate how to obtain references to registered Convex functions, which are essential for client-side invocation. The first example uses the generated `api` utility for a type-safe reference, while the second shows how to use `anyApi` from `convex/server` when code generation is not employed. Such references are then passed to client-side hooks like `useQuery`.

```javascript
import { api } from "../convex/_generated/api";
const reference = api.myModule.myFunction;
```

```javascript
import { anyApi } from "convex/server";
const reference = anyApi.myModule.myFunction;
```

```javascript
const result = useQuery(api.myModule.myFunction);
```

--------------------------------

### Post-generation Token Usage Tracking with Convex Agent in TypeScript

Source: https://docs.convex.dev/agents/rate-limiting

Tracks token usage after an LLM generates a response using the `usageHandler` in the Convex Agent. It consumes token usage with `rateLimiter.limit` and uses `reserve: true` to handle potential overages, preventing further requests until the 'debt' is paid. This requires the `@convex-dev/rate-limiter` package and a configured `Agent` instance.

```typescript
import { Agent, type Config } from "@convex-dev/rate-limiter";

const sharedConfig = {
  usageHandler: async (ctx, { usage, userId }) => {
    if (!userId) {
      return;
    }
    // We consume the token usage here, once we know the full usage.
    // This is too late for the first generation, but prevents further requests
    // until we've paid off that debt.
    await rateLimiter.limit(ctx, "tokenUsage", {
      key: userId,
      // You could weight different kinds of tokens differently here.
      count: usage.totalTokens,
      // Reserving the tokens means it won't fail here, but will allow it
      // to go negative, disallowing further requests at the `check` call below.
      reserve: true,
    });
  },
} satisfies Config;

// use it in your agent definitions
const agent = new Agent(components.agent, {
  name,
  languageModel,
  ...sharedConfig,
});
```

--------------------------------

### Configure Raw LLM Request/Response Logging (Convex Agent)

Source: https://context7_llms

This snippet shows how to configure an `Agent` instance to log raw LLM requests and responses. By providing a `rawRequestResponseHandler` function, developers can inspect the exact data sent to and received from the Language Model, useful for detailed debugging and integration with external logging services.

```javascript
const supportAgent = new Agent(components.agent, {
  ...
  rawRequestResponseHandler: async (ctx, { request, response }) => {
    console.log("request", request);
    console.log("response", response);
  },
});
```

--------------------------------

### Define Multiple Indexes on Convex Table Schema

Source: https://docs.convex.dev/database/reading-data/indexes

Create a Convex schema with two indexes on a messages table. The first index orders by channel, and the second orders by both channel and user fields. The example demonstrates using the index() method chained on table definitions with field arrays as parameters.

```typescript
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

// Define a messages table with two indexes.
export default defineSchema({
  messages: defineTable({
    channel: v.id("channels"),
    body: v.string(),
    user: v.id("users"),
  })
    .index("by_channel", ["channel"])
    .index("by_channel_user", ["channel", "user"]),
});
```

--------------------------------

### GET /api/document_deltas

Source: https://docs.convex.dev/streaming-export-api

This endpoint provides a chronological log of document changes, including new, updated, and deleted records. Each document's mutation order is determined by its `_ts` (timestamp) field, with deletions explicitly marked.

```APIDOC
## GET /api/document_deltas

### Description
The `document_deltas` endpoint walks the change log of documents to find new, updated, and deleted documents in the order of their mutations. This order is given by a `_ts` field on the returned documents. Deletions are represented as JSON objects with fields `_id`, `_ts`, and `_deleted: true`.

### Method
GET

### Endpoint
/api/document_deltas

### Parameters
#### Path Parameters
_None_

#### Query Parameters
- **cursor** (int) - Required - Database timestamp after which to continue streaming document deltas. Initial value is the `snapshot` field returned from list_snapshot.
- **tableName** (string) - Optional - If provided, filters the document deltas to a table. If omitted, provide deltas across all tables.
- **format** (string) - Optional - Output format for values. Valid values: [`json`]

### Response
#### Success Response (200)
- **values** (List[ConvexValue]) - List of convex values in the requested format. Each value includes extra fields for `_ts`, and `_table`. Deletions include a field `_deleted`.
- **hasMore** (boolean) - True if there are more pages to the snapshot.
- **cursor** (int) - A value that represents the database timestamp at the end of the page. Pass to subsequent calls to document_deltas.

#### Response Example
```json
{
  "values": [
    {
      "_id": "doc123",
      "_ts": 1678886400000,
      "_table": "users",
      "name": "Alice",
      "email": "alice@example.com"
    },
    {
      "_id": "doc456",
      "_ts": 1678886401000,
      "_table": "products",
      "_deleted": true
    }
  ],
  "hasMore": true,
  "cursor": 1678886401000
}
```
```

--------------------------------

### Define Index with Configuration

Source: https://context7_llms

Define an index on a table with full configuration options including staging capability. This method allows you to specify index name, fields to index, and whether the index should be staged for deferred enablement on large tables.

```APIDOC
## index(name, indexConfig)

### Description
Define an index on this table with optional staging configuration. Staging an index allows you to push the schema without blocking completion on large tables, enabling the index later.

### Method
Function

### Parameters

#### Required Parameters
- **name** (IndexName) - Required - The name of the index. Must be a string.
- **indexConfig** (Object) - Required - The index configuration object.
  - **indexConfig.fields** ([FirstFieldPath, ...RestFieldPaths[]) - Required - The fields to index, in order. Must specify at least one field.

#### Optional Parameters
- **indexConfig.staged?** (false) - Optional - Whether the index should be staged. For large tables, index backfill can be slow. Staging an index allows you to push the schema and enable the index later. If `staged` is `true`, the index will be staged and will not be enabled until the staged flag is removed. Staged indexes do not block push completion. Staged indexes cannot be used in queries.

### Type Parameters
| Name | Type |
|------|------|
| IndexName | extends string |
| FirstFieldPath | extends any |
| RestFieldPaths | extends ExtractFieldPaths<DocumentType>[] |

### Returns

TableDefinition<DocumentType, Expand<Indexes & Record<IndexName, [FirstFieldPath, ...RestFieldPaths[], "_creationTime"]>>, SearchIndexes, VectorIndexes>

A TableDefinition with this index included.

### Response Example
```
TableDefinition with index configuration applied and staged flag if specified
```

### Reference
Defined in: server/schema.ts:235
```

--------------------------------

### Filter Documents by Comparison - TypeScript/JavaScript

Source: https://context7_llms

Filters documents using comparison operators to find values greater than, less than, or equal to a threshold. The example finds all users with age 18 or higher using the gte() operator. Supports operators: eq, neq, lt, lte, gt, gte for comparisons.

```typescript
// Get all users with an age of 18 or higher.
const adults = await ctx.db
  .query("users")
  .filter((q) => q.gte(q.field("age"), 18))
  .collect();
```

--------------------------------

### Query Messages by Channel with Time Range Filter

Source: https://docs.convex.dev/database/indexes

Shows how to query documents using the withIndex() method with an index range expression. This example queries messages in a specific channel created between 1-2 minutes ago using the by_channel index. The query demonstrates equality filtering on the channel field and range filtering on the _creationTime field.

```typescript
const messages = await ctx.db
  .query("messages")
  .withIndex("by_channel", (q) => q
    .eq("channel", channel)
    .gt("_creationTime", Date.now() - 2 * 60000)
    .lt("_creationTime", Date.now() - 60000),
  )
  .collect();
```

--------------------------------

### Implement Argument Validation for Convex Mutations (TypeScript)

Source: https://context7_llms

This example illustrates how to correctly implement argument validation for Convex mutation functions. It contrasts a vulnerable mutation that can update any document with a secure version that restricts updates to a specific table ('messages') and validates the types and optionality of fields like 'body' and 'author' using `v.id` and `v.object`.

```typescript
//  -- could be used to update any document (not just `messages`)
export const updateMessage = mutation({
  handler: async (ctx, { id, update }) => {
    await ctx.db.patch(id, update);
  },
});
```

```typescript
//  -- can only be called with an ID from the messages table, and can only update
// the `body` and `author` fields
export const updateMessage = mutation({
  args: {
    id: v.id("messages"),
    update: v.object({
      body: v.optional(v.string()),
      author: v.optional(v.string()),
    }),
  },
  handler: async (ctx, { id, update }) => {
    await ctx.db.patch(id, update);
  },
});
```

--------------------------------

### Perform Grouped Aggregations with Prefix Bounds in Convex

Source: https://www.convex.dev/components/aggregate

This TypeScript example shows how to perform aggregations on data grouped by a specific prefix, such as a username. It demonstrates calculating high scores and average scores for an individual user, as well as a global average, where `aggregateScoreByUser` is an aggregate pre-grouped by username.

```typescript
// aggregateScoreByUser is the leaderboard scores grouped by username.
const bounds = { prefix: [username] };
const highScoreForUser = await aggregateScoreByUser.max(ctx, { bounds });
const avgScoreForUser = (await aggregateScoreByUser.sum(ctx, { bounds })) / (await aggregateScoreByUser.count(ctx, { bounds }));
// It still enables adding or averaging all scores across all usernames.
const globalAverageScore = (await aggregateScoreByUser.sum(ctx)) / (await aggregateScoreByUser.count(ctx));
```

--------------------------------

### GET /getAuthorMessages/{authorId}

Source: https://docs.convex.dev/functions/http-actions

This endpoint retrieves messages for a specific author, where the author's identifier is provided as a path parameter. It showcases the use of path prefixes in Convex's HTTP router for dynamic routing.

```APIDOC
## GET /getAuthorMessages/{authorId}

### Description
Retrieves messages associated with a specific author, identified by a path parameter. This endpoint uses a path prefix to define a dynamic route segment for the author ID.

### Method
GET

### Endpoint
/getAuthorMessages/{authorId}

### Parameters
#### Path Parameters
- **authorId** (string) - Required - The unique identifier or name of the author whose messages are to be retrieved.

#### Query Parameters
- No query parameters.

#### Request Body
- No request body.

### Request Example
N/A

### Response
#### Success Response (200)
- **messages** (array of objects) - A list of message objects, each containing `id`, `author`, and `body`, belonging to the specified author.

#### Response Example
```json
[
  {
    "id": "789",
    "author": "User 456",
    "body": "Message from User 456"
  },
  {
    "id": "101",
    "author": "User 456",
    "body": "Hello again from User 456"
  }
]
```
```

--------------------------------

### Combine multiple conditions with AND in Convex filters (TypeScript)

Source: https://docs.convex.dev/database/reading-data/filters

Explains how to construct more complex filters by combining multiple conditions using the `q.and` operator. This example queries the `users` table to find all users named "Alex" who are also 18 years of age or older.

```TypeScript
const adultAlexes = await ctx.db
  .query("users")
  .filter((q) =>
    q.and(q.eq(q.field("name"), "Alex"), q.gte(q.field("age"), 18)),
  )
  .collect();
```

--------------------------------

### Get File Metadata from Convex Storage

Source: https://docs.convex.dev/api/interfaces/server.StorageWriter

Retrieves metadata for a file stored in Convex storage using a StorageId. Returns a FileMetadata object if the file exists, or null if not found. Inherited from the StorageReader interface.

```typescript
getMetadata(storageId: T extends { __tableName: any } ? never : T): Promise<null | FileMetadata>
```

--------------------------------

### Update Mutation to Schedule Wikipedia Action

Source: https://context7_llms

Modifies the sendMessage mutation to detect messages starting with '/wiki' and schedule the getWikipediaSummary action using Convex's durable scheduler. The scheduler ensures actions are only queued if the mutation transaction succeeds. Extracts the topic from the message and passes it to the internal action.

```TypeScript
import { api, internal } from "./_generated/api";

export const sendMessage = mutation({
  args: {
    user: v.string(),
    body: v.string(),
  },
  handler: async (ctx, args) => {
    console.log("This TypeScript function is running on the server.");
    await ctx.db.insert("messages", {
      user: args.user,
      body: args.body,
    });

    if (args.body.startsWith("/wiki")) {
      const topic = args.body.slice(args.body.indexOf(" ") + 1);
      await ctx.scheduler.runAfter(0, internal.chat.getWikipediaSummary, {
        topic,
      });
    }
  },
});
```